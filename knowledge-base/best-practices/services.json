[
  {
    "id": "bp-006",
    "topic": "services",
    "rule": "Always use app.service() to get services",
    "rationale": "The service returned by app.service() has all Feathers functionality (hooks, events, etc.). Using the raw service object directly bypasses these features.",
    "goodExample": "// Correct: use app.service()\nconst messages = app.service('messages')\nconst result = await messages.find()",
    "badExample": "// Wrong: using the raw service object\nconst rawService = new MessageService()\nconst result = await rawService.find() // No hooks, no events!",
    "version": "v5",
    "tags": [
      "services",
      "usage",
      "hooks"
    ]
  },
  {
    "id": "bp-007",
    "topic": "services",
    "rule": "Use TypeScript generics for type safety",
    "rationale": "Define ServiceTypes on the app and use typed service methods for compile-time safety.",
    "goodExample": "type ServiceTypes = {\n  messages: MessageService\n  users: UserService\n}\nconst app = feathers<ServiceTypes>()\n// app.service('messages') is now fully typed",
    "badExample": "// No type safety\nconst app = feathers()\n// app.service('messages') returns unknown type",
    "version": "v5",
    "tags": [
      "services",
      "typescript",
      "types"
    ]
  },
  {
    "id": "bp-008",
    "topic": "services",
    "rule": "Register services with explicit methods option",
    "rationale": "Use the methods option to explicitly control which methods are available externally. This improves security by limiting the API surface.",
    "goodExample": "app.use('payments', new PaymentService(), {\n  methods: ['create', 'get', 'find'] // only expose needed methods\n})",
    "badExample": "// Dangerous: all methods exposed by default\napp.use('payments', new PaymentService())\n// Now update, patch, remove are all available externally",
    "version": "v5",
    "tags": [
      "services",
      "security",
      "methods"
    ]
  },
  {
    "id": "bp-009",
    "topic": "services",
    "rule": "Use params.query for filtering, params for internal data",
    "rationale": "Keep query parameters separate from internal params. params.query is for database queries; use custom params properties for internal context.",
    "goodExample": "// Good: separate concerns\napp.service('messages').hooks({\n  before: {\n    find: [async (context) => {\n      // Internal data on params\n      context.params.user = await getUser(context)\n      // Database filtering on params.query\n      context.params.query.$sort = { createdAt: -1 }\n    }]\n  }\n})",
    "badExample": "// Bad: mixing internal data into query\napp.service('messages').hooks({\n  before: {\n    find: [async (context) => {\n      context.params.query.user = await getUser(context) // This gets sent to DB!\n    }]\n  }\n})",
    "version": "v5",
    "tags": [
      "services",
      "params",
      "query"
    ]
  },
  {
    "id": "bp-010",
    "topic": "services",
    "rule": "Handle paginated and non-paginated results correctly",
    "rationale": "Service find() returns either paginated (object with data array) or non-paginated (plain array) results. Handle both cases.",
    "goodExample": "// Good: handle both result types\nconst result = await app.service('messages').find({ query })\nconst items = Array.isArray(result) ? result : result.data\nconst total = Array.isArray(result) ? result.length : result.total",
    "badExample": "// Bug: assuming always paginated\nconst result = await app.service('messages').find()\nconst items = result.data // Crashes if paginate: false\nconst total = result.total // undefined if not paginated",
    "version": "v5",
    "tags": [
      "services",
      "pagination",
      "find"
    ]
  }
]