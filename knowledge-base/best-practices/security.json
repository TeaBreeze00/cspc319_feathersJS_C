[
  {
    "id": "bp-011",
    "topic": "security",
    "rule": "Never expose internal errors to clients",
    "rationale": "Internal errors can leak sensitive information about your system. Sanitize errors in application error hooks.",
    "goodExample": "app.hooks({\n  error: {\n    all: [async (context) => {\n      if (!context.error.code) {\n        context.error = new GeneralError('Internal server error')\n      }\n      if (process.env.NODE_ENV === 'production') {\n        context.error.stack = undefined\n      }\n    }]\n  }\n})",
    "badExample": "// Bad: raw errors sent to client\n// No error hooks - database errors go directly to client\n// Client sees: \"SQLITE_CONSTRAINT: UNIQUE constraint failed: users.email\"",
    "version": "both",
    "tags": [
      "security",
      "errors",
      "production"
    ]
  },
  {
    "id": "bp-012",
    "topic": "security",
    "rule": "Use resolveExternal for safe response data",
    "rationale": "Always use resolveExternal to create safe representations of data that is sent to external clients. This prevents leaking sensitive fields like passwords.",
    "goodExample": "const userExternalResolver = resolve<User, HookContext>({\n  password: async () => undefined, // Always remove password\n  internalNotes: async () => undefined,\n})\n\napp.service('users').hooks({\n  around: {\n    all: [resolveExternal(userExternalResolver)]\n  }\n})",
    "badExample": "// Bad: manually trying to remove fields in after hooks\n// Easy to miss fields, doesn't handle nested/associated data\napp.service('users').hooks({\n  after: { all: [protect('password')] } // deprecated pattern\n})",
    "version": "both",
    "tags": [
      "security",
      "resolver",
      "password"
    ]
  },
  {
    "id": "bp-013",
    "topic": "security",
    "rule": "Validate and sanitize all input data",
    "rationale": "Always validate incoming data with schemas. Use TypeBox or JSON Schema validators in the hook chain before any data processing.",
    "goodExample": "// Schema-based validation\nconst messageDataValidator = getValidator(messageDataSchema, dataValidator)\napp.service('messages').hooks({\n  before: {\n    create: [schemaHooks.validateData(messageDataValidator)],\n    patch: [schemaHooks.validateData(messageDataValidator)]\n  }\n})",
    "badExample": "// Bad: trusting client data without validation\napp.service('messages').hooks({\n  before: {\n    create: [async (context) => {\n      // No validation - client could send anything\n      // SQL injection, XSS, huge payloads all possible\n    }]\n  }\n})",
    "version": "both",
    "tags": [
      "security",
      "validation",
      "input",
      "schema"
    ]
  },
  {
    "id": "bp-014",
    "topic": "security",
    "rule": "Use query resolvers to restrict access",
    "rationale": "Use resolveQuery to ensure users can only access their own data or data they are authorized to see.",
    "goodExample": "const messageQueryResolver = resolve<MessageQuery, HookContext>({\n  userId: async (value, query, context) => {\n    // Regular users can only see their own messages\n    if (context.params.user && !context.params.user.isAdmin) {\n      return context.params.user.id\n    }\n    return value\n  }\n})",
    "badExample": "// Bad: relying on client to send correct userId\n// Client could query any user's messages\napp.service('messages').hooks({\n  before: {\n    find: [] // no query restriction - anyone sees everything\n  }\n})",
    "version": "both",
    "tags": [
      "security",
      "authorization",
      "query",
      "resolver"
    ]
  },
  {
    "id": "bp-015",
    "topic": "security",
    "rule": "Rate-limit authentication attempts",
    "rationale": "Protect authentication endpoints from brute force attacks by limiting login attempts per IP or account.",
    "goodExample": "// Use rate-limiting middleware\nimport rateLimit from 'express-rate-limit'\n\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 attempts per window\n  message: 'Too many login attempts'\n})\n\napp.use('/authentication', authLimiter)",
    "badExample": "// Bad: no rate limiting on authentication\n// Allows unlimited brute force attempts\napp.use('authentication', authentication)",
    "version": "both",
    "tags": [
      "security",
      "rate-limit",
      "authentication",
      "brute-force"
    ]
  }
]