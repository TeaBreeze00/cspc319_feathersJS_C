[
  {
    "id": "bp-021",
    "topic": "performance",
    "rule": "Use pagination for find queries",
    "rationale": "Always enable pagination to prevent loading entire datasets into memory. Set sensible defaults and maximums.",
    "goodExample": "const options = {\n  paginate: {\n    default: 10,  // return 10 items by default\n    max: 100      // never return more than 100\n  }\n}\napp.use('messages', new KnexService(options))",
    "badExample": "// Dangerous: no pagination\napp.use('messages', new KnexService({ paginate: false }))\n// service.find() could return millions of records",
    "version": "v5",
    "tags": [
      "performance",
      "pagination",
      "database"
    ]
  },
  {
    "id": "bp-022",
    "topic": "performance",
    "rule": "Use $select to limit response fields",
    "rationale": "Use $select in queries to only return needed fields. Reduces data transfer and improves response times.",
    "goodExample": "// Only fetch id and text fields\nconst messages = await app.service('messages').find({\n  query: { $select: ['id', 'text'] }\n})",
    "badExample": "// Bad: fetching all fields when only a few are needed\nconst messages = await app.service('messages').find()\n// Returns every field including large content, metadata, etc.",
    "version": "v5",
    "tags": [
      "performance",
      "query",
      "select",
      "database"
    ]
  },
  {
    "id": "bp-023",
    "topic": "performance",
    "rule": "Use hookless methods for bulk operations",
    "rationale": "Prefix methods with _ (e.g., _find, _patch) for server-only operations that bypass hooks. Much faster for migrations and bulk updates.",
    "goodExample": "// Fast: bypass hooks for internal migration\nconst allUsers = await app.service('users')._find({ paginate: false })\nawait app.service('users')._patch(null, { migrated: true })",
    "badExample": "// Slow: every record goes through all hooks\nconst allUsers = await app.service('users').find({ paginate: false })\nfor (const user of allUsers) {\n  await app.service('users').patch(user.id, { migrated: true })\n}",
    "version": "v5",
    "tags": [
      "performance",
      "hookless",
      "bulk",
      "database"
    ]
  },
  {
    "id": "bp-024",
    "topic": "performance",
    "rule": "Avoid N+1 queries with resolvers",
    "rationale": "Use batch resolvers or dataloader patterns to avoid fetching related data one record at a time.",
    "goodExample": "// Good: batch loading with a single query\nconst messageResultResolver = resolve<Message, HookContext>({\n  user: virtual(async (message, context) => {\n    // This gets called per-record but can be batch-optimized\n    return context.app.service('users').get(message.userId)\n  })\n})\n// Better: use a dataloader for batching\nimport DataLoader from 'dataloader'",
    "badExample": "// Bad: N+1 query pattern\nconst messages = await app.service('messages').find()\nfor (const msg of messages.data) {\n  msg.user = await app.service('users').get(msg.userId) // N queries!\n}",
    "version": "v5",
    "tags": [
      "performance",
      "n+1",
      "resolver",
      "dataloader"
    ]
  },
  {
    "id": "bp-025",
    "topic": "performance",
    "rule": "Index database fields used in queries",
    "rationale": "Create database indexes for fields commonly used in $sort, query filters, and $select. Without indexes, queries scan entire tables.",
    "goodExample": "// Good: create indexes for queried fields\nexport async function up(knex: Knex) {\n  await knex.schema.createTable('messages', (table) => {\n    table.increments('id')\n    table.string('text')\n    table.integer('userId').index() // indexed for lookups\n    table.bigInteger('createdAt').index() // indexed for sorting\n  })\n}",
    "badExample": "// Bad: no indexes on frequently queried columns\nexport async function up(knex: Knex) {\n  await knex.schema.createTable('messages', (table) => {\n    table.increments('id')\n    table.string('text')\n    table.integer('userId') // no index - slow lookups\n    table.bigInteger('createdAt') // no index - slow sorting\n  })\n}",
    "version": "v5",
    "tags": [
      "performance",
      "database",
      "index",
      "query"
    ]
  }
]