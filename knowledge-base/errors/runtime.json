[
  {
    "id": "err-018",
    "pattern": "MethodNotAllowed: Method .* is not supported",
    "cause": "Called a service method that is not implemented or not listed in the `methods` option.",
    "solution": "Implement the missing method on the service, or add it to the `methods` option in `app.use()`. Check spelling of method name.",
    "example": "app.use(\"myservice\", new MyService(), { methods: [\"find\", \"get\", \"create\", \"myCustomMethod\"] })",
    "version": "both",
    "tags": [
      "service",
      "method",
      "405"
    ],
    "category": "runtime"
  },
  {
    "id": "err-019",
    "pattern": "Timeout: Operation timed out",
    "cause": "A service method or database query took too long to complete.",
    "solution": "Check database connection. Optimize slow queries. Increase timeout configuration if appropriate. Check for deadlocks.",
    "example": "app.use(\"messages\", new MessageService(), { timeout: 10000 })",
    "version": "both",
    "tags": [
      "timeout",
      "performance",
      "database"
    ],
    "category": "runtime"
  },
  {
    "id": "err-020",
    "pattern": "NotImplemented: .* is not implemented",
    "cause": "The service does not implement the called method (find, get, create, etc.).",
    "solution": "Implement the required method on your service class. Feathers automatically throws NotImplemented for missing standard methods.",
    "example": "class MyService { async find(params: Params) { return [] } /* implement needed methods */ }",
    "version": "both",
    "tags": [
      "service",
      "method",
      "501"
    ],
    "category": "runtime"
  },
  {
    "id": "err-021",
    "pattern": "NotFound: Service .* not found",
    "cause": "Tried to access a service that has not been registered with `app.use()`.",
    "solution": "Check the service path spelling. Ensure the service is registered before it is accessed. Verify import/configuration order.",
    "example": "app.use(\"messages\", new MessageService()); const svc = app.service(\"messages\"); // path must match exactly",
    "version": "both",
    "tags": [
      "service",
      "registration",
      "404"
    ],
    "category": "runtime"
  },
  {
    "id": "err-022",
    "pattern": "Error: .* is not a function",
    "cause": "Accessing the service object directly instead of through `app.service()`, or calling a method that doesn't exist.",
    "solution": "Always use `app.service(path)` to access services, not the raw service object. Check method name spelling.",
    "example": "const svc = app.service(\"messages\"); await svc.find(); // NOT: await rawServiceObj.find()",
    "version": "both",
    "tags": [
      "service",
      "usage",
      "TypeError"
    ],
    "category": "runtime"
  },
  {
    "id": "err-023",
    "pattern": "Error: Channel .* does not exist",
    "cause": "Tried to publish or send to a channel that has no connections or hasn't been created.",
    "solution": "Ensure connections join the channel (e.g., on login). Check channel naming. Channels only exist while they have connections.",
    "example": "app.on(\"login\", (result, { connection }) => { if (connection) app.channel(\"authenticated\").join(connection) })",
    "version": "both",
    "tags": [
      "channels",
      "real-time",
      "connection"
    ],
    "category": "runtime"
  }
]