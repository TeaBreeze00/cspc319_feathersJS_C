[
  {
    "id": "err-runtime-hook-not-returning",
    "pattern": "Hook function.*did not return|should return a hook context|hook.*undefined",
    "cause": "A hook function did not return the context object. All hooks must return the context.",
    "solution": "Ensure every hook function ends with 'return context;'. For async hooks, make sure the function is async and returns context after awaiting operations.",
    "example": "Error: A hook function for 'before:create' did not return a hook context"
  },
  {
    "id": "err-runtime-service-not-found",
    "pattern": "Can not find service|service.*not.*registered|No service.*found",
    "cause": "Attempting to call a service that has not been registered with the app.",
    "solution": "Verify the service name matches exactly (case-sensitive, no leading slash in v5). Check that the service is registered in your services/index file: app.configure(services);",
    "example": "Error: Can not find service 'messages'. Did you forget to register it?"
  },
  {
    "id": "err-runtime-method-not-allowed",
    "pattern": "Method.*not allowed|is not a function|service\\.\\w+ is not a function",
    "cause": "Calling a service method (find, get, create, etc.) that is not implemented by the service.",
    "solution": "Implement the missing method in your service class, or if deliberately missing, add a before hook using disallow() to return a 405 error instead of a confusing TypeError.",
    "example": "TypeError: service.update is not a function"
  },
  {
    "id": "err-runtime-invalid-params",
    "pattern": "Invalid query parameter|Unexpected.*\\$\\w+|invalid.*\\$limit|not allowed",
    "cause": "The query contains parameters that are not allowed by the service's query schema or sanitization.",
    "solution": "Check your query against the service's allowed query properties. In v5, ensure your query schema includes the operators you need. Common issue: using $select, $sort, $limit with values that don't match the schema type.",
    "example": "BadRequest: Invalid query parameter '$populate'"
  },
  {
    "id": "err-runtime-circular-dependency",
    "pattern": "Maximum call stack size exceeded|circular.*dependency|RangeError",
    "cause": "A hook or service method triggers itself recursively (e.g., an after:create hook that calls create on the same service).",
    "solution": "Use params.provider check to prevent hooks from re-triggering: if (context.params.provider) { ... }. Or pass { _skipHooks: true } as a custom param.",
    "example": "RangeError: Maximum call stack size exceeded"
  },
  {
    "id": "err-runtime-missing-id",
    "pattern": "id.*must not be null|missing.*id|id.*required|No id",
    "cause": "Calling get, patch, update, or remove without providing a valid ID.",
    "solution": "Ensure you pass a valid ID (string or number) as the first argument: service.get(id). For multi operations, use service.patch(null, data, { query: ... }).",
    "example": "NotFound: No record found for id 'undefined'"
  }
]
