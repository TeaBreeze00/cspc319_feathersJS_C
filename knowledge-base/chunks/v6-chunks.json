[
  {
    "id": "v6-application-0",
    "content": "# Application\nBreadcrumb: Application\nCovers: .use(path, service [, options]) | path | options | .unuse(path) | .service(path) | .lookup(path) | .hooks(hooks) | .publish([event, ] publisher) | .configure(callback) | .setup([server]) | .teardown([server]) | .listen(port) | .set(name, value) | .get(name) | .on(eventname, listener) | .emit(eventname, data) | .removeListener(eventname) | .mixins | .services | .defaultService\nTopics: hooks, services, context, params, provider, database, adapter, channels, events, rest, find, get, create, update, patch, remove, hook context, setup, teardown, application\n\n## .use(path, service [, options])\n\n`app.use(path, service [, options]) -> app` allows registering a [service object](./services) on a given `path`.\n\n```ts\nimport { feathers, type Id } from '@feathersjs/feathers'\n\nclass MessageService {\n  async get(id: Id) {\n    return {\n      id,\n      text: `This is the ${id} message!`\n    }\n  }\n}\n\ntype ServiceTypes = {\n  // Add services path to type mapping here\n  messages: MessageService\n}\n\nconst app = feathers<ServiceTypes>()\n\n// Register a service instance on the app\napp.use('messages', new MessageService())\n\n// Get the service and call the service method with the correct types\nconst message = await app.service('messages').get('test')\n```\n\n### path\n\nThe `path` is a string that should be URL friendly and may contain `/` as a separator. `path` can also be `/` to register a service at the root level. A path may contain placeholders in the form of `:userId/messages` which will be included in `params.route` by a transport.\n\n### options\n\nThe following options are available:\n\n- `methods` (default: `['find', 'get', 'create', 'patch', 'update','remove']`) - A list of official and [custom service methods](services#custom-methods) that should be available to clients. When using this option **all** method names that should be available externally must be passed. Those methods will automatically be available for use with [hooks](./hooks).\n- `events` - A list of [public custom events sent by this service](./events#custom-events)\n\n```ts\nimport { feathers, type Id, EventEmitter } from '@feathersjs/feathers'\n\n// Feathers services will always be event emitters\n// but we can also extend it for better type consistency\nclass MessageService extends EventEmitter {\n  async doSomething(data: { message: string }, params: Params) {\n    this.emit('something', 'I did something')\n    return data\n  }\n\n  async get(id: Id) {\n    return {\n      id,\n      text: `This is the ${id} message!`\n    }\n  }\n}\n\ntype ServiceTypes = {\n  // Add services path to type mapping here\n  messages: MessageService\n}\n\nconst app = feathers<ServiceTypes>()\n\n// Register a service with options\napp.use('messages', new MessageService(), {\n  methods: ['get', 'doSomething'],\n  events: ['something']\n})\n```\n\n<BlockQuote type=\"warning\">\nIf the `methods` property is `undefined`, all standard methods will be enabled and accessible externally.\n</BlockQuote>\n\n## .unuse(path)\n\n`app.unuse(path)` unregisters an existing service on `path` and calls the services [.teardown method](./services#teardownapp-path) if it is implemented.\n\n## .service(path)\n\n`app.service(path) -> service` returns the [service object](./services) for the given path. Feathers internally creates a new object from each registered service. This means that the object returned by `app.service(path)` will provide the same methods and functionality as your original service object but also functionality added by Feathers and its plugins like [service events](./events) and [additional methods](./services#feathers-functionality).\n\n```ts\nconst messageService = app.service('messages')\n\nconst message = await messageService.get('test')\n\nconsole.log(message)\n\nmessageService.on('created', (message: Message) => {\n  console.log('Created a todo')\n})\n```\n\n<BlockQuote type=\"note\">\nNote that a server side `app.service(path)` only allows the original service name (e.g. `app.service(':userId/messages')`) and does not parse placeholders. To get a service with route paramters use [.lookup](#lookuppath)\n</BlockQuote>\n\n## .lookup(path)\n\n`app.lookup(path)` allows to look up a full path and will return the `data` (route parameters) and `service` **on the server**.\n\n```ts\nconst lookup = app.lookup('messages/4321')\n\n// lookup.service -> app.service('messages')\n// lookup.data -> { __id: '4321' }\n\n// `lookup.dta` needs to be passed as `params.route`\nlookup.service.find({\n  route: lookup.data\n})\n```\n\nCase insensitive lookups can be enabled in the `app` file like this:\n\n```ts\napp.routes.caseSensitive = false\n```\n\n## .hooks(hooks)\n\n`app.hooks(hooks) -> app` allows registration of application-level hooks. For more information see the [application hooks section in the hooks chapter](./hooks#application-hooks).\n\n## .publish([event, ] publisher)\n\n`app.publish([event, ] publisher) -> app` registers a global event publisher. For more information see the [channels publishing](./channels#publishing) chapter.\n\n## .configure(callback)\n\n`app.configure(callback) -> app` runs a `callback` function that gets passed the application object. It is used to initialize plugins and can be used to separate your application into different files.\n\n```ts\nconst setupService = (app: Application) => {\n  app.use('/todos', todoService)\n}\n\napp.configure(setupService)\n```\n\n## .setup([server])\n\n`app.setup([server]) -> Promise<app>` is used to initialize all services by calling each [services .setup(app, path)](services#setupapp-path) method (if available).\nIt will also use the `server` instance passed (e.g. through `http.createServer`) to set up SocketIO (if enabled) and any other provider that might require the server instance. You can register [application setup hooks](./hooks#setup-and-teardown) to e.g. set up database connections and other things required to be initialized on startup in a certain order.\n\nNormally `app.setup` will be called automatically when starting the application via [app.listen([port])](#listen-port) but there are cases (like in tests) when it can be called explicitly.\n\n## .teardown([server])\n\n`app.teardown([server]) -> Promise<app>` can be called to gracefully shut down the application. When the app has been set up with a server (e.g. by calling `app.listen()`) the server will be closed automatically when calling `app.teardown()`. You can also register [application hooks](./hooks#setup-and-teardown) on teardown to e.g. close database connection etc.\n\n## .listen(port)\n\n`app.listen([port]) -> Promise<HTTPServer>` starts the application on the given port. It will set up all configured transports (if any) and then run [app.setup(server)](#setup-server) with the server object and then return the server object.\n\n`listen` will only be available if a server side transport (REST or websocket) has been configured.\n\n## .set(name, value)\n\n`app.set(name, value) -> app` assigns setting `name` to `value`.\n\n<BlockQuote type=\"danger\">\n`app.set` is global to the application. It is used for storing application wide information like database connection strings etc. **Do not use it for storing request or service specific data.** This can be done by adding data to the [hook context](./hooks#hook-context).\n</BlockQuote>\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\n\ntype ServiceTypes = {\n  // Add services path to type mapping here\n}\n\n// app.get and app.set can be typed when initializing the app\ntype Configuration = {\n  port: number\n}\n\nconst app = feathers<ServiceTypes, Configuration>()\n\napp.set('port', 3030)\n\napp.listen(app.get('port'))\n```\n\n<BlockQuote type=\"note\">\nOn the server, settings are usually initialized using [Feathers configuration](configuration).\n</BlockQuote>\n\n## .get(name)\n\n`app.get(name) -> value` retrieves the setting `name`.\n\n## .on(eventname, listener)\n\nProvided by the core [NodeJS EventEmitter .on](https://nodejs.org/api/events.html#events_emitter_on_eventname_listener). Registers a `listener` method (`function(data) {}`) for the given `eventname`.\n\n```js\napp.on('login', (user) => console.log('Logged in', user))\n```\n\n## .emit(eventname, data)\n\nProvided by the core [NodeJS EventEmitter .emit](https://nodejs.org/api/events.html#events_emitter_emit_eventname_args).\n\n```ts\ntype MyEventData = { message: string }\n\napp.emit('myevent', {\n  message: 'Something happened'\n})\n\napp.on('myevent', (data: MyEventData) => console.log('myevent happened', data))\n```\n\n<BlockQuote type=\"warning\">\n`app` can not receive or send events to or from clients. A [custom service](./services) should be used for that.\n</BlockQuote>\n\n## .removeListener(eventname)\n\nProvided by the core [NodeJS EventEmitter .removeListener](https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener). Removes all or the given listener for `eventname`.\n\n## .mixins\n\n`app.mixins` contains a list of service mixins. A mixin is a callback (`(service, path, options) => {}`) that gets run for every service that is being registered. Adding your own mixins allows to add functionality to every registered service.\n\n```ts\nimport type { Id } from '@feathersjs/feathers'\n\n// Mixins have to be added before registering any services\napp.mixins.push((service: any, path: string) => {\n  service.sayHello = function () {\n    return `Hello from service at '${path}'`\n  }\n})\n\napp.use('/todos', {\n  async get(id: Id) {\n    return { id }\n  }\n})\n\napp.service('todos').sayHello()\n// -> Hello from service at 'todos'\n```\n\n## .services\n\n`app.services` contains an object of all [services](./services) keyed by the path they have been registered via `app.use(path, service)`. This allows to return a list of all available service names:\n\n```ts\nconst servicePaths = Object.keys(app.services)\n\nservicePaths.forEach((path) => {\n  const service = app.service(path)\n})\n```\n\n<BlockQuote type=\"danger\">\nTo retrieve services use [app.service(path)](#service-path), not `app.services[path]` directly.\n</BlockQuote>\n\nA Feathers [client](client) does not know anything about the server it is connected to. This means that `app.services` will _not_ automatically contain all services available on the server. Instead, the server has to provide the list of its services, e.g. through a [custom service](./services):\n\n```ts\nclass InfoService {\n  constructor(public app: Application) {}\n\n  async find() {\n    return {\n      service: Object.keys(this.app.services)\n    }\n  }\n}\n\napp.use('info', new InfoService(app))\n```\n\n## .defaultService\n\n`app.defaultService` can be a function that returns an instance of a new standard service for `app.service(path)` if there isn't one registered yet. By default it throws a `NotFound` error when you are trying to access a service that doesn't exist.\n\n```ts\nimport { MemoryService } from '@feathersjs/memory'\n\n// For every `path` that doesn't have a service\n// Automatically return a new in-memory service\napp.defaultService = function (path: string) {\n  return new MemoryService()\n}\n```\n\nThis is used by the [client transport adapters](./client) to automatically register client side services that talk to a Feathers server.",
    "rawContent": "## .use(path, service [, options])\n\n`app.use(path, service [, options]) -> app` allows registering a [service object](./services) on a given `path`.\n\n```ts\nimport { feathers, type Id } from '@feathersjs/feathers'\n\nclass MessageService {\n  async get(id: Id) {\n    return {\n      id,\n      text: `This is the ${id} message!`\n    }\n  }\n}\n\ntype ServiceTypes = {\n  // Add services path to type mapping here\n  messages: MessageService\n}\n\nconst app = feathers<ServiceTypes>()\n\n// Register a service instance on the app\napp.use('messages', new MessageService())\n\n// Get the service and call the service method with the correct types\nconst message = await app.service('messages').get('test')\n```\n\n### path\n\nThe `path` is a string that should be URL friendly and may contain `/` as a separator. `path` can also be `/` to register a service at the root level. A path may contain placeholders in the form of `:userId/messages` which will be included in `params.route` by a transport.\n\n### options\n\nThe following options are available:\n\n- `methods` (default: `['find', 'get', 'create', 'patch', 'update','remove']`) - A list of official and [custom service methods](services#custom-methods) that should be available to clients. When using this option **all** method names that should be available externally must be passed. Those methods will automatically be available for use with [hooks](./hooks).\n- `events` - A list of [public custom events sent by this service](./events#custom-events)\n\n```ts\nimport { feathers, type Id, EventEmitter } from '@feathersjs/feathers'\n\n// Feathers services will always be event emitters\n// but we can also extend it for better type consistency\nclass MessageService extends EventEmitter {\n  async doSomething(data: { message: string }, params: Params) {\n    this.emit('something', 'I did something')\n    return data\n  }\n\n  async get(id: Id) {\n    return {\n      id,\n      text: `This is the ${id} message!`\n    }\n  }\n}\n\ntype ServiceTypes = {\n  // Add services path to type mapping here\n  messages: MessageService\n}\n\nconst app = feathers<ServiceTypes>()\n\n// Register a service with options\napp.use('messages', new MessageService(), {\n  methods: ['get', 'doSomething'],\n  events: ['something']\n})\n```\n\n<BlockQuote type=\"warning\">\nIf the `methods` property is `undefined`, all standard methods will be enabled and accessible externally.\n</BlockQuote>\n\n## .unuse(path)\n\n`app.unuse(path)` unregisters an existing service on `path` and calls the services [.teardown method](./services#teardownapp-path) if it is implemented.\n\n## .service(path)\n\n`app.service(path) -> service` returns the [service object](./services) for the given path. Feathers internally creates a new object from each registered service. This means that the object returned by `app.service(path)` will provide the same methods and functionality as your original service object but also functionality added by Feathers and its plugins like [service events](./events) and [additional methods](./services#feathers-functionality).\n\n```ts\nconst messageService = app.service('messages')\n\nconst message = await messageService.get('test')\n\nconsole.log(message)\n\nmessageService.on('created', (message: Message) => {\n  console.log('Created a todo')\n})\n```\n\n<BlockQuote type=\"note\">\nNote that a server side `app.service(path)` only allows the original service name (e.g. `app.service(':userId/messages')`) and does not parse placeholders. To get a service with route paramters use [.lookup](#lookuppath)\n</BlockQuote>\n\n## .lookup(path)\n\n`app.lookup(path)` allows to look up a full path and will return the `data` (route parameters) and `service` **on the server**.\n\n```ts\nconst lookup = app.lookup('messages/4321')\n\n// lookup.service -> app.service('messages')\n// lookup.data -> { __id: '4321' }\n\n// `lookup.dta` needs to be passed as `params.route`\nlookup.service.find({\n  route: lookup.data\n})\n```\n\nCase insensitive lookups can be enabled in the `app` file like this:\n\n```ts\napp.routes.caseSensitive = false\n```\n\n## .hooks(hooks)\n\n`app.hooks(hooks) -> app` allows registration of application-level hooks. For more information see the [application hooks section in the hooks chapter](./hooks#application-hooks).\n\n## .publish([event, ] publisher)\n\n`app.publish([event, ] publisher) -> app` registers a global event publisher. For more information see the [channels publishing](./channels#publishing) chapter.\n\n## .configure(callback)\n\n`app.configure(callback) -> app` runs a `callback` function that gets passed the application object. It is used to initialize plugins and can be used to separate your application into different files.\n\n```ts\nconst setupService = (app: Application) => {\n  app.use('/todos', todoService)\n}\n\napp.configure(setupService)\n```\n\n## .setup([server])\n\n`app.setup([server]) -> Promise<app>` is used to initialize all services by calling each [services .setup(app, path)](services#setupapp-path) method (if available).\nIt will also use the `server` instance passed (e.g. through `http.createServer`) to set up SocketIO (if enabled) and any other provider that might require the server instance. You can register [application setup hooks](./hooks#setup-and-teardown) to e.g. set up database connections and other things required to be initialized on startup in a certain order.\n\nNormally `app.setup` will be called automatically when starting the application via [app.listen([port])](#listen-port) but there are cases (like in tests) when it can be called explicitly.\n\n## .teardown([server])\n\n`app.teardown([server]) -> Promise<app>` can be called to gracefully shut down the application. When the app has been set up with a server (e.g. by calling `app.listen()`) the server will be closed automatically when calling `app.teardown()`. You can also register [application hooks](./hooks#setup-and-teardown) on teardown to e.g. close database connection etc.\n\n## .listen(port)\n\n`app.listen([port]) -> Promise<HTTPServer>` starts the application on the given port. It will set up all configured transports (if any) and then run [app.setup(server)](#setup-server) with the server object and then return the server object.\n\n`listen` will only be available if a server side transport (REST or websocket) has been configured.\n\n## .set(name, value)\n\n`app.set(name, value) -> app` assigns setting `name` to `value`.\n\n<BlockQuote type=\"danger\">\n`app.set` is global to the application. It is used for storing application wide information like database connection strings etc. **Do not use it for storing request or service specific data.** This can be done by adding data to the [hook context](./hooks#hook-context).\n</BlockQuote>\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\n\ntype ServiceTypes = {\n  // Add services path to type mapping here\n}\n\n// app.get and app.set can be typed when initializing the app\ntype Configuration = {\n  port: number\n}\n\nconst app = feathers<ServiceTypes, Configuration>()\n\napp.set('port', 3030)\n\napp.listen(app.get('port'))\n```\n\n<BlockQuote type=\"note\">\nOn the server, settings are usually initialized using [Feathers configuration](configuration).\n</BlockQuote>\n\n## .get(name)\n\n`app.get(name) -> value` retrieves the setting `name`.\n\n## .on(eventname, listener)\n\nProvided by the core [NodeJS EventEmitter .on](https://nodejs.org/api/events.html#events_emitter_on_eventname_listener). Registers a `listener` method (`function(data) {}`) for the given `eventname`.\n\n```js\napp.on('login', (user) => console.log('Logged in', user))\n```\n\n## .emit(eventname, data)\n\nProvided by the core [NodeJS EventEmitter .emit](https://nodejs.org/api/events.html#events_emitter_emit_eventname_args).\n\n```ts\ntype MyEventData = { message: string }\n\napp.emit('myevent', {\n  message: 'Something happened'\n})\n\napp.on('myevent', (data: MyEventData) => console.log('myevent happened', data))\n```\n\n<BlockQuote type=\"warning\">\n`app` can not receive or send events to or from clients. A [custom service](./services) should be used for that.\n</BlockQuote>\n\n## .removeListener(eventname)\n\nProvided by the core [NodeJS EventEmitter .removeListener](https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener). Removes all or the given listener for `eventname`.\n\n## .mixins\n\n`app.mixins` contains a list of service mixins. A mixin is a callback (`(service, path, options) => {}`) that gets run for every service that is being registered. Adding your own mixins allows to add functionality to every registered service.\n\n```ts\nimport type { Id } from '@feathersjs/feathers'\n\n// Mixins have to be added before registering any services\napp.mixins.push((service: any, path: string) => {\n  service.sayHello = function () {\n    return `Hello from service at '${path}'`\n  }\n})\n\napp.use('/todos', {\n  async get(id: Id) {\n    return { id }\n  }\n})\n\napp.service('todos').sayHello()\n// -> Hello from service at 'todos'\n```\n\n## .services\n\n`app.services` contains an object of all [services](./services) keyed by the path they have been registered via `app.use(path, service)`. This allows to return a list of all available service names:\n\n```ts\nconst servicePaths = Object.keys(app.services)\n\nservicePaths.forEach((path) => {\n  const service = app.service(path)\n})\n```\n\n<BlockQuote type=\"danger\">\nTo retrieve services use [app.service(path)](#service-path), not `app.services[path]` directly.\n</BlockQuote>\n\nA Feathers [client](client) does not know anything about the server it is connected to. This means that `app.services` will _not_ automatically contain all services available on the server. Instead, the server has to provide the list of its services, e.g. through a [custom service](./services):\n\n```ts\nclass InfoService {\n  constructor(public app: Application) {}\n\n  async find() {\n    return {\n      service: Object.keys(this.app.services)\n    }\n  }\n}\n\napp.use('info', new InfoService(app))\n```\n\n## .defaultService\n\n`app.defaultService` can be a function that returns an instance of a new standard service for `app.service(path)` if there isn't one registered yet. By default it throws a `NotFound` error when you are trying to access a service that doesn't exist.\n\n```ts\nimport { MemoryService } from '@feathersjs/memory'\n\n// For every `path` that doesn't have a service\n// Automatically return a new in-memory service\napp.defaultService = function (path: string) {\n  return new MemoryService()\n}\n```\n\nThis is used by the [client transport adapters](./client) to automatically register client side services that talk to a Feathers server.",
    "breadcrumb": "Application",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/application.md",
    "heading": "Application",
    "subHeadings": [
      ".use(path, service [, options])",
      "path",
      "options",
      ".unuse(path)",
      ".service(path)",
      ".lookup(path)",
      ".hooks(hooks)",
      ".publish([event, ] publisher)",
      ".configure(callback)",
      ".setup([server])",
      ".teardown([server])",
      ".listen(port)",
      ".set(name, value)",
      ".get(name)",
      ".on(eventname, listener)",
      ".emit(eventname, data)",
      ".removeListener(eventname)",
      ".mixins",
      ".services",
      ".defaultService"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text",
      "js"
    ],
    "tokens": 2614,
    "category": "api",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "provider",
      "database",
      "adapter",
      "channels",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "hook context",
      "setup",
      "teardown",
      "application"
    ]
  },
  {
    "id": "v6-authentication-0",
    "content": "# Authentication\nBreadcrumb: Authentication\nCovers: authenticate | Legacy Documentation\nTopics: hooks, authentication, jwt, oauth\n\n## authenticate\n\n`authenticate(...strategies)` is a hook that allows to authenticate a service method with one or more registered authentication strategies.\n\n```ts\nimport { authenticate } from '@feathersjs/authentication'\n\napp.service('messages').hooks({\n  before: {\n    all: [authenticate('jwt')]\n  }\n})\n```\n\n## Legacy Documentation\n\nFor detailed documentation on the authentication service, strategies (JWT, Local, OAuth), and client usage, see the [Feathers v5 (Dove) authentication documentation](https://eagle.feathersjs.com/api/authentication/).",
    "rawContent": "## authenticate\n\n`authenticate(...strategies)` is a hook that allows to authenticate a service method with one or more registered authentication strategies.\n\n```ts\nimport { authenticate } from '@feathersjs/authentication'\n\napp.service('messages').hooks({\n  before: {\n    all: [authenticate('jwt')]\n  }\n})\n```\n\n## Legacy Documentation\n\nFor detailed documentation on the authentication service, strategies (JWT, Local, OAuth), and client usage, see the [Feathers v5 (Dove) authentication documentation](https://eagle.feathersjs.com/api/authentication/).",
    "breadcrumb": "Authentication",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/authentication.md",
    "heading": "Authentication",
    "subHeadings": [
      "authenticate",
      "Legacy Documentation"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 138,
    "category": "api",
    "tags": [
      "hooks",
      "authentication",
      "jwt",
      "oauth"
    ]
  },
  {
    "id": "v6-browser-0",
    "content": "# Browser\nBreadcrumb: Browser\nCovers: Setup | With IndexedDB | With Service Worker | Events\nTopics: services, events, find, get, create, update, patch, remove, setup, application\n\n## Setup\n\n```ts\nimport { feathers } from 'feathers'\n\nconst app = feathers()\n\napp.use('messages', {\n  messages: [],\n\n  async find() {\n    return this.messages\n  },\n\n  async get(id) {\n    return this.messages.find(m => m.id === id)\n  },\n\n  async create(data) {\n    const message = { id: this.messages.length, ...data }\n    this.messages.push(message)\n    return message\n  },\n\n  async remove(id) {\n    const index = this.messages.findIndex(m => m.id === id)\n    if (index !== -1) {\n      const [removed] = this.messages.splice(index, 1)\n      return removed\n    }\n    return null\n  }\n})\n\n// Use services directly\nconst messages = await app.service('messages').create({ text: 'Hello' })\n```\n\n## With IndexedDB\n\nFor persistent browser storage, combine Feathers with IndexedDB:\n\n```ts\nimport { feathers } from 'feathers'\nimport { openDB } from 'idb'\n\nconst db = await openDB('myapp', 1, {\n  upgrade(db) {\n    db.createObjectStore('messages', { keyPath: 'id', autoIncrement: true })\n  }\n})\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return db.getAll('messages')\n  },\n\n  async get(id) {\n    return db.get('messages', id)\n  },\n\n  async create(data) {\n    const id = await db.add('messages', data)\n    return { id, ...data }\n  },\n\n  async patch(id, data) {\n    const existing = await db.get('messages', id)\n    const updated = { ...existing, ...data }\n    await db.put('messages', updated)\n    return updated\n  },\n\n  async remove(id) {\n    const message = await db.get('messages', id)\n    await db.delete('messages', id)\n    return message\n  }\n})\n```\n\n## With Service Worker\n\nFeathers can handle requests in a Service Worker for offline support:\n\n```ts\n// service-worker.ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Cached message' }]\n  }\n})\n\nconst handler = createHandler(app)\n\nself.addEventListener('fetch', (event) => {\n  const url = new URL(event.request.url)\n\n  // Handle API requests with Feathers\n  if (url.pathname.startsWith('/api/')) {\n    event.respondWith(handler(event.request))\n  }\n})\n```\n\n## Events\n\nBrowser Feathers applications support the same event system as server applications:\n\n```ts\nconst app = feathers()\n\napp.use('messages', {\n  messages: [],\n\n  async create(data) {\n    const message = { id: Date.now(), ...data }\n    this.messages.push(message)\n    return message\n  }\n})\n\n// Listen for events\napp.service('messages').on('created', (message) => {\n  console.log('New message:', message)\n  // Update UI\n})\n\n// Create a message - will trigger the event\nawait app.service('messages').create({ text: 'Hello' })\n```",
    "rawContent": "## Setup\n\n```ts\nimport { feathers } from 'feathers'\n\nconst app = feathers()\n\napp.use('messages', {\n  messages: [],\n\n  async find() {\n    return this.messages\n  },\n\n  async get(id) {\n    return this.messages.find(m => m.id === id)\n  },\n\n  async create(data) {\n    const message = { id: this.messages.length, ...data }\n    this.messages.push(message)\n    return message\n  },\n\n  async remove(id) {\n    const index = this.messages.findIndex(m => m.id === id)\n    if (index !== -1) {\n      const [removed] = this.messages.splice(index, 1)\n      return removed\n    }\n    return null\n  }\n})\n\n// Use services directly\nconst messages = await app.service('messages').create({ text: 'Hello' })\n```\n\n## With IndexedDB\n\nFor persistent browser storage, combine Feathers with IndexedDB:\n\n```ts\nimport { feathers } from 'feathers'\nimport { openDB } from 'idb'\n\nconst db = await openDB('myapp', 1, {\n  upgrade(db) {\n    db.createObjectStore('messages', { keyPath: 'id', autoIncrement: true })\n  }\n})\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return db.getAll('messages')\n  },\n\n  async get(id) {\n    return db.get('messages', id)\n  },\n\n  async create(data) {\n    const id = await db.add('messages', data)\n    return { id, ...data }\n  },\n\n  async patch(id, data) {\n    const existing = await db.get('messages', id)\n    const updated = { ...existing, ...data }\n    await db.put('messages', updated)\n    return updated\n  },\n\n  async remove(id) {\n    const message = await db.get('messages', id)\n    await db.delete('messages', id)\n    return message\n  }\n})\n```\n\n## With Service Worker\n\nFeathers can handle requests in a Service Worker for offline support:\n\n```ts\n// service-worker.ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Cached message' }]\n  }\n})\n\nconst handler = createHandler(app)\n\nself.addEventListener('fetch', (event) => {\n  const url = new URL(event.request.url)\n\n  // Handle API requests with Feathers\n  if (url.pathname.startsWith('/api/')) {\n    event.respondWith(handler(event.request))\n  }\n})\n```\n\n## Events\n\nBrowser Feathers applications support the same event system as server applications:\n\n```ts\nconst app = feathers()\n\napp.use('messages', {\n  messages: [],\n\n  async create(data) {\n    const message = { id: Date.now(), ...data }\n    this.messages.push(message)\n    return message\n  }\n})\n\n// Listen for events\napp.service('messages').on('created', (message) => {\n  console.log('New message:', message)\n  // Update UI\n})\n\n// Create a message - will trigger the event\nawait app.service('messages').create({ text: 'Hello' })\n```",
    "breadcrumb": "Browser",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/browser.md",
    "heading": "Browser",
    "subHeadings": [
      "Setup",
      "With IndexedDB",
      "With Service Worker",
      "Events"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 671,
    "category": "api",
    "tags": [
      "services",
      "events",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "setup",
      "application"
    ]
  },
  {
    "id": "v6-bun-0",
    "content": "# Bun\nBreadcrumb: Bun\nCovers: Setup | With Socket.io\nTopics: real-time, find, create, socket.io, setup\n\n## Setup\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\n\nBun.serve({\n  port: 3030,\n  fetch: handler\n})\n```\n\nThe `createHandler` returns a function with the signature `(request: Request) => Promise<Response>` which is the Web Standard used natively by Bun.\n\n## With Socket.io\n\nTo use real-time functionality with Socket.io in Bun:\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\nimport { Server } from 'socket.io'\nimport { socketio } from 'feathers/socketio'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\napp.configure(socketio())\n\nconst handler = createHandler(app)\n\nconst server = Bun.serve({\n  port: 3030,\n  fetch: handler\n})\n\nawait app.setup(server)\n```",
    "rawContent": "## Setup\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\n\nBun.serve({\n  port: 3030,\n  fetch: handler\n})\n```\n\nThe `createHandler` returns a function with the signature `(request: Request) => Promise<Response>` which is the Web Standard used natively by Bun.\n\n## With Socket.io\n\nTo use real-time functionality with Socket.io in Bun:\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\nimport { Server } from 'socket.io'\nimport { socketio } from 'feathers/socketio'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\napp.configure(socketio())\n\nconst handler = createHandler(app)\n\nconst server = Bun.serve({\n  port: 3030,\n  fetch: handler\n})\n\nawait app.setup(server)\n```",
    "breadcrumb": "Bun",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/bun.md",
    "heading": "Bun",
    "subHeadings": [
      "Setup",
      "With Socket.io"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 240,
    "category": "api",
    "tags": [
      "real-time",
      "find",
      "create",
      "socket.io",
      "setup"
    ]
  },
  {
    "id": "v6-channels-0",
    "content": "# Channels\nBreadcrumb: Channels\nCovers: Concepts | Example | Connections | app.on('connection') | app.on('disconnect') | app.on('login') | app.on('logout') | Channels | app.channel(...names) | app.channels | channel.join(connection) | channel.leave(connection|fn) | channel.filter(fn) | channel.send(data) | channel.connections | channel.length | Publishing | service.publish([event,] fn) | app.publish([event,] fn) | Publisher precedence | Keeping channels updated\nTopics: hooks, services, context, params, authentication, database, real-time, channels, events, rest, find, get, create, update, patch, remove, hook context, socket.io, middleware, application\n\n## Concepts\n\nA **_channel_** is basically an array of **_connection_** objects. Each array is explicitly given a name. When using a real-time server transport and a new client connects, you can tell the server to explicitly add that client's connection object to any relevant channels. Any connection in a channel will receive all events that are sent to that channel. This allows clients to receive only their intended messages.\n\nWhen using a real-time transport, the server pushes events (such as \"created\", \"removed\" etc. for a particular service) down to its clients. Using channels allows customizing which clients should receive each event. The client doesnâ€™t subscribe to individual channels, directly, but rather subscribes to specific events like `created`, `patched`, custom events, etc, in which they are interested. Those events will only fire for a client if the server pushes data to one a channel to which the client has been added.\n\nYou can have any number of channels. This helps to organise how data is sent and to control the volume of data, by not sending things that aren't relevant.\n\nThe server can also change connection channel membership from time to time, eg. before vs after login.\n\nThe server needs to explicitly **publish** channels it is interested in sharing with clients before they become available.\n\n## Example\n\nThe example below shows a `channels.js` file illustrating how the different parts fit together:\n\n```ts\nimport type { RealTimeConnection, Params } from '@feathersjs/feathers'\nimport type { Application, HookContext } from './declarations'\n\nexport default function (app: any) {\n  if (typeof app.channel !== 'function') {\n    // If no real-time functionality has been configured just return\n    return\n  }\n\n  app.on('connection', (connection: RealTimeConnection) => {\n    // On a new real-time connection, add it to the anonymous channel\n    app.channel('anonymous').join(connection)\n  })\n\n  app.on('login', (AuthenticationResult: any, { connection }: Params) => {\n    // connection can be undefined if there is no\n    // real-time connection, e.g. when logging in via REST\n    if (connection) {\n      // The connection is no longer anonymous, remove it\n      app.channel('anonymous').leave(connection)\n\n      // Add it to the authenticated user channel\n      app.channel('authenticated').join(connection)\n    }\n  })\n\n  // eslint-disable-next-line no-unused-vars\n  app.publish((data: any, context: HookContext) => {\n    // Here you can add event publishers to channels set up in `channels.js`\n    // To publish only for a specific event use `app.publish(eventname, () => {})`\n    console.log(\n      'Publishing all events to all authenticated users. See `channels.js` and https://docs.feathersjs.com/api/channels.html for more information.'\n    )\n\n    // e.g. to publish all service events to all authenticated users use\n    return app.channel('authenticated')\n  })\n}\n```\n\n## Connections\n\nA connection is an object that represents a real-time connection. It is the same object as `socket.feathers` in a [Socket.io](./socketio#params) middleware. You can add any kind of information to it but most notably, when using [authentication](./authentication/service), it will contain the authenticated user. By default it is located in `connection.user` once the client has authenticated on the socket (usually by calling `app.authenticate()` on the [client](./client)).\n\nWe can get access to the `connection` object by listening to `app.on('connection', connection => {})` or `app.on('login', (payload, { connection }) => {})`.\n\n<BlockQuote type=\"note\">\nWhen a connection is terminated it will be automatically removed from all channels.\n</BlockQuote>\n\n### app.on('connection')\n\n`app.on('connection', connection => {})` is fired every time a new real-time connection is established. This is a good place to add the connection to a channel for anonymous users (in case we want to send any real-time updates to them):\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\napp.on('connection', (connection: RealTimeConnection) => {\n  // On a new real-time connection, add it to the\n  // anonymous channel\n  app.channel('anonymous').join(connection)\n})\n```\n\n### app.on('disconnect')\n\n`app.on('disconnect', connection => {})` is fired every time real-time connection is disconnected. This is a good place to to handle disconnections outside of a logout. A connection that is disconnected will always leave all its channels automatically.\n\n### app.on('login')\n\n`app.on('login', (authenticationResult, params, context) => {})` is sent by the [AuthenticationService](./authentication/service#app-on-login) on successful login.\n\nThis is a good place to add the connection to channels related to the user (e.g. chat rooms, admin status etc.)\n\n```ts\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  // connection can be undefined if there is no\n  // real-time connection, e.g. when logging in via REST\n  if (connection) {\n    // The user attached to this connection\n    const { user } = connection\n\n    // The connection is no longer anonymous, remove it\n    app.channel('anonymous').leave(connection)\n\n    // Add it to the authenticated user channel\n    app.channel('authenticated').join(connection)\n\n    // Channels can be named anything and joined on any condition `\n    // E.g. to send real-time events only to admins use\n    if (user.isAdmin) {\n      app.channel('admins').join(connection)\n    }\n\n    // If the user has joined e.g. chat rooms\n    user.rooms.forEach((room) => {\n      app.channel(`rooms/${room.id}`).join(connection)\n    })\n  }\n})\n```\n\n### app.on('logout')\n\n`app.on('logout', (AuthenticationResult, params, context) => {})` is sent by the [AuthenticationService](./authentication/service) on successful logout:\n\n```ts\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('logout', (payload: AuthenticationResult, { connection }: Params) => {\n  if (connection) {\n    // Join the channels a logged out connection should be in\n    app.channel('anonymous').join(connection)\n  }\n})\n```\n\n<BlockQuote type=\"note\">\nOn `logout` the connection will be removed from all existing channels automatically.\n</BlockQuote>\n\n## Channels\n\nA channel is an object that contains a number of connections. It can be created via `app.channel` and allows a connection to join or leave it.\n\n### app.channel(...names)\n\n`app.channel(name) -> Channel`, when given a single name, returns an existing or new named channel:\n\n```ts\napp.channel('admins') // the admin channel\napp.channel('authenticated') // the authenticated channel\n```\n\n`app.channel(name1, name2, ... nameN) -> Channel`, when given multiples names, will return a combined channel. A combined channel contains a list of all connections (without duplicates) and re-directs `channel.join` and `channel.leave` calls to all its child channels.\n\n```ts\n// Combine the anonymous and authenticated channel\nconst combinedChannel = app.channel('anonymous', 'authenticated')\n\n// Join the `anonymous` and `authenticated` channel\ncombinedChannel.join(connection)\n\n// Join the `admins` and `chat` channel\napp.channel('admins', 'chat').join(connection)\n\n// Leave the `admins` and `chat` channel\napp.channel('admins', 'chat').leave(connection)\n\n// Make user with `_id` 5 leave the admins and chat channel\napp.channel('admins', 'chat').leave((connection) => {\n  return connection.user._id === 5\n})\n```\n\n### app.channels\n\n`app.channels -> [string]` returns a list of all existing channel names.\n\n```ts\napp.channel('authenticated')\napp.channel('admins', 'users')\n\napp.channels // [ 'authenticated', 'admins', 'users' ]\n\napp.channel(app.channels) // will return a channel with all connections\n```\n\nThis is useful to e.g. remove a connection from all channels:\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\n// When a user is removed, make all their connections leave every channel\napp.service('users').on('removed', (user: User) => {\n  app.channel(app.channels).leave((connection: RealTimeConnection) => {\n    return user._id === connection.user._id\n  })\n})\n```\n\n### channel.join(connection)\n\n`channel.join(connection) -> Channel` adds a connection to this channel. If the channel is a combined channel, add the connection to all its child channels. If the connection is already in the channel it does nothing. Returns the channel object.\n\n```ts\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  if (connection && connection.user.isAdmin) {\n    // Join the admins channel\n    app.channel('admins').join(connection)\n\n    // Calling a second time will do nothing\n    app.channel('admins').join(connection)\n  }\n})\n```\n\n### channel.leave(connection|fn)\n\n`channel.leave(connection|fn) -> Channel` removes a connection from this channel. If the channel is a combined channel, remove the connection from all its child channels. Also allows to pass a callback that is run for every connection and returns if the connection should be removed or not. Returns the channel object.\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\n// Make the user with `_id` 5 leave the `admins` channel\napp.channel('admins').leave((connection: RealTimeConnection) => {\n  return connection.user._id === 5\n})\n```\n\n### channel.filter(fn)\n\n`channel.filter(fn) -> Channel` returns a new channel filtered by a given function which gets passed the connection.\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\n// Returns a new channel with all connections of the user with `_id` 5\nconst userFive = app\n  .channel(app.channels)\n  .filter((connection: RealTimeConnection) => connection.user._id === 5)\n```\n\n### channel.send(data)\n\n`channel.send(data) -> Channel` returns a copy of this channel with customized data that should be sent for this event. Usually this should be handled by modifying either the service method result or setting client \"safe\" data in `context.dispatch` but in some cases it might make sense to still change the event data for certain channels.\n\nWhat data will be sent as the event data will be determined by the first available in the following order:\n\n1. `data` from `channel.send(data)`\n2. `context.dispatch`\n3. `context.result`\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\napp.on('connection', (connection: RealTimeConnection) => {\n  // On a new real-time connection, add it to the\n  // anonymous channel\n  app.channel('anonymous').join(connection)\n})\n\n// Send the `users` `created` event to all anonymous\n// users but use only the name as the payload\napp.service('users').publish('created', (data: User) => {\n  return app.channel('anonymous').send({\n    name: data.name\n  })\n})\n```\n\n<BlockQuote type=\"warning\">\nIf a connection is in multiple channels (e.g. `users` and `admins`) it will get the data from the _first_ channel that it is in.\n</BlockQuote>\n\n### channel.connections\n\n`channel.connections -> [ object ]` contains a list of all connections in this channel.\n\n### channel.length\n\n`channel.length -> integer` returns the total number of connections in this channel.\n\n## Publishing\n\nPublishers are callback functions that return which channel(s) to send an event to. They can be registered at the application and the service level and for all or specific events. A publishing function gets the event data and context object (`(data, context) => {}`) and returns a named or combined channel, an array of channels or `null`. Only one publisher can be registered for one type. Besides the standard [service event names](./events#service-events) an event name can also be a [custom event](./events#custom-events). `context` is the [hook context object](./hooks) from the service call or an object containing `{ path, service, app, result }` for custom events.\n\n### service.publish([event,] fn)\n\n`service.publish([event,] fn) -> service` registers a publishing function for a specific service for a specific event or all events if no event name was given.\n\n```ts\nimport { HookContext } from './declarations'\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  // connection can be undefined if there is no\n  // real-time connection, e.g. when logging in via REST\n  if (connection && connection.user.isAdmin) {\n    app.channel('admins').join(connection)\n  }\n})\n\n// Publish all messages service events only to its room channel\napp.service('messages').publish((data: Message, context: HookContext) => {\n  return app.channel(`rooms/${data.roomId}`)\n})\n\n// Publish the `created` event to admins and the user that sent it\napp.service('users').publish('created', (data: User, context: HookContext) => {\n  return [\n    app.channel('admins'),\n    app.channel(app.channels).filter((connection) => connection.user._id === context.params.user._id)\n  ]\n})\n\n// Prevent all events in the `password-reset` service from being published\napp.service('password-reset').publish(() => null)\n```\n\n### app.publish([event,] fn)\n\n`app.publish([event,] fn) -> app` registers a publishing function for all services for a specific event or all events if no event name was given.\n\n```ts\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  // connection can be undefined if there is no\n  // real-time connection, e.g. when logging in via REST\n  if (connection) {\n    app.channel('authenticated').join(connection)\n  }\n})\n\n// Publish all events to all authenticated users\napp.publish((data: any, context: HookContext) => {\n  return app.channel('authenticated')\n})\n\n// Publish the `log` custom event to all connections\napp.publish('log', (data: any, context: HookContext) => {\n  return app.channel(app.channels)\n})\n```\n\n### Publisher precedence\n\nThe first publisher callback found in the following order will be used:\n\n1. Service publisher for a specific event\n2. Service publisher for all events\n3. App publishers for a specific event\n4. App publishers for all events\n\n## Keeping channels updated\n\nSince every application will be different, keeping the connections assigned to channels up to date (e.g. if a user joins/leaves a room) is up to you.\n\nIn general, channels should reflect your persistent application data. This means that it normally isn't necessary for e.g. a user to request to directly join a channel. This is especially important when running multiple instances of an application since channels are only _local_ to the current instance.\n\nInstead, the relevant information (e.g. what rooms a user is currently in) should be stored in the database and then the active connections can be re-distributed into the appropriate channels listening to the proper [service events](./events).\n\nThe following example updates all active connections for a given user when the user object (which is assumed to have a `rooms` array being a list of room ids the user has joined) is updated or removed:\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\n// Join a channel given a user and connection\nconst joinChannels = (user: User, connection: RealTimeConnection) => {\n  app.channel('authenticated').join(connection)\n  // Assuming that the chat room/user assignment is stored\n  // on an array of the user\n  user.rooms.forEach((room) => app.channel(`rooms/${roomId}`).join(connection))\n}\n\n// Get a user to leave all channels\nconst leaveChannels = (user: User) => {\n  app.channel(app.channels).leave((connection) => connection.user._id === user._id)\n}\n\n// Leave and re-join all channels with new user information\nconst updateChannels = (user: User) => {\n  // Find all connections for this user\n  const { connections } = app.channel(app.channels).filter((connection) => connection.user._id === user._id)\n\n  // Leave all channels\n  leaveChannels(user)\n\n  // Re-join all channels with the updated user information\n  connections.forEach((connection) => joinChannels(user, connection))\n}\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  if (connection) {\n    // Join all channels on login\n    joinChannels(connection.user, connection)\n  }\n})\n\n// On `updated` and `patched`, leave and re-join with new room assignments\napp.service('users').on('updated', updateChannels)\napp.service('users').on('patched', updateChannels)\n// On `removed`, remove the connection from all channels\napp.service('users').on('removed', leaveChannels)\n```\n\n<BlockQuote type=\"note\">\nThe number active connections is usually one (or none) but unless you prevent it explicitly Feathers is not preventing multiple logins of the same user (e.g. with two open browser windows or on a mobile device).\n</BlockQuote>",
    "rawContent": "## Concepts\n\nA **_channel_** is basically an array of **_connection_** objects. Each array is explicitly given a name. When using a real-time server transport and a new client connects, you can tell the server to explicitly add that client's connection object to any relevant channels. Any connection in a channel will receive all events that are sent to that channel. This allows clients to receive only their intended messages.\n\nWhen using a real-time transport, the server pushes events (such as \"created\", \"removed\" etc. for a particular service) down to its clients. Using channels allows customizing which clients should receive each event. The client doesnâ€™t subscribe to individual channels, directly, but rather subscribes to specific events like `created`, `patched`, custom events, etc, in which they are interested. Those events will only fire for a client if the server pushes data to one a channel to which the client has been added.\n\nYou can have any number of channels. This helps to organise how data is sent and to control the volume of data, by not sending things that aren't relevant.\n\nThe server can also change connection channel membership from time to time, eg. before vs after login.\n\nThe server needs to explicitly **publish** channels it is interested in sharing with clients before they become available.\n\n## Example\n\nThe example below shows a `channels.js` file illustrating how the different parts fit together:\n\n```ts\nimport type { RealTimeConnection, Params } from '@feathersjs/feathers'\nimport type { Application, HookContext } from './declarations'\n\nexport default function (app: any) {\n  if (typeof app.channel !== 'function') {\n    // If no real-time functionality has been configured just return\n    return\n  }\n\n  app.on('connection', (connection: RealTimeConnection) => {\n    // On a new real-time connection, add it to the anonymous channel\n    app.channel('anonymous').join(connection)\n  })\n\n  app.on('login', (AuthenticationResult: any, { connection }: Params) => {\n    // connection can be undefined if there is no\n    // real-time connection, e.g. when logging in via REST\n    if (connection) {\n      // The connection is no longer anonymous, remove it\n      app.channel('anonymous').leave(connection)\n\n      // Add it to the authenticated user channel\n      app.channel('authenticated').join(connection)\n    }\n  })\n\n  // eslint-disable-next-line no-unused-vars\n  app.publish((data: any, context: HookContext) => {\n    // Here you can add event publishers to channels set up in `channels.js`\n    // To publish only for a specific event use `app.publish(eventname, () => {})`\n    console.log(\n      'Publishing all events to all authenticated users. See `channels.js` and https://docs.feathersjs.com/api/channels.html for more information.'\n    )\n\n    // e.g. to publish all service events to all authenticated users use\n    return app.channel('authenticated')\n  })\n}\n```\n\n## Connections\n\nA connection is an object that represents a real-time connection. It is the same object as `socket.feathers` in a [Socket.io](./socketio#params) middleware. You can add any kind of information to it but most notably, when using [authentication](./authentication/service), it will contain the authenticated user. By default it is located in `connection.user` once the client has authenticated on the socket (usually by calling `app.authenticate()` on the [client](./client)).\n\nWe can get access to the `connection` object by listening to `app.on('connection', connection => {})` or `app.on('login', (payload, { connection }) => {})`.\n\n<BlockQuote type=\"note\">\nWhen a connection is terminated it will be automatically removed from all channels.\n</BlockQuote>\n\n### app.on('connection')\n\n`app.on('connection', connection => {})` is fired every time a new real-time connection is established. This is a good place to add the connection to a channel for anonymous users (in case we want to send any real-time updates to them):\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\napp.on('connection', (connection: RealTimeConnection) => {\n  // On a new real-time connection, add it to the\n  // anonymous channel\n  app.channel('anonymous').join(connection)\n})\n```\n\n### app.on('disconnect')\n\n`app.on('disconnect', connection => {})` is fired every time real-time connection is disconnected. This is a good place to to handle disconnections outside of a logout. A connection that is disconnected will always leave all its channels automatically.\n\n### app.on('login')\n\n`app.on('login', (authenticationResult, params, context) => {})` is sent by the [AuthenticationService](./authentication/service#app-on-login) on successful login.\n\nThis is a good place to add the connection to channels related to the user (e.g. chat rooms, admin status etc.)\n\n```ts\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  // connection can be undefined if there is no\n  // real-time connection, e.g. when logging in via REST\n  if (connection) {\n    // The user attached to this connection\n    const { user } = connection\n\n    // The connection is no longer anonymous, remove it\n    app.channel('anonymous').leave(connection)\n\n    // Add it to the authenticated user channel\n    app.channel('authenticated').join(connection)\n\n    // Channels can be named anything and joined on any condition `\n    // E.g. to send real-time events only to admins use\n    if (user.isAdmin) {\n      app.channel('admins').join(connection)\n    }\n\n    // If the user has joined e.g. chat rooms\n    user.rooms.forEach((room) => {\n      app.channel(`rooms/${room.id}`).join(connection)\n    })\n  }\n})\n```\n\n### app.on('logout')\n\n`app.on('logout', (AuthenticationResult, params, context) => {})` is sent by the [AuthenticationService](./authentication/service) on successful logout:\n\n```ts\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('logout', (payload: AuthenticationResult, { connection }: Params) => {\n  if (connection) {\n    // Join the channels a logged out connection should be in\n    app.channel('anonymous').join(connection)\n  }\n})\n```\n\n<BlockQuote type=\"note\">\nOn `logout` the connection will be removed from all existing channels automatically.\n</BlockQuote>\n\n## Channels\n\nA channel is an object that contains a number of connections. It can be created via `app.channel` and allows a connection to join or leave it.\n\n### app.channel(...names)\n\n`app.channel(name) -> Channel`, when given a single name, returns an existing or new named channel:\n\n```ts\napp.channel('admins') // the admin channel\napp.channel('authenticated') // the authenticated channel\n```\n\n`app.channel(name1, name2, ... nameN) -> Channel`, when given multiples names, will return a combined channel. A combined channel contains a list of all connections (without duplicates) and re-directs `channel.join` and `channel.leave` calls to all its child channels.\n\n```ts\n// Combine the anonymous and authenticated channel\nconst combinedChannel = app.channel('anonymous', 'authenticated')\n\n// Join the `anonymous` and `authenticated` channel\ncombinedChannel.join(connection)\n\n// Join the `admins` and `chat` channel\napp.channel('admins', 'chat').join(connection)\n\n// Leave the `admins` and `chat` channel\napp.channel('admins', 'chat').leave(connection)\n\n// Make user with `_id` 5 leave the admins and chat channel\napp.channel('admins', 'chat').leave((connection) => {\n  return connection.user._id === 5\n})\n```\n\n### app.channels\n\n`app.channels -> [string]` returns a list of all existing channel names.\n\n```ts\napp.channel('authenticated')\napp.channel('admins', 'users')\n\napp.channels // [ 'authenticated', 'admins', 'users' ]\n\napp.channel(app.channels) // will return a channel with all connections\n```\n\nThis is useful to e.g. remove a connection from all channels:\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\n// When a user is removed, make all their connections leave every channel\napp.service('users').on('removed', (user: User) => {\n  app.channel(app.channels).leave((connection: RealTimeConnection) => {\n    return user._id === connection.user._id\n  })\n})\n```\n\n### channel.join(connection)\n\n`channel.join(connection) -> Channel` adds a connection to this channel. If the channel is a combined channel, add the connection to all its child channels. If the connection is already in the channel it does nothing. Returns the channel object.\n\n```ts\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  if (connection && connection.user.isAdmin) {\n    // Join the admins channel\n    app.channel('admins').join(connection)\n\n    // Calling a second time will do nothing\n    app.channel('admins').join(connection)\n  }\n})\n```\n\n### channel.leave(connection|fn)\n\n`channel.leave(connection|fn) -> Channel` removes a connection from this channel. If the channel is a combined channel, remove the connection from all its child channels. Also allows to pass a callback that is run for every connection and returns if the connection should be removed or not. Returns the channel object.\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\n// Make the user with `_id` 5 leave the `admins` channel\napp.channel('admins').leave((connection: RealTimeConnection) => {\n  return connection.user._id === 5\n})\n```\n\n### channel.filter(fn)\n\n`channel.filter(fn) -> Channel` returns a new channel filtered by a given function which gets passed the connection.\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\n// Returns a new channel with all connections of the user with `_id` 5\nconst userFive = app\n  .channel(app.channels)\n  .filter((connection: RealTimeConnection) => connection.user._id === 5)\n```\n\n### channel.send(data)\n\n`channel.send(data) -> Channel` returns a copy of this channel with customized data that should be sent for this event. Usually this should be handled by modifying either the service method result or setting client \"safe\" data in `context.dispatch` but in some cases it might make sense to still change the event data for certain channels.\n\nWhat data will be sent as the event data will be determined by the first available in the following order:\n\n1. `data` from `channel.send(data)`\n2. `context.dispatch`\n3. `context.result`\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\n\napp.on('connection', (connection: RealTimeConnection) => {\n  // On a new real-time connection, add it to the\n  // anonymous channel\n  app.channel('anonymous').join(connection)\n})\n\n// Send the `users` `created` event to all anonymous\n// users but use only the name as the payload\napp.service('users').publish('created', (data: User) => {\n  return app.channel('anonymous').send({\n    name: data.name\n  })\n})\n```\n\n<BlockQuote type=\"warning\">\nIf a connection is in multiple channels (e.g. `users` and `admins`) it will get the data from the _first_ channel that it is in.\n</BlockQuote>\n\n### channel.connections\n\n`channel.connections -> [ object ]` contains a list of all connections in this channel.\n\n### channel.length\n\n`channel.length -> integer` returns the total number of connections in this channel.\n\n## Publishing\n\nPublishers are callback functions that return which channel(s) to send an event to. They can be registered at the application and the service level and for all or specific events. A publishing function gets the event data and context object (`(data, context) => {}`) and returns a named or combined channel, an array of channels or `null`. Only one publisher can be registered for one type. Besides the standard [service event names](./events#service-events) an event name can also be a [custom event](./events#custom-events). `context` is the [hook context object](./hooks) from the service call or an object containing `{ path, service, app, result }` for custom events.\n\n### service.publish([event,] fn)\n\n`service.publish([event,] fn) -> service` registers a publishing function for a specific service for a specific event or all events if no event name was given.\n\n```ts\nimport { HookContext } from './declarations'\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  // connection can be undefined if there is no\n  // real-time connection, e.g. when logging in via REST\n  if (connection && connection.user.isAdmin) {\n    app.channel('admins').join(connection)\n  }\n})\n\n// Publish all messages service events only to its room channel\napp.service('messages').publish((data: Message, context: HookContext) => {\n  return app.channel(`rooms/${data.roomId}`)\n})\n\n// Publish the `created` event to admins and the user that sent it\napp.service('users').publish('created', (data: User, context: HookContext) => {\n  return [\n    app.channel('admins'),\n    app.channel(app.channels).filter((connection) => connection.user._id === context.params.user._id)\n  ]\n})\n\n// Prevent all events in the `password-reset` service from being published\napp.service('password-reset').publish(() => null)\n```\n\n### app.publish([event,] fn)\n\n`app.publish([event,] fn) -> app` registers a publishing function for all services for a specific event or all events if no event name was given.\n\n```ts\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  // connection can be undefined if there is no\n  // real-time connection, e.g. when logging in via REST\n  if (connection) {\n    app.channel('authenticated').join(connection)\n  }\n})\n\n// Publish all events to all authenticated users\napp.publish((data: any, context: HookContext) => {\n  return app.channel('authenticated')\n})\n\n// Publish the `log` custom event to all connections\napp.publish('log', (data: any, context: HookContext) => {\n  return app.channel(app.channels)\n})\n```\n\n### Publisher precedence\n\nThe first publisher callback found in the following order will be used:\n\n1. Service publisher for a specific event\n2. Service publisher for all events\n3. App publishers for a specific event\n4. App publishers for all events\n\n## Keeping channels updated\n\nSince every application will be different, keeping the connections assigned to channels up to date (e.g. if a user joins/leaves a room) is up to you.\n\nIn general, channels should reflect your persistent application data. This means that it normally isn't necessary for e.g. a user to request to directly join a channel. This is especially important when running multiple instances of an application since channels are only _local_ to the current instance.\n\nInstead, the relevant information (e.g. what rooms a user is currently in) should be stored in the database and then the active connections can be re-distributed into the appropriate channels listening to the proper [service events](./events).\n\nThe following example updates all active connections for a given user when the user object (which is assumed to have a `rooms` array being a list of room ids the user has joined) is updated or removed:\n\n```ts\nimport type { RealTimeConnection } from '@feathersjs/feathers'\nimport type { Params } from '@feathersjs/feathers'\nimport type { AuthenticationResult } from '@feathersjs/authentication'\n\n// Join a channel given a user and connection\nconst joinChannels = (user: User, connection: RealTimeConnection) => {\n  app.channel('authenticated').join(connection)\n  // Assuming that the chat room/user assignment is stored\n  // on an array of the user\n  user.rooms.forEach((room) => app.channel(`rooms/${roomId}`).join(connection))\n}\n\n// Get a user to leave all channels\nconst leaveChannels = (user: User) => {\n  app.channel(app.channels).leave((connection) => connection.user._id === user._id)\n}\n\n// Leave and re-join all channels with new user information\nconst updateChannels = (user: User) => {\n  // Find all connections for this user\n  const { connections } = app.channel(app.channels).filter((connection) => connection.user._id === user._id)\n\n  // Leave all channels\n  leaveChannels(user)\n\n  // Re-join all channels with the updated user information\n  connections.forEach((connection) => joinChannels(user, connection))\n}\n\napp.on('login', (payload: AuthenticationResult, { connection }: Params) => {\n  if (connection) {\n    // Join all channels on login\n    joinChannels(connection.user, connection)\n  }\n})\n\n// On `updated` and `patched`, leave and re-join with new room assignments\napp.service('users').on('updated', updateChannels)\napp.service('users').on('patched', updateChannels)\n// On `removed`, remove the connection from all channels\napp.service('users').on('removed', leaveChannels)\n```\n\n<BlockQuote type=\"note\">\nThe number active connections is usually one (or none) but unless you prevent it explicitly Feathers is not preventing multiple logins of the same user (e.g. with two open browser windows or on a mobile device).\n</BlockQuote>",
    "breadcrumb": "Channels",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/channels.md",
    "heading": "Channels",
    "subHeadings": [
      "Concepts",
      "Example",
      "Connections",
      "app.on('connection')",
      "app.on('disconnect')",
      "app.on('login')",
      "app.on('logout')",
      "Channels",
      "app.channel(...names)",
      "app.channels",
      "channel.join(connection)",
      "channel.leave(connection|fn)",
      "channel.filter(fn)",
      "channel.send(data)",
      "channel.connections",
      "channel.length",
      "Publishing",
      "service.publish([event,] fn)",
      "app.publish([event,] fn)",
      "Publisher precedence",
      "Keeping channels updated"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 4316,
    "category": "api",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "authentication",
      "database",
      "real-time",
      "channels",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "hook context",
      "socket.io",
      "middleware",
      "application"
    ]
  },
  {
    "id": "v6-rest-0",
    "content": "# REST Client\nBreadcrumb: REST Client\nCovers: rest-client | rest([baseUrl]) | params.headers | params.connection | app.rest | Request libraries | FormData and File Uploads | Streaming Uploads | Streaming Responses (SSE) | Custom Methods | Connecting to multiple servers | Extending rest clients | HTTP API | Authentication | find | get | create | update | patch | remove | Custom methods | Route placeholders\nTopics: hooks, services, context, params, authentication, authorization, jwt, schema, database, adapter, real-time, websockets, channels, events, rest, find, get, create, update, patch, remove, custom methods, socket.io, middleware, application\n\n## rest-client\n\n::badges{npm=\"@feathersjs/rest-client\" changelog=\"https://github.com/feathersjs/feathers/blob/dove/packages/rest-client/CHANGELOG.md\"}\n::\n\n```\nnpm install @feathersjs/rest-client --save\n```\n\n`@feathersjs/rest-client` allows to connect to a service exposed through a REST HTTP transport (e.g. with [Koa](../koa#rest) or [Express](../express#rest)) using [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), [Superagent](https://github.com/ladjs/superagent) or [Axios](https://github.com/mzabriskie/axios).\n\n<BlockQuote type=\"note\">\nFor directly using a Feathers REST API (via HTTP) without using Feathers on the client see the [HTTP API](#http-api) section.\n</BlockQuote>\n\n<BlockQuote type=\"tip\">\nREST client services do emit `created`, `updated`, `patched` and `removed` events but only _locally for their own instance_. Real-time events from other clients can only be received by using a real-time transport like [Socket.io](./socketio).\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nA client application can only use **a single transport** (e.g. either REST or Socket.io). Using two transports in the same client application is not necessary.\n</BlockQuote>\n\n### rest([baseUrl])\n\nREST client services can be initialized by loading `@feathersjs/rest-client` and initializing a client object with a base URL.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\n\nconst app = feathers()\n\n// Connect to the same as the browser URL (only in the browser)\nconst restClient = rest()\n\n// Connect to a different URL\nconst restClient = rest('http://feathers-api.com')\n\n// Configure an AJAX library (see below) with that client\napp.configure(restClient.fetch(window.fetch.bind(window)))\n\n// Connect to the `http://feathers-api.com/messages` service\nconst messages = app.service('messages')\n```\n\nThe base URL is relative from where services are registered. That means that\n\n- A service at `http://api.feathersjs.com/api/v1/messages` with a base URL of `http://api.feathersjs.com` would be available as `app.service('api/v1/messages')`\n- A base URL of `http://api.feathersjs.com/api/v1` would be `app.service('messages')`.\n\n<BlockQuote type=\"warning\">\nIn the browser `window.fetch` (which the same as the global `fetch`) has to be passed as `window.fetch.bind(window)` otherwise it will be called with an incorrect context, causing a JavaScript error: `Failed to execute 'fetch' on 'Window': Illegal invocation`.\n</BlockQuote>\n\n### params.headers\n\nRequest specific headers can be through `params.headers` in a service call:\n\n```js\napp.service('messages').create(\n  {\n    text: 'A message from a REST client'\n  },\n  {\n    headers: { 'X-Requested-With': 'FeathersJS' }\n  }\n)\n```\n\n### params.connection\n\nAllows to pass additional options specific to the AJAX library. `params.connection.headers` will be merged with `params.headers`:\n\n```js\napp.configure(restClient.axios(axios))\n\napp.service('messages').get(1, {\n  connection: {\n    // Axios specific options here\n  }\n})\n```\n\n### app.rest\n\n`app.rest` contains a reference to the `connection` object passed to `rest().<name>(connection)`.\n\n### Request libraries\n\nThe Feathers REST client can be used with several HTTP request libraries.\n\n#### Fetch\n\nThe [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) is the recommended way to make client connections since it does not require a third party library on most platforms:\n\n```js\n// In Node\napp.configure(restClient.fetch(fetch))\n\n// In modern browsers\napp.configure(restClient.fetch(window.fetch.bind(window)))\n```\n\nWhere supported, an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) can be used to abort fetch requests:\n\n```js\nconst controller = new AbortController()\n\napp.configure(restClient.fetch(fetch))\n\napp.service('messages').get(1, {\n  connection: {\n    signal: controller.signal\n  }\n})\n\ncontroller.abort()\n```\n\n#### Superagent\n\n[Superagent](http://visionmedia.github.io/superagent/) currently works with a default configuration:\n\n```ts\nimport superagent from 'superagent'\n\napp.configure(restClient.superagent(superagent))\n```\n\n#### Axios\n\n[Axios](http://github.com/mzabriskie/axios) currently works with a default configuration:\n\n```js\nimport axios from 'axios'\n\napp.configure(restClient.axios(axios))\n```\n\nTo use default values for all requests, `axios.create` with [the axios configuration](https://axios-http.com/docs/req_config) can be used:\n\n```js\nimport axios from 'axios'\n\napp.configure(\n  restClient.axios(\n    axios.create({\n      headers: { 'X-Requested-With': 'My-Feathers-Frontend' }\n    })\n  )\n)\n```\n\n### FormData and File Uploads\n\nThe REST client automatically detects when you pass a `FormData` object and handles it appropriately - skipping JSON serialization and letting the browser set the correct `Content-Type` header with the multipart boundary.\n\n```ts\n// Create a FormData object\nconst formData = new FormData()\nformData.append('file', fileInput.files[0])\nformData.append('description', 'My uploaded file')\n\n// Upload using the service - FormData is auto-detected\nconst result = await app.service('uploads').create(formData)\n```\n\nOn the server, the data is parsed and converted to a plain object:\n\n```ts\n// Server receives:\n{\n  file: File,\n  description: 'My uploaded file'\n}\n```\n\nMultiple values for the same field name become an array:\n\n```ts\n// Client\nconst formData = new FormData()\nformData.append('files', file1)\nformData.append('files', file2)\nformData.append('files', file3)\n\n// Server receives:\n{\n  files: [File, File, File] // All files in one array\n}\n```\n\n<BlockQuote type=\"warning\">\nFormData and file uploads are only supported with the REST/HTTP transport. Socket.io does not support FormData - attempting to send FormData over websockets will result in an error.\n</BlockQuote>\n\n<BlockQuote type=\"note\">\nFile uploads use the native `Request.formData()` API which buffers the entire request into memory. For large file uploads (videos, large datasets), consider using presigned URLs to upload directly to cloud storage (S3, R2, etc.).\n</BlockQuote>\n\n### Streaming Uploads\n\nThe REST client supports streaming data to services using `ReadableStream`. This is useful for large file uploads, real-time data ingestion, or piping data directly to storage without buffering.\n\n```ts\n// Stream a file to a service\nconst file = fileInput.files[0]\nconst stream = file.stream()\n\nconst result = await app.service('uploads').create(stream, {\n  headers: {\n    'Content-Type': file.type,\n    'X-Filename': file.name\n  }\n})\n```\n\nOn the server, the service receives the `ReadableStream` directly:\n\n```ts\nclass UploadService {\n  async create(stream: ReadableStream, params: Params) {\n    const filename = params.headers['x-filename']\n    const contentType = params.headers['content-type']\n\n    // Pipe directly to storage - no buffering\n    await storage.upload(filename, stream, { contentType })\n\n    return { filename, uploaded: true }\n  }\n}\n```\n\nThe stream can be piped directly to cloud storage (S3, R2, etc.) without loading the entire file into memory:\n\n```ts\nasync create(stream: ReadableStream, params: Params) {\n  // Stream directly to R2/S3\n  await env.MY_BUCKET.put(params.headers['x-filename'], stream)\n  return { success: true }\n}\n```\n\nFor more complex metadata, you can stringify an object into a header:\n\n```ts\n// Client\nconst file = fileInput.files[0]\n\nawait app.service('csv-import').create(file.stream(), {\n  headers: {\n    'Content-Type': 'text/csv',\n    'X-Import-Options': JSON.stringify({\n      filename: file.name,\n      tableName: 'products',\n      skipHeader: true\n    })\n  }\n})\n\n// Server\nasync create(stream: ReadableStream, params: Params) {\n  const options = JSON.parse(params.headers['x-import-options'])\n  // options.filename, options.tableName, options.skipHeader\n}\n```\n\n<BlockQuote type=\"warning\">\nHTTP headers are typically limited to 8KB total. Keep metadata small - use headers for filenames, options, and IDs, not large data payloads.\n</BlockQuote>\n\n<BlockQuote type=\"note\">\nIf no `Content-Type` header is specified, streaming requests default to `application/octet-stream`. Any content type not recognized as JSON, form-urlencoded, or multipart will be streamed through to the service.\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nStreaming uploads are only supported with the REST/HTTP transport. Socket.io does not support streaming request bodies.\n</BlockQuote>\n\n### Streaming Responses (SSE)\n\nWhen a service returns an [async generator or async iterable](../http#async-iterators-sse), the server sends the response as Server-Sent Events (SSE). The REST client automatically detects this and returns an async iterable that you can consume with `for await...of`:\n\n```ts\n// Server - service returns an async generator\nclass ChatService {\n  async *create(data: { prompt: string }) {\n    const stream = await ai.generateStream(data.prompt)\n\n    for await (const chunk of stream) {\n      yield { type: 'text', content: chunk }\n    }\n  }\n}\n\n// Client - consume the stream\nconst response = app.service('chat').create({ prompt: 'Hello' })\n\nfor await (const chunk of response) {\n  console.log(chunk.content) // Streams in real-time\n}\n```\n\nThis is useful for:\n\n- **AI/LLM responses** - Stream tokens as they're generated\n- **Progress updates** - Report status during long-running operations\n- **Live data feeds** - Push data to clients as it becomes available\n\n```ts\n// Example: Streaming AI chat with status updates\nclass AIChatService {\n  async *create(data: { messages: Message[] }, params: Params) {\n    yield { type: 'status', text: 'Thinking...' }\n\n    const stream = await llm.chat(data.messages)\n\n    for await (const token of stream) {\n      yield { type: 'text', text: token }\n    }\n\n    yield { type: 'done' }\n  }\n}\n\n// Client\nlet fullResponse = ''\n\nfor await (const event of app.service('ai-chat').create({ messages })) {\n  if (event.type === 'status') {\n    showStatus(event.text)\n  } else if (event.type === 'text') {\n    fullResponse += event.text\n    updateUI(fullResponse)\n  }\n}\n```\n\n<BlockQuote type=\"note\">\nThe client automatically handles SSE stream buffering, correctly parsing events even when they arrive split across network chunks. This ensures reliable streaming regardless of network conditions.\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nStreaming responses are only supported with the REST/HTTP transport. For real-time updates over Socket.io, use [channels and events](../channels) instead.\n</BlockQuote>\n\n### Custom Methods\n\nOn the client, [custom service methods](../services#custom-methods) registered using the `methods` option when registering the service via `restClient.service()`:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\nimport type { RestService } from '@feathersjs/rest-client'\n\n// `data` and return type of custom method\ntype CustomMethodData = { name: string }\ntype CustomMethodResponse = { acknowledged: boolean }\n\ntype ServiceTypes = {\n  // The type is a RestService extended with custom methods\n  myservice: RestService & {\n    myCustomMethod(data: CustomMethodData, params: Params): Promise<CustomMethodResponse>\n  }\n}\n\nconst client = feathers<ServiceTypes>()\n\n// Connect to the same as the browser URL (only in the browser)\nconst restClient = rest().fetch(window.fetch.bind(window))\n\n// Connect to a different URL\nconst restClient = rest('http://feathers-api.com').fetch(window.fetch.bind(window))\n\n// Configure an AJAX library (see below) with that client\nclient.configure(restClient)\n\n// Register a REST client service with all methods listed\nclient.use('myservice', restClient.service('myservice'), {\n  methods: ['find', 'get', 'create', 'update', 'patch', 'remove', 'myCustomMethod']\n})\n\n// Then it can be used like other service methods\nclient.service('myservice').myCustomMethod(data, params)\n```\n\n<BlockQuote type=\"note\">\nJust like on the server _all_ methods you want to use have to be listed in the `methods` option.\n</BlockQuote>\n\n### Connecting to multiple servers\n\nIt is possible to instantiate and use individual services pointing to different servers by calling `rest('server').<library>().service(name)`:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\n\nconst app = feathers()\n\nconst client1 = rest('http://feathers-api.com').fetch(window.fetch.bind(window))\nconst client2 = rest('http://other-feathers-api.com').fetch(window.fetch.bind(window))\n\n// With additional options to e.g. set authentication information\nconst client2 = rest('http://other-feathers-api.com').fetch(window.fetch.bind(window), {\n  headers: {\n    Authorization: 'Bearer <Token for other-feathers-api.com>'\n  }\n})\n\n// Configuring this will initialize default services for http://feathers-api.com\napp.configure(client1)\n\n// Connect to the `http://feathers-api.com/messages` service\nconst messages = app.service('messages')\n\n// Register /users service that points to http://other-feathers-api.com/users\napp.use('users', client2.service('users'))\n\nconst users = app.service('users')\n```\n\n<BlockQuote type=\"note\">\nIf the authentication information is different, it needs to be set as an option as shown above or via `params.headers` when making the request.\n</BlockQuote>\n\n### Extending rest clients\n\nThis can be useful if you e.g. wish to override how the query is transformed before it is sent to the API.\n\n```ts\nimport type { Query } from '@feathersjs/feathers'\nimport { FetchClient } from '@feathersjs/rest-client'\nimport qs from 'qs'\n\nclass CustomFetch extends FetchClient {\n  getQuery(query: Query) {\n    if (Object.keys(query).length !== 0) {\n      const queryString = qs.stringify(query, {\n        strictNullHandling: true\n      })\n\n      return `?${queryString}`\n    }\n\n    return ''\n  }\n}\n\napp.configure(restClient.fetch(fetch, CustomFetch))\n```\n\n## HTTP API\n\nYou can communicate with a Feathers REST API using any other HTTP REST client. The following section describes what HTTP method, body and query parameters belong to which service method call.\n\nAll query parameters in a URL will be set as `params.query` on the server. Other service parameters can be set through [hooks](../hooks) and [Express middleware](../express). URL query parameter values will always be strings. Conversion (e.g. the string `'true'` to boolean `true`) on the server is done via [schemas](../schema/index) or [hooks](../hooks).\n\nThe body type for `POST`, `PUT` and `PATCH` requests is determined by the request type. You should also make sure you are setting your `Accept` header to `application/json`. Here is the mapping of service methods to REST API calls:\n\n| Service method | HTTP method | Path        |\n| -------------- | ----------- | ----------- |\n| .find()        | GET         | /messages   |\n| .get()         | GET         | /messages/1 |\n| .create()      | POST        | /messages   |\n| .update()      | PUT         | /messages/1 |\n| .patch()       | PATCH       | /messages/1 |\n| .remove()      | DELETE      | /messages/1 |\n\n### Authentication\n\nAuthenticating HTTP (REST) requests is a two step process. First you have to obtain a JWT from the [authentication service](../authentication/service) by POSTing the strategy you want to use:\n\n```json\n// POST /authentication the Content-Type header set to application/json\n{\n  \"strategy\": \"local\",\n  \"email\": \"your email\",\n  \"password\": \"your password\"\n}\n```\n\nHere is what that looks like with curl:\n\n```bash\ncurl -H \"Content-Type: application/json\" -X POST -d '{\"strategy\":\"local\",\"email\":\"your email\",\"password\":\"your password\"}' http://localhost:3030/authentication\n```\n\nThen to authenticate subsequent requests, add the returned `accessToken` to the `Authorization` header as `Bearer <your access token>`:\n\n```bash\ncurl -H \"Content-Type: application/json\" -H \"Authorization: Bearer <your access token>\" http://localhost:3030/messages\n```\n\nFor more information see the [authentication API documentation](../).\n\n### find\n\nRetrieves a list of all matching resources from the service\n\n```\nGET /messages?status=read&user=10\n```\n\nWill call `messages.find({ query: { status: 'read', userId: '10' } })` on the server.\n\nIf you want to use any of the built-in find operands ($le, $lt, $ne, $eq, $in, etc.) the general format is as follows:\n\n```\nGET /messages?field[$operand]=value&field[$operand]=value2\n```\n\nFor example, to find the records where field _status_ is not equal to **active** you could do\n\n```\nGET /messages?status[$ne]=active\n```\n\nThe find API allows the use of $limit, $skip, $sort, and $select in the query. These special parameters can be passed directly inside the query object:\n\n```\n// Find all messages that are read, limit to 10, only include text field.\n{\"status\": \"read\", \"$limit\":10, \"$select\": [\"name\"] } } // JSON\n\nGET /messages?status=read&$limit=10&$select[]=text // HTTP\n```\n\nMore information about the possible parameters for official database adapters can be found [in the database querying section](../databases/querying).\n\n### get\n\nRetrieve a single resource from the service.\n\n```\nGET /messages/1\n```\n\nWill call `messages.get(1, {})` on the server.\n\n```\nGET /messages/1?status=read\n```\n\nWill call `messages.get(1, { query: { status: 'read' } })` on the server.\n\n### create\n\nCreate a new resource with `data` which may also be an array.\n\n```\nPOST /messages\n{ \"text\": \"I really have to iron\" }\n```\n\nWill call `messages.create({ \"text\": \"I really have to iron\" }, {})` on the server.\n\n```\nPOST /messages\n[\n  { \"text\": \"I really have to iron\" },\n  { \"text\": \"Do laundry\" }\n]\n```\n\n<BlockQuote type=\"note\">\nWith a [database adapters](../databases/adapters) the [`multi` option](../databases/common) has to be set explicitly to support creating multiple entries.\n</BlockQuote>\n\n### update\n\nCompletely replace a single or multiple resources.\n\n```\nPUT /messages/2\n{ \"text\": \"I really have to do laundry\" }\n```\n\nWill call `messages.update(2, { text: 'I really have to do laundry' }, {})` on the server. When no `id` is given by sending the request directly to the endpoint something like:\n\n```\nPUT /messages?status=unread\n{ \"status\": \"read\" }\n```\n\nWill call `messages.update(null, { status: 'read' }, { query: { status: 'unread' } })` on the server.\n\n### patch\n\nMerge the existing data of a single or multiple resources with the new `data`.\n\n```\nPATCH /messages/2\n{ \"status\": \"read\" }\n```\n\nWill call `messages.patch(2, { status: 'read' }, {})` on the server. When no `id` is given by sending the request directly to the endpoint something like:\n\n```\nPATCH /messages?status=unread\n{ \"status\": \"read\" }\n```\n\nWill call `messages.patch(null, { status: 'read' }, { query: { status: 'unread' } })` on the server to change the status for all read messages.\n\n<BlockQuote type=\"note\">\nWith a [database adapters](../databases/adapters) the [`multi` option](../databases/common) has to be set to support patching multiple entries.\n</BlockQuote>\n\nThis is supported out of the box by the Feathers [database adapters](../databases/adapters)\n\n### remove\n\nRemove a single or multiple resources:\n\n```\nDELETE /messages/2\n```\n\nWill call `messages.remove(2, {} })`.\n\nWhen no `id` is given by sending the request directly to the endpoint something like:\n\n```\nDELETE /messages?status=archived\n```\n\nWill call `messages.remove(null, { query: { status: 'archived' } })` to delete all read messages.\n\n<BlockQuote type=\"note\">\nWith a [database adapters](../databases/adapters) the [`multi` option](../databases/common) has to be set to support patching multiple entries.\n</BlockQuote>\n\n### Custom methods\n\n[Custom service methods](../services#custom-methods) can be called directly via HTTP by sending a POST request and setting the `X-Service-Method` header to the method you want to call:\n\n```\nPOST /messages\n\nX-Service-Method: myCustomMethod\n\n{\n  \"message\": \"Hello world\"\n}\n```\n\nVia CURL:\n\n```bash\ncurl -H \"Content-Type: application/json\" -H \"X-Service-Method: myCustomMethod\" -X POST -d '{\"message\": \"Hello world\"}' http://localhost:3030/myservice\n```\n\nThis will call `messages.myCustomMethod({ message: 'Hello world' }, {})`.\n\n### Route placeholders\n\nService URLs can have placeholders, e.g. `users/:userId/messages`. (see in [express](../express#params.route) or [koa](../koa#params.route))\n\nYou can call the client with route placeholders in the `params.route` property:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\n\nconst app = feathers()\n\n// Connect to the same as the browser URL (only in the browser)\nconst restClient = rest()\n\n// Connect to a different URL\nconst restClient = rest('http://feathers-api.com')\n\n// Configure an AJAX library (see below) with that client\napp.configure(restClient.fetch(window.fetch.bind(window)))\n\n// Connect to the `http://feathers-api.com/messages` service\nconst messages = app.service('users/:userId/messages')\n\n// Call the `http://feathers-api.com/users/2/messages` URL\nmessages.find({\n  route: {\n    userId: 2\n  }\n})\n```\n\nThis can also be achieved by using the client bundled,\nsharing several `servicePath` variable exported in the [service shared file](../../guides/cli/service.shared#Variables) file.\n\n```ts\nimport rest from '@feathersjs/rest-client'\n// usersMessagesPath contains 'users/:userId/messages'\nimport { createClient, usersMessagesPath } from 'my-app'\n\nconst connection = rest('https://myapp.com').fetch(window.fetch.bind(window))\n\nconst client = createClient(connection)\n\n// Call the `https://myapp.com/users/2/messages` URL\nclient.service(usersMessagesPath).find({\n  route: {\n    userId: 2\n  }\n})\n```",
    "rawContent": "## rest-client\n\n::badges{npm=\"@feathersjs/rest-client\" changelog=\"https://github.com/feathersjs/feathers/blob/dove/packages/rest-client/CHANGELOG.md\"}\n::\n\n```\nnpm install @feathersjs/rest-client --save\n```\n\n`@feathersjs/rest-client` allows to connect to a service exposed through a REST HTTP transport (e.g. with [Koa](../koa#rest) or [Express](../express#rest)) using [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), [Superagent](https://github.com/ladjs/superagent) or [Axios](https://github.com/mzabriskie/axios).\n\n<BlockQuote type=\"note\">\nFor directly using a Feathers REST API (via HTTP) without using Feathers on the client see the [HTTP API](#http-api) section.\n</BlockQuote>\n\n<BlockQuote type=\"tip\">\nREST client services do emit `created`, `updated`, `patched` and `removed` events but only _locally for their own instance_. Real-time events from other clients can only be received by using a real-time transport like [Socket.io](./socketio).\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nA client application can only use **a single transport** (e.g. either REST or Socket.io). Using two transports in the same client application is not necessary.\n</BlockQuote>\n\n### rest([baseUrl])\n\nREST client services can be initialized by loading `@feathersjs/rest-client` and initializing a client object with a base URL.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\n\nconst app = feathers()\n\n// Connect to the same as the browser URL (only in the browser)\nconst restClient = rest()\n\n// Connect to a different URL\nconst restClient = rest('http://feathers-api.com')\n\n// Configure an AJAX library (see below) with that client\napp.configure(restClient.fetch(window.fetch.bind(window)))\n\n// Connect to the `http://feathers-api.com/messages` service\nconst messages = app.service('messages')\n```\n\nThe base URL is relative from where services are registered. That means that\n\n- A service at `http://api.feathersjs.com/api/v1/messages` with a base URL of `http://api.feathersjs.com` would be available as `app.service('api/v1/messages')`\n- A base URL of `http://api.feathersjs.com/api/v1` would be `app.service('messages')`.\n\n<BlockQuote type=\"warning\">\nIn the browser `window.fetch` (which the same as the global `fetch`) has to be passed as `window.fetch.bind(window)` otherwise it will be called with an incorrect context, causing a JavaScript error: `Failed to execute 'fetch' on 'Window': Illegal invocation`.\n</BlockQuote>\n\n### params.headers\n\nRequest specific headers can be through `params.headers` in a service call:\n\n```js\napp.service('messages').create(\n  {\n    text: 'A message from a REST client'\n  },\n  {\n    headers: { 'X-Requested-With': 'FeathersJS' }\n  }\n)\n```\n\n### params.connection\n\nAllows to pass additional options specific to the AJAX library. `params.connection.headers` will be merged with `params.headers`:\n\n```js\napp.configure(restClient.axios(axios))\n\napp.service('messages').get(1, {\n  connection: {\n    // Axios specific options here\n  }\n})\n```\n\n### app.rest\n\n`app.rest` contains a reference to the `connection` object passed to `rest().<name>(connection)`.\n\n### Request libraries\n\nThe Feathers REST client can be used with several HTTP request libraries.\n\n#### Fetch\n\nThe [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) is the recommended way to make client connections since it does not require a third party library on most platforms:\n\n```js\n// In Node\napp.configure(restClient.fetch(fetch))\n\n// In modern browsers\napp.configure(restClient.fetch(window.fetch.bind(window)))\n```\n\nWhere supported, an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) can be used to abort fetch requests:\n\n```js\nconst controller = new AbortController()\n\napp.configure(restClient.fetch(fetch))\n\napp.service('messages').get(1, {\n  connection: {\n    signal: controller.signal\n  }\n})\n\ncontroller.abort()\n```\n\n#### Superagent\n\n[Superagent](http://visionmedia.github.io/superagent/) currently works with a default configuration:\n\n```ts\nimport superagent from 'superagent'\n\napp.configure(restClient.superagent(superagent))\n```\n\n#### Axios\n\n[Axios](http://github.com/mzabriskie/axios) currently works with a default configuration:\n\n```js\nimport axios from 'axios'\n\napp.configure(restClient.axios(axios))\n```\n\nTo use default values for all requests, `axios.create` with [the axios configuration](https://axios-http.com/docs/req_config) can be used:\n\n```js\nimport axios from 'axios'\n\napp.configure(\n  restClient.axios(\n    axios.create({\n      headers: { 'X-Requested-With': 'My-Feathers-Frontend' }\n    })\n  )\n)\n```\n\n### FormData and File Uploads\n\nThe REST client automatically detects when you pass a `FormData` object and handles it appropriately - skipping JSON serialization and letting the browser set the correct `Content-Type` header with the multipart boundary.\n\n```ts\n// Create a FormData object\nconst formData = new FormData()\nformData.append('file', fileInput.files[0])\nformData.append('description', 'My uploaded file')\n\n// Upload using the service - FormData is auto-detected\nconst result = await app.service('uploads').create(formData)\n```\n\nOn the server, the data is parsed and converted to a plain object:\n\n```ts\n// Server receives:\n{\n  file: File,\n  description: 'My uploaded file'\n}\n```\n\nMultiple values for the same field name become an array:\n\n```ts\n// Client\nconst formData = new FormData()\nformData.append('files', file1)\nformData.append('files', file2)\nformData.append('files', file3)\n\n// Server receives:\n{\n  files: [File, File, File] // All files in one array\n}\n```\n\n<BlockQuote type=\"warning\">\nFormData and file uploads are only supported with the REST/HTTP transport. Socket.io does not support FormData - attempting to send FormData over websockets will result in an error.\n</BlockQuote>\n\n<BlockQuote type=\"note\">\nFile uploads use the native `Request.formData()` API which buffers the entire request into memory. For large file uploads (videos, large datasets), consider using presigned URLs to upload directly to cloud storage (S3, R2, etc.).\n</BlockQuote>\n\n### Streaming Uploads\n\nThe REST client supports streaming data to services using `ReadableStream`. This is useful for large file uploads, real-time data ingestion, or piping data directly to storage without buffering.\n\n```ts\n// Stream a file to a service\nconst file = fileInput.files[0]\nconst stream = file.stream()\n\nconst result = await app.service('uploads').create(stream, {\n  headers: {\n    'Content-Type': file.type,\n    'X-Filename': file.name\n  }\n})\n```\n\nOn the server, the service receives the `ReadableStream` directly:\n\n```ts\nclass UploadService {\n  async create(stream: ReadableStream, params: Params) {\n    const filename = params.headers['x-filename']\n    const contentType = params.headers['content-type']\n\n    // Pipe directly to storage - no buffering\n    await storage.upload(filename, stream, { contentType })\n\n    return { filename, uploaded: true }\n  }\n}\n```\n\nThe stream can be piped directly to cloud storage (S3, R2, etc.) without loading the entire file into memory:\n\n```ts\nasync create(stream: ReadableStream, params: Params) {\n  // Stream directly to R2/S3\n  await env.MY_BUCKET.put(params.headers['x-filename'], stream)\n  return { success: true }\n}\n```\n\nFor more complex metadata, you can stringify an object into a header:\n\n```ts\n// Client\nconst file = fileInput.files[0]\n\nawait app.service('csv-import').create(file.stream(), {\n  headers: {\n    'Content-Type': 'text/csv',\n    'X-Import-Options': JSON.stringify({\n      filename: file.name,\n      tableName: 'products',\n      skipHeader: true\n    })\n  }\n})\n\n// Server\nasync create(stream: ReadableStream, params: Params) {\n  const options = JSON.parse(params.headers['x-import-options'])\n  // options.filename, options.tableName, options.skipHeader\n}\n```\n\n<BlockQuote type=\"warning\">\nHTTP headers are typically limited to 8KB total. Keep metadata small - use headers for filenames, options, and IDs, not large data payloads.\n</BlockQuote>\n\n<BlockQuote type=\"note\">\nIf no `Content-Type` header is specified, streaming requests default to `application/octet-stream`. Any content type not recognized as JSON, form-urlencoded, or multipart will be streamed through to the service.\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nStreaming uploads are only supported with the REST/HTTP transport. Socket.io does not support streaming request bodies.\n</BlockQuote>\n\n### Streaming Responses (SSE)\n\nWhen a service returns an [async generator or async iterable](../http#async-iterators-sse), the server sends the response as Server-Sent Events (SSE). The REST client automatically detects this and returns an async iterable that you can consume with `for await...of`:\n\n```ts\n// Server - service returns an async generator\nclass ChatService {\n  async *create(data: { prompt: string }) {\n    const stream = await ai.generateStream(data.prompt)\n\n    for await (const chunk of stream) {\n      yield { type: 'text', content: chunk }\n    }\n  }\n}\n\n// Client - consume the stream\nconst response = app.service('chat').create({ prompt: 'Hello' })\n\nfor await (const chunk of response) {\n  console.log(chunk.content) // Streams in real-time\n}\n```\n\nThis is useful for:\n\n- **AI/LLM responses** - Stream tokens as they're generated\n- **Progress updates** - Report status during long-running operations\n- **Live data feeds** - Push data to clients as it becomes available\n\n```ts\n// Example: Streaming AI chat with status updates\nclass AIChatService {\n  async *create(data: { messages: Message[] }, params: Params) {\n    yield { type: 'status', text: 'Thinking...' }\n\n    const stream = await llm.chat(data.messages)\n\n    for await (const token of stream) {\n      yield { type: 'text', text: token }\n    }\n\n    yield { type: 'done' }\n  }\n}\n\n// Client\nlet fullResponse = ''\n\nfor await (const event of app.service('ai-chat').create({ messages })) {\n  if (event.type === 'status') {\n    showStatus(event.text)\n  } else if (event.type === 'text') {\n    fullResponse += event.text\n    updateUI(fullResponse)\n  }\n}\n```\n\n<BlockQuote type=\"note\">\nThe client automatically handles SSE stream buffering, correctly parsing events even when they arrive split across network chunks. This ensures reliable streaming regardless of network conditions.\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nStreaming responses are only supported with the REST/HTTP transport. For real-time updates over Socket.io, use [channels and events](../channels) instead.\n</BlockQuote>\n\n### Custom Methods\n\nOn the client, [custom service methods](../services#custom-methods) registered using the `methods` option when registering the service via `restClient.service()`:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\nimport type { RestService } from '@feathersjs/rest-client'\n\n// `data` and return type of custom method\ntype CustomMethodData = { name: string }\ntype CustomMethodResponse = { acknowledged: boolean }\n\ntype ServiceTypes = {\n  // The type is a RestService extended with custom methods\n  myservice: RestService & {\n    myCustomMethod(data: CustomMethodData, params: Params): Promise<CustomMethodResponse>\n  }\n}\n\nconst client = feathers<ServiceTypes>()\n\n// Connect to the same as the browser URL (only in the browser)\nconst restClient = rest().fetch(window.fetch.bind(window))\n\n// Connect to a different URL\nconst restClient = rest('http://feathers-api.com').fetch(window.fetch.bind(window))\n\n// Configure an AJAX library (see below) with that client\nclient.configure(restClient)\n\n// Register a REST client service with all methods listed\nclient.use('myservice', restClient.service('myservice'), {\n  methods: ['find', 'get', 'create', 'update', 'patch', 'remove', 'myCustomMethod']\n})\n\n// Then it can be used like other service methods\nclient.service('myservice').myCustomMethod(data, params)\n```\n\n<BlockQuote type=\"note\">\nJust like on the server _all_ methods you want to use have to be listed in the `methods` option.\n</BlockQuote>\n\n### Connecting to multiple servers\n\nIt is possible to instantiate and use individual services pointing to different servers by calling `rest('server').<library>().service(name)`:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\n\nconst app = feathers()\n\nconst client1 = rest('http://feathers-api.com').fetch(window.fetch.bind(window))\nconst client2 = rest('http://other-feathers-api.com').fetch(window.fetch.bind(window))\n\n// With additional options to e.g. set authentication information\nconst client2 = rest('http://other-feathers-api.com').fetch(window.fetch.bind(window), {\n  headers: {\n    Authorization: 'Bearer <Token for other-feathers-api.com>'\n  }\n})\n\n// Configuring this will initialize default services for http://feathers-api.com\napp.configure(client1)\n\n// Connect to the `http://feathers-api.com/messages` service\nconst messages = app.service('messages')\n\n// Register /users service that points to http://other-feathers-api.com/users\napp.use('users', client2.service('users'))\n\nconst users = app.service('users')\n```\n\n<BlockQuote type=\"note\">\nIf the authentication information is different, it needs to be set as an option as shown above or via `params.headers` when making the request.\n</BlockQuote>\n\n### Extending rest clients\n\nThis can be useful if you e.g. wish to override how the query is transformed before it is sent to the API.\n\n```ts\nimport type { Query } from '@feathersjs/feathers'\nimport { FetchClient } from '@feathersjs/rest-client'\nimport qs from 'qs'\n\nclass CustomFetch extends FetchClient {\n  getQuery(query: Query) {\n    if (Object.keys(query).length !== 0) {\n      const queryString = qs.stringify(query, {\n        strictNullHandling: true\n      })\n\n      return `?${queryString}`\n    }\n\n    return ''\n  }\n}\n\napp.configure(restClient.fetch(fetch, CustomFetch))\n```\n\n## HTTP API\n\nYou can communicate with a Feathers REST API using any other HTTP REST client. The following section describes what HTTP method, body and query parameters belong to which service method call.\n\nAll query parameters in a URL will be set as `params.query` on the server. Other service parameters can be set through [hooks](../hooks) and [Express middleware](../express). URL query parameter values will always be strings. Conversion (e.g. the string `'true'` to boolean `true`) on the server is done via [schemas](../schema/index) or [hooks](../hooks).\n\nThe body type for `POST`, `PUT` and `PATCH` requests is determined by the request type. You should also make sure you are setting your `Accept` header to `application/json`. Here is the mapping of service methods to REST API calls:\n\n| Service method | HTTP method | Path        |\n| -------------- | ----------- | ----------- |\n| .find()        | GET         | /messages   |\n| .get()         | GET         | /messages/1 |\n| .create()      | POST        | /messages   |\n| .update()      | PUT         | /messages/1 |\n| .patch()       | PATCH       | /messages/1 |\n| .remove()      | DELETE      | /messages/1 |\n\n### Authentication\n\nAuthenticating HTTP (REST) requests is a two step process. First you have to obtain a JWT from the [authentication service](../authentication/service) by POSTing the strategy you want to use:\n\n```json\n// POST /authentication the Content-Type header set to application/json\n{\n  \"strategy\": \"local\",\n  \"email\": \"your email\",\n  \"password\": \"your password\"\n}\n```\n\nHere is what that looks like with curl:\n\n```bash\ncurl -H \"Content-Type: application/json\" -X POST -d '{\"strategy\":\"local\",\"email\":\"your email\",\"password\":\"your password\"}' http://localhost:3030/authentication\n```\n\nThen to authenticate subsequent requests, add the returned `accessToken` to the `Authorization` header as `Bearer <your access token>`:\n\n```bash\ncurl -H \"Content-Type: application/json\" -H \"Authorization: Bearer <your access token>\" http://localhost:3030/messages\n```\n\nFor more information see the [authentication API documentation](../).\n\n### find\n\nRetrieves a list of all matching resources from the service\n\n```\nGET /messages?status=read&user=10\n```\n\nWill call `messages.find({ query: { status: 'read', userId: '10' } })` on the server.\n\nIf you want to use any of the built-in find operands ($le, $lt, $ne, $eq, $in, etc.) the general format is as follows:\n\n```\nGET /messages?field[$operand]=value&field[$operand]=value2\n```\n\nFor example, to find the records where field _status_ is not equal to **active** you could do\n\n```\nGET /messages?status[$ne]=active\n```\n\nThe find API allows the use of $limit, $skip, $sort, and $select in the query. These special parameters can be passed directly inside the query object:\n\n```\n// Find all messages that are read, limit to 10, only include text field.\n{\"status\": \"read\", \"$limit\":10, \"$select\": [\"name\"] } } // JSON\n\nGET /messages?status=read&$limit=10&$select[]=text // HTTP\n```\n\nMore information about the possible parameters for official database adapters can be found [in the database querying section](../databases/querying).\n\n### get\n\nRetrieve a single resource from the service.\n\n```\nGET /messages/1\n```\n\nWill call `messages.get(1, {})` on the server.\n\n```\nGET /messages/1?status=read\n```\n\nWill call `messages.get(1, { query: { status: 'read' } })` on the server.\n\n### create\n\nCreate a new resource with `data` which may also be an array.\n\n```\nPOST /messages\n{ \"text\": \"I really have to iron\" }\n```\n\nWill call `messages.create({ \"text\": \"I really have to iron\" }, {})` on the server.\n\n```\nPOST /messages\n[\n  { \"text\": \"I really have to iron\" },\n  { \"text\": \"Do laundry\" }\n]\n```\n\n<BlockQuote type=\"note\">\nWith a [database adapters](../databases/adapters) the [`multi` option](../databases/common) has to be set explicitly to support creating multiple entries.\n</BlockQuote>\n\n### update\n\nCompletely replace a single or multiple resources.\n\n```\nPUT /messages/2\n{ \"text\": \"I really have to do laundry\" }\n```\n\nWill call `messages.update(2, { text: 'I really have to do laundry' }, {})` on the server. When no `id` is given by sending the request directly to the endpoint something like:\n\n```\nPUT /messages?status=unread\n{ \"status\": \"read\" }\n```\n\nWill call `messages.update(null, { status: 'read' }, { query: { status: 'unread' } })` on the server.\n\n### patch\n\nMerge the existing data of a single or multiple resources with the new `data`.\n\n```\nPATCH /messages/2\n{ \"status\": \"read\" }\n```\n\nWill call `messages.patch(2, { status: 'read' }, {})` on the server. When no `id` is given by sending the request directly to the endpoint something like:\n\n```\nPATCH /messages?status=unread\n{ \"status\": \"read\" }\n```\n\nWill call `messages.patch(null, { status: 'read' }, { query: { status: 'unread' } })` on the server to change the status for all read messages.\n\n<BlockQuote type=\"note\">\nWith a [database adapters](../databases/adapters) the [`multi` option](../databases/common) has to be set to support patching multiple entries.\n</BlockQuote>\n\nThis is supported out of the box by the Feathers [database adapters](../databases/adapters)\n\n### remove\n\nRemove a single or multiple resources:\n\n```\nDELETE /messages/2\n```\n\nWill call `messages.remove(2, {} })`.\n\nWhen no `id` is given by sending the request directly to the endpoint something like:\n\n```\nDELETE /messages?status=archived\n```\n\nWill call `messages.remove(null, { query: { status: 'archived' } })` to delete all read messages.\n\n<BlockQuote type=\"note\">\nWith a [database adapters](../databases/adapters) the [`multi` option](../databases/common) has to be set to support patching multiple entries.\n</BlockQuote>\n\n### Custom methods\n\n[Custom service methods](../services#custom-methods) can be called directly via HTTP by sending a POST request and setting the `X-Service-Method` header to the method you want to call:\n\n```\nPOST /messages\n\nX-Service-Method: myCustomMethod\n\n{\n  \"message\": \"Hello world\"\n}\n```\n\nVia CURL:\n\n```bash\ncurl -H \"Content-Type: application/json\" -H \"X-Service-Method: myCustomMethod\" -X POST -d '{\"message\": \"Hello world\"}' http://localhost:3030/myservice\n```\n\nThis will call `messages.myCustomMethod({ message: 'Hello world' }, {})`.\n\n### Route placeholders\n\nService URLs can have placeholders, e.g. `users/:userId/messages`. (see in [express](../express#params.route) or [koa](../koa#params.route))\n\nYou can call the client with route placeholders in the `params.route` property:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\n\nconst app = feathers()\n\n// Connect to the same as the browser URL (only in the browser)\nconst restClient = rest()\n\n// Connect to a different URL\nconst restClient = rest('http://feathers-api.com')\n\n// Configure an AJAX library (see below) with that client\napp.configure(restClient.fetch(window.fetch.bind(window)))\n\n// Connect to the `http://feathers-api.com/messages` service\nconst messages = app.service('users/:userId/messages')\n\n// Call the `http://feathers-api.com/users/2/messages` URL\nmessages.find({\n  route: {\n    userId: 2\n  }\n})\n```\n\nThis can also be achieved by using the client bundled,\nsharing several `servicePath` variable exported in the [service shared file](../../guides/cli/service.shared#Variables) file.\n\n```ts\nimport rest from '@feathersjs/rest-client'\n// usersMessagesPath contains 'users/:userId/messages'\nimport { createClient, usersMessagesPath } from 'my-app'\n\nconst connection = rest('https://myapp.com').fetch(window.fetch.bind(window))\n\nconst client = createClient(connection)\n\n// Call the `https://myapp.com/users/2/messages` URL\nclient.service(usersMessagesPath).find({\n  route: {\n    userId: 2\n  }\n})\n```",
    "breadcrumb": "REST Client",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/client/rest.md",
    "heading": "REST Client",
    "subHeadings": [
      "rest-client",
      "rest([baseUrl])",
      "params.headers",
      "params.connection",
      "app.rest",
      "Request libraries",
      "FormData and File Uploads",
      "Streaming Uploads",
      "Streaming Responses (SSE)",
      "Custom Methods",
      "Connecting to multiple servers",
      "Extending rest clients",
      "HTTP API",
      "Authentication",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "Custom methods",
      "Route placeholders"
    ],
    "hasCode": true,
    "codeLanguages": [
      "text",
      "ts",
      "js",
      "json",
      "bash"
    ],
    "tokens": 5404,
    "category": "api",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "authentication",
      "authorization",
      "jwt",
      "schema",
      "database",
      "adapter",
      "real-time",
      "websockets",
      "channels",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "custom methods",
      "socket.io",
      "middleware",
      "application"
    ]
  },
  {
    "id": "v6-socketio-0",
    "content": "# Socket.io Client\nBreadcrumb: Socket.io Client\nCovers: socketio-client | socketio(socket) | `app.io` | Custom Methods | Route placeholders | Direct connection | Authentication | find | get | create | update | patch | remove | Custom methods | Listening to events\nTopics: services, params, authentication, authorization, jwt, real-time, events, rest, find, get, create, update, patch, remove, custom methods, socket.io, middleware, application\n\n## socketio-client\n\n::badges{npm=\"@feathersjs/socketio-client\" changelog=\"https://github.com/feathersjs/feathers/blob/dove/packages/socketio-client/CHANGELOG.md\"}\n::\n\n```\nnpm install @feathersjs/socketio-client socket.io-client --save\n```\n\nThe `@feathersjs/socketio-client` module allows to connect to services exposed through the [Socket.io transport](../socketio) via a Socket.io socket. We recommend using Feathers and the `@feathersjs/socketio-client` module on the client if possible since it can also handle reconnection and reauthentication. If however, you want to use a direct Socket.io connection without using Feathers on the client, see the [Direct connection](#direct-connection) section.\n\n<BlockQuote type=\"warning\">\nSocket.io is also used to _call_ service methods. Using sockets for both calling methods and receiving real-time events is generally faster than using [REST](./rest). There is therefore no need to use both REST and Socket.io in the same client application.\n</BlockQuote>\n\n### socketio(socket)\n\nInitialize the Socket.io client using a given socket and the default options.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport io from 'socket.io-client'\n\nconst socket = io('http://api.feathersjs.com')\nconst app = feathers()\n\n// Set up Socket.io client with the socket\napp.configure(socketio(socket))\n\n// Receive real-time events through Socket.io\napp.service('messages').on('created', (message) => console.log('New message created', message))\n\n// Call the `messages` service\napp.service('messages').create({\n  text: 'A message from a REST client'\n})\n```\n\n### `app.io`\n\n`app.io` contains a reference to the `socket` object passed to `socketio(socket [, options])`\n\n```ts\napp.io.on('disconnect', (reason: any) => {\n  // Show offline message\n})\n```\n\n### Custom Methods\n\nOn the client, [custom service methods](../services#custom-methods) are also registered using the `methods` option when registering the service via `socketClient.service()`:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport type { SocketService } from '@feathersjs/socketio-client'\nimport io from 'socket.io-client'\n\n// `data` and return type of custom method\ntype CustomMethodData = { name: string }\ntype CustomMethodResponse = { acknowledged: boolean }\n\ntype ServiceTypes = {\n  // The type is a Socket service extended with custom methods\n  myservice: SocketService & {\n    myCustomMethod(data: CustomMethodData, params: Params): Promise<CustomMethodResponse>\n  }\n}\n\nconst socket = io('http://api.feathersjs.com')\nconst client = feathers<ServiceTypes>()\nconst socketClient = socketio(socket)\n\n// Set up Socket.io client with the socket\nclient.configure(socketClient)\n\n// Register a socket client service with all methods listed\nclient.use('myservice', socketClient.service('myservice'), {\n  methods: ['find', 'get', 'create', 'update', 'patch', 'remove', 'myCustomMethod']\n})\n\n// Then it can be used like other service methods\nclient.service('myservice').myCustomMethod(data, params)\n```\n\n<BlockQuote type=\"note\">\nJust like on the server _all_ methods you want to use have to be listed in the `methods` option.\n</BlockQuote>\n\n### Route placeholders\n\nService URLs can have placeholders, e.g. `users/:userId/messages`. (see in [express](../express#params.route) or [koa](../koa#params.route))\n\nYou can call the client with route placeholders in the `params.route` property:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport io from 'socket.io-client'\n\nconst socket = io('http://api.feathersjs.com')\nconst app = feathers()\n\n// Set up Socket.io client with the socket\napp.configure(socketio(socket))\n\n// Call `users/2/messages`\napp.service('users/:userId/messages').find({\n  route: {\n    userId: 2\n  }\n})\n```\n\nThis can also be achieved by using the client bundled,\nsharing several `servicePath` variable exported in the [service shared file](../../guides/cli/service.shared#Variables) file.\n\n```ts\nimport rest from '@feathersjs/rest-client'\n\nconst connection = rest('https://myapp.com').fetch(window.fetch.bind(window))\n\nconst client = createClient(connection)\n\n// Call the `https://myapp.com/users/2/messages` URL\nclient.service(usersMyMessagesPath).find({\n  route: {\n    userId: 2\n  }\n})\n\nimport io from 'socket.io-client'\nimport socketio from '@feathersjs/socketio-client'\nimport { createClient, usersMessagesPath } from 'my-app'\n\nconst socket = io('http://api.my-feathers-server.com')\nconst connection = socketio(socket)\n\nconst client = createClient(connection)\n\nconst messageService = client.service('users/:userId/messages')\n\n// Call `users/2/messages`\napp.service('users/:userId/messages').find({\n  route: {\n    userId: 2\n  }\n})\n```\n\n## Direct connection\n\nFeathers sets up a normal Socket.io server that you can connect to with any Socket.io compatible client, usually the [Socket.io client](http://socket.io/docs/client-api/) either by loading the `socket.io-client` module or `/socket.io/socket.io.js` from the server. Query parameter types do not have to be converted from strings as they do for REST requests.\n\n<BlockQuote type=\"warning\">\nThe socket connection URL has to point to the server root which is where Feathers will set up Socket.io.\n</BlockQuote>\n\n```html\n<!-- Connecting to the same URL -->\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io()\n</script>\n\n<!-- Connecting to a different server -->\n<script src=\"http://localhost:3030/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io('http://localhost:3030/')\n</script>\n```\n\nService methods can be called by emitting a `<methodname>` event followed by the service path and method parameters. The service path is the name the service has been registered with (in `app.use`), without leading or trailing slashes. An optional callback following the `function(error, data)` Node convention will be called with the result of the method call or any errors that might have occurred.\n\n`params` will be set as `params.query` in the service method call. Other service parameters can be set through a [Socket.io middleware](../socketio).\n\nIf the service path or method does not exist, an appropriate Feathers error will be returned.\n\n### Authentication\n\nThere are two ways to establish an authenticated Socket.io connection. Either by calling the authentication service or by sending authentication headers.\n\n#### Via authentication service\n\nSockets will be authenticated automatically by calling [.create](#create) on the [authentication service](../authentication/service):\n\n```ts\nimport io from 'socket.io-client'\n\nconst socket = io('http://localhost:3030')\n\nsocket.emit(\n  'create',\n  'authentication',\n  {\n    strategy: 'local',\n    email: 'hello@feathersjs.com',\n    password: 'supersecret'\n  },\n  function (error, authResult) {\n    console.log(authResult)\n    // authResult will be {\"accessToken\": \"your token\", \"user\": user }\n    // You can now send authenticated messages to the server\n  }\n)\n```\n\n<BlockQuote type=\"warning\">\nWhen a socket disconnects and then reconnects, it has to be authenticated again before making any other request that requires authentication. This is usually done with the [jwt strategy](../authentication/jwt) using the `accessToken` from the `authResult`. The [authentication client](../authentication/client) handles this already automatically.\n</BlockQuote>\n\n```js\nsocket.on('connect', () => {\n  socket.emit(\n    'create',\n    'authentication',\n    {\n      strategy: 'jwt',\n      accessToken: authResult.accessToken\n    },\n    function (error, newAuthResult) {\n      console.log(newAuthResult)\n    }\n  )\n})\n```\n\n#### Via handshake headers\n\nIf the authentication strategy (e.g. JWT or API key) supports parsing headers, an authenticated websocket connection can be established by adding the information in the [extraHeaders option](https://socket.io/docs/client-api/#With-extraHeaders):\n\n```ts\nimport io from 'socket.io-client'\n\nconst socket = io('http://localhost:3030', {\n  extraHeaders: {\n    Authorization: `Bearer <accessToken here>`\n  }\n})\n```\n\n<BlockQuote type=\"note\">\nThe authentication strategy needs to be included in the [`authStrategies` configuration](../authentication/service#configuration).\n</BlockQuote>\n\n### find\n\nRetrieves a list of all matching resources from the service\n\n```js\nsocket.emit('find', 'messages', { status: 'read', user: 10 }, (error, data) => {\n  console.log('Found all messages', data)\n})\n```\n\nWill call `app.service('messages').find({ query: { status: 'read', user: 10 } })` on the server.\n\n### get\n\nRetrieve a single resource from the service.\n\n```js\nsocket.emit('get', 'messages', 1, (error, message) => {\n  console.log('Found message', message)\n})\n```\n\nWill call `app.service('messages').get(1, {})` on the server.\n\n```js\nsocket.emit('get', 'messages', 1, { status: 'read' }, (error, message) => {\n  console.log('Found message', message)\n})\n```\n\nWill call `app.service('messages').get(1, { query: { status: 'read' } })` on the server.\n\n### create\n\nCreate a new resource with `data` which may also be an array.\n\n```js\nsocket.emit(\n  'create',\n  'messages',\n  {\n    text: 'I really have to iron'\n  },\n  (error, message) => {\n    console.log('Todo created', message)\n  }\n)\n```\n\nWill call `app.service('messages').create({ text: 'I really have to iron' }, {})` on the server.\n\n```js\nsocket.emit('create', 'messages', [{ text: 'I really have to iron' }, { text: 'Do laundry' }])\n```\n\nWill call `app.service('messages').create` with the array.\n\n### update\n\nCompletely replace a single or multiple resources.\n\n```js\nsocket.emit(\n  'update',\n  'messages',\n  2,\n  {\n    text: 'I really have to do laundry'\n  },\n  (error, message) => {\n    console.log('Todo updated', message)\n  }\n)\n```\n\nWill call `app.service('messages').update(2, { text: 'I really have to do laundry' }, {})` on the server. The `id` can also be `null` to update multiple resources:\n\n```js\nsocket.emit(\n  'update',\n  'messages',\n  null,\n  {\n    status: 'unread'\n  },\n  { status: 'read' }\n)\n```\n\nWill call `app.service('messages').update(null, { status: 'read' }, { query: { satus: 'unread' } })` on the server.\n\n### patch\n\nMerge the existing data of a single or multiple resources with the new `data`.\n\n```js\nsocket.emit(\n  'patch',\n  'messages',\n  2,\n  {\n    read: true\n  },\n  (error, message) => {\n    console.log('Patched message', message)\n  }\n)\n```\n\nWill call `app.service('messages').patch(2, { read: true }, {})` on the server. The `id` can also be `null` to update multiple resources:\n\n```js\nsocket.emit(\n  'patch',\n  'messages',\n  null,\n  {\n    status: 'read'\n  },\n  {\n    status: 'unread'\n  },\n  (error, message) => {\n    console.log('Patched message', message)\n  }\n)\n```\n\nWill call `app.service('messages').patch(null, { status: 'read' }, { query: { status: 'unread' } })` on the server, to change the status for all read app.service('messages').\n\n### remove\n\nRemove a single or multiple resources:\n\n```js\nsocket.emit('remove', 'messages', 2, {}, (error, message) => {\n  console.log('Removed a message', message)\n})\n```\n\nWill call `app.service('messages').remove(2, {})` on the server. The `id` can also be `null` to remove multiple resources:\n\n```js\nsocket.emit('remove', 'messages', null, { status: 'archived' })\n```\n\nWill call `app.service('messages').remove(null, { query: { status: 'archived' } })` on the server to delete all messages with status `archived`.\n\n### Custom methods\n\n[Custom service methods](../services#custom-methods) can be called directly via Socket.io by sending a `socket.emit(methodName, serviceName, data, query)` message:\n\n```js\nsocket.emit('myCustomMethod', 'myservice', { message: 'Hello world' }, {}, (error, data) => {\n  console.log('Called myCustomMethod', data)\n})\n```\n\n### Listening to events\n\nListening to service events allows real-time behaviour in an application. [Service events](../events) are sent to the socket in the form of `servicepath eventname`.\n\n#### created\n\nThe `created` event will be published with the callback data, when a service `create` returns successfully.\n\n```ts\nconst socket = io('http://localhost:3030/')\n\nsocket.on('messages created', (message: Message) => {\n  console.log('Got a new Todo!', message)\n})\n```\n\n#### updated, patched\n\nThe `updated` and `patched` events will be published with the callback data, when a service `update` or `patch` method calls back successfully.\n\n```ts\nconst socket = io('http://localhost:3030/')\n\nsocket.on('my/messages updated', (message: Message) => {\n  console.log('Got an updated Todo!', message)\n})\n\nsocket.emit(\n  'update',\n  'my/messages',\n  1,\n  {\n    text: 'Updated text'\n  },\n  {},\n  (error, callback) => {\n    // Do something here\n  }\n)\n```\n\n#### removed\n\nThe `removed` event will be published with the callback data, when a service `remove` calls back successfully.\n\n```js\nconst socket = io('http://localhost:3030/')\n\nsocket.on('messages removed', (message: Message) => {\n  // Remove element showing the Todo from the page\n  $('#message-' + message.id).remove()\n})\n```\n\n#### Custom events\n\n[Custom events](../events#custom-events) can be listened to accordingly:\n\n```ts\nconst socket = io('http://localhost:3030/')\n\nsocket.on('messages myevent', function (data: any) {\n  console.log('Got myevent event', data)\n})\n```",
    "rawContent": "## socketio-client\n\n::badges{npm=\"@feathersjs/socketio-client\" changelog=\"https://github.com/feathersjs/feathers/blob/dove/packages/socketio-client/CHANGELOG.md\"}\n::\n\n```\nnpm install @feathersjs/socketio-client socket.io-client --save\n```\n\nThe `@feathersjs/socketio-client` module allows to connect to services exposed through the [Socket.io transport](../socketio) via a Socket.io socket. We recommend using Feathers and the `@feathersjs/socketio-client` module on the client if possible since it can also handle reconnection and reauthentication. If however, you want to use a direct Socket.io connection without using Feathers on the client, see the [Direct connection](#direct-connection) section.\n\n<BlockQuote type=\"warning\">\nSocket.io is also used to _call_ service methods. Using sockets for both calling methods and receiving real-time events is generally faster than using [REST](./rest). There is therefore no need to use both REST and Socket.io in the same client application.\n</BlockQuote>\n\n### socketio(socket)\n\nInitialize the Socket.io client using a given socket and the default options.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport io from 'socket.io-client'\n\nconst socket = io('http://api.feathersjs.com')\nconst app = feathers()\n\n// Set up Socket.io client with the socket\napp.configure(socketio(socket))\n\n// Receive real-time events through Socket.io\napp.service('messages').on('created', (message) => console.log('New message created', message))\n\n// Call the `messages` service\napp.service('messages').create({\n  text: 'A message from a REST client'\n})\n```\n\n### `app.io`\n\n`app.io` contains a reference to the `socket` object passed to `socketio(socket [, options])`\n\n```ts\napp.io.on('disconnect', (reason: any) => {\n  // Show offline message\n})\n```\n\n### Custom Methods\n\nOn the client, [custom service methods](../services#custom-methods) are also registered using the `methods` option when registering the service via `socketClient.service()`:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport type { SocketService } from '@feathersjs/socketio-client'\nimport io from 'socket.io-client'\n\n// `data` and return type of custom method\ntype CustomMethodData = { name: string }\ntype CustomMethodResponse = { acknowledged: boolean }\n\ntype ServiceTypes = {\n  // The type is a Socket service extended with custom methods\n  myservice: SocketService & {\n    myCustomMethod(data: CustomMethodData, params: Params): Promise<CustomMethodResponse>\n  }\n}\n\nconst socket = io('http://api.feathersjs.com')\nconst client = feathers<ServiceTypes>()\nconst socketClient = socketio(socket)\n\n// Set up Socket.io client with the socket\nclient.configure(socketClient)\n\n// Register a socket client service with all methods listed\nclient.use('myservice', socketClient.service('myservice'), {\n  methods: ['find', 'get', 'create', 'update', 'patch', 'remove', 'myCustomMethod']\n})\n\n// Then it can be used like other service methods\nclient.service('myservice').myCustomMethod(data, params)\n```\n\n<BlockQuote type=\"note\">\nJust like on the server _all_ methods you want to use have to be listed in the `methods` option.\n</BlockQuote>\n\n### Route placeholders\n\nService URLs can have placeholders, e.g. `users/:userId/messages`. (see in [express](../express#params.route) or [koa](../koa#params.route))\n\nYou can call the client with route placeholders in the `params.route` property:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport io from 'socket.io-client'\n\nconst socket = io('http://api.feathersjs.com')\nconst app = feathers()\n\n// Set up Socket.io client with the socket\napp.configure(socketio(socket))\n\n// Call `users/2/messages`\napp.service('users/:userId/messages').find({\n  route: {\n    userId: 2\n  }\n})\n```\n\nThis can also be achieved by using the client bundled,\nsharing several `servicePath` variable exported in the [service shared file](../../guides/cli/service.shared#Variables) file.\n\n```ts\nimport rest from '@feathersjs/rest-client'\n\nconst connection = rest('https://myapp.com').fetch(window.fetch.bind(window))\n\nconst client = createClient(connection)\n\n// Call the `https://myapp.com/users/2/messages` URL\nclient.service(usersMyMessagesPath).find({\n  route: {\n    userId: 2\n  }\n})\n\nimport io from 'socket.io-client'\nimport socketio from '@feathersjs/socketio-client'\nimport { createClient, usersMessagesPath } from 'my-app'\n\nconst socket = io('http://api.my-feathers-server.com')\nconst connection = socketio(socket)\n\nconst client = createClient(connection)\n\nconst messageService = client.service('users/:userId/messages')\n\n// Call `users/2/messages`\napp.service('users/:userId/messages').find({\n  route: {\n    userId: 2\n  }\n})\n```\n\n## Direct connection\n\nFeathers sets up a normal Socket.io server that you can connect to with any Socket.io compatible client, usually the [Socket.io client](http://socket.io/docs/client-api/) either by loading the `socket.io-client` module or `/socket.io/socket.io.js` from the server. Query parameter types do not have to be converted from strings as they do for REST requests.\n\n<BlockQuote type=\"warning\">\nThe socket connection URL has to point to the server root which is where Feathers will set up Socket.io.\n</BlockQuote>\n\n```html\n<!-- Connecting to the same URL -->\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io()\n</script>\n\n<!-- Connecting to a different server -->\n<script src=\"http://localhost:3030/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io('http://localhost:3030/')\n</script>\n```\n\nService methods can be called by emitting a `<methodname>` event followed by the service path and method parameters. The service path is the name the service has been registered with (in `app.use`), without leading or trailing slashes. An optional callback following the `function(error, data)` Node convention will be called with the result of the method call or any errors that might have occurred.\n\n`params` will be set as `params.query` in the service method call. Other service parameters can be set through a [Socket.io middleware](../socketio).\n\nIf the service path or method does not exist, an appropriate Feathers error will be returned.\n\n### Authentication\n\nThere are two ways to establish an authenticated Socket.io connection. Either by calling the authentication service or by sending authentication headers.\n\n#### Via authentication service\n\nSockets will be authenticated automatically by calling [.create](#create) on the [authentication service](../authentication/service):\n\n```ts\nimport io from 'socket.io-client'\n\nconst socket = io('http://localhost:3030')\n\nsocket.emit(\n  'create',\n  'authentication',\n  {\n    strategy: 'local',\n    email: 'hello@feathersjs.com',\n    password: 'supersecret'\n  },\n  function (error, authResult) {\n    console.log(authResult)\n    // authResult will be {\"accessToken\": \"your token\", \"user\": user }\n    // You can now send authenticated messages to the server\n  }\n)\n```\n\n<BlockQuote type=\"warning\">\nWhen a socket disconnects and then reconnects, it has to be authenticated again before making any other request that requires authentication. This is usually done with the [jwt strategy](../authentication/jwt) using the `accessToken` from the `authResult`. The [authentication client](../authentication/client) handles this already automatically.\n</BlockQuote>\n\n```js\nsocket.on('connect', () => {\n  socket.emit(\n    'create',\n    'authentication',\n    {\n      strategy: 'jwt',\n      accessToken: authResult.accessToken\n    },\n    function (error, newAuthResult) {\n      console.log(newAuthResult)\n    }\n  )\n})\n```\n\n#### Via handshake headers\n\nIf the authentication strategy (e.g. JWT or API key) supports parsing headers, an authenticated websocket connection can be established by adding the information in the [extraHeaders option](https://socket.io/docs/client-api/#With-extraHeaders):\n\n```ts\nimport io from 'socket.io-client'\n\nconst socket = io('http://localhost:3030', {\n  extraHeaders: {\n    Authorization: `Bearer <accessToken here>`\n  }\n})\n```\n\n<BlockQuote type=\"note\">\nThe authentication strategy needs to be included in the [`authStrategies` configuration](../authentication/service#configuration).\n</BlockQuote>\n\n### find\n\nRetrieves a list of all matching resources from the service\n\n```js\nsocket.emit('find', 'messages', { status: 'read', user: 10 }, (error, data) => {\n  console.log('Found all messages', data)\n})\n```\n\nWill call `app.service('messages').find({ query: { status: 'read', user: 10 } })` on the server.\n\n### get\n\nRetrieve a single resource from the service.\n\n```js\nsocket.emit('get', 'messages', 1, (error, message) => {\n  console.log('Found message', message)\n})\n```\n\nWill call `app.service('messages').get(1, {})` on the server.\n\n```js\nsocket.emit('get', 'messages', 1, { status: 'read' }, (error, message) => {\n  console.log('Found message', message)\n})\n```\n\nWill call `app.service('messages').get(1, { query: { status: 'read' } })` on the server.\n\n### create\n\nCreate a new resource with `data` which may also be an array.\n\n```js\nsocket.emit(\n  'create',\n  'messages',\n  {\n    text: 'I really have to iron'\n  },\n  (error, message) => {\n    console.log('Todo created', message)\n  }\n)\n```\n\nWill call `app.service('messages').create({ text: 'I really have to iron' }, {})` on the server.\n\n```js\nsocket.emit('create', 'messages', [{ text: 'I really have to iron' }, { text: 'Do laundry' }])\n```\n\nWill call `app.service('messages').create` with the array.\n\n### update\n\nCompletely replace a single or multiple resources.\n\n```js\nsocket.emit(\n  'update',\n  'messages',\n  2,\n  {\n    text: 'I really have to do laundry'\n  },\n  (error, message) => {\n    console.log('Todo updated', message)\n  }\n)\n```\n\nWill call `app.service('messages').update(2, { text: 'I really have to do laundry' }, {})` on the server. The `id` can also be `null` to update multiple resources:\n\n```js\nsocket.emit(\n  'update',\n  'messages',\n  null,\n  {\n    status: 'unread'\n  },\n  { status: 'read' }\n)\n```\n\nWill call `app.service('messages').update(null, { status: 'read' }, { query: { satus: 'unread' } })` on the server.\n\n### patch\n\nMerge the existing data of a single or multiple resources with the new `data`.\n\n```js\nsocket.emit(\n  'patch',\n  'messages',\n  2,\n  {\n    read: true\n  },\n  (error, message) => {\n    console.log('Patched message', message)\n  }\n)\n```\n\nWill call `app.service('messages').patch(2, { read: true }, {})` on the server. The `id` can also be `null` to update multiple resources:\n\n```js\nsocket.emit(\n  'patch',\n  'messages',\n  null,\n  {\n    status: 'read'\n  },\n  {\n    status: 'unread'\n  },\n  (error, message) => {\n    console.log('Patched message', message)\n  }\n)\n```\n\nWill call `app.service('messages').patch(null, { status: 'read' }, { query: { status: 'unread' } })` on the server, to change the status for all read app.service('messages').\n\n### remove\n\nRemove a single or multiple resources:\n\n```js\nsocket.emit('remove', 'messages', 2, {}, (error, message) => {\n  console.log('Removed a message', message)\n})\n```\n\nWill call `app.service('messages').remove(2, {})` on the server. The `id` can also be `null` to remove multiple resources:\n\n```js\nsocket.emit('remove', 'messages', null, { status: 'archived' })\n```\n\nWill call `app.service('messages').remove(null, { query: { status: 'archived' } })` on the server to delete all messages with status `archived`.\n\n### Custom methods\n\n[Custom service methods](../services#custom-methods) can be called directly via Socket.io by sending a `socket.emit(methodName, serviceName, data, query)` message:\n\n```js\nsocket.emit('myCustomMethod', 'myservice', { message: 'Hello world' }, {}, (error, data) => {\n  console.log('Called myCustomMethod', data)\n})\n```\n\n### Listening to events\n\nListening to service events allows real-time behaviour in an application. [Service events](../events) are sent to the socket in the form of `servicepath eventname`.\n\n#### created\n\nThe `created` event will be published with the callback data, when a service `create` returns successfully.\n\n```ts\nconst socket = io('http://localhost:3030/')\n\nsocket.on('messages created', (message: Message) => {\n  console.log('Got a new Todo!', message)\n})\n```\n\n#### updated, patched\n\nThe `updated` and `patched` events will be published with the callback data, when a service `update` or `patch` method calls back successfully.\n\n```ts\nconst socket = io('http://localhost:3030/')\n\nsocket.on('my/messages updated', (message: Message) => {\n  console.log('Got an updated Todo!', message)\n})\n\nsocket.emit(\n  'update',\n  'my/messages',\n  1,\n  {\n    text: 'Updated text'\n  },\n  {},\n  (error, callback) => {\n    // Do something here\n  }\n)\n```\n\n#### removed\n\nThe `removed` event will be published with the callback data, when a service `remove` calls back successfully.\n\n```js\nconst socket = io('http://localhost:3030/')\n\nsocket.on('messages removed', (message: Message) => {\n  // Remove element showing the Todo from the page\n  $('#message-' + message.id).remove()\n})\n```\n\n#### Custom events\n\n[Custom events](../events#custom-events) can be listened to accordingly:\n\n```ts\nconst socket = io('http://localhost:3030/')\n\nsocket.on('messages myevent', function (data: any) {\n  console.log('Got myevent event', data)\n})\n```",
    "breadcrumb": "Socket.io Client",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/client/socketio.md",
    "heading": "Socket.io Client",
    "subHeadings": [
      "socketio-client",
      "socketio(socket)",
      "`app.io`",
      "Custom Methods",
      "Route placeholders",
      "Direct connection",
      "Authentication",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "Custom methods",
      "Listening to events"
    ],
    "hasCode": true,
    "codeLanguages": [
      "text",
      "ts",
      "html",
      "js"
    ],
    "tokens": 3349,
    "category": "api",
    "tags": [
      "services",
      "params",
      "authentication",
      "authorization",
      "jwt",
      "real-time",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "custom methods",
      "socket.io",
      "middleware",
      "application"
    ]
  },
  {
    "id": "v6-client-0",
    "content": "# Feathers Client\nBreadcrumb: Feathers Client\nCovers: Typed client | Node | React Native | Module loaders | Webpack | create-react-app | Others | @feathersjs/client | When to use | Load from CDN with `<script>`\nTopics: authentication, schema, rest, create, feathers client, socket.io, setup, application\n\n## Typed client\n\nA Feathers application generated with Feathers v5 or later now exports a client file, including the types you defined in [schemas](./schema/index) on the server. For more information see the [CLI guide](../guides/cli/client)\n\n## Node\n\nTo connect to a Feathers server in NodeJS, install the desired client connection library (here, `socket.io-client`), alongside the Feathers core library, and the connection-specific library:\n\n```\nnpm install @feathersjs/feathers @feathersjs/socketio-client socket.io-client --save\n```\n\nThen initialize like this:\n\n```ts\nimport io from 'socket.io-client'\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\n\nconst socket = io('http://api.my-feathers-server.com')\nconst client = feathers()\n\nclient.configure(socketio(socket))\n\nconst messageService = client.service('messages')\n\nmessageService.on('created', (message: Message) => console.log('Created a message', message))\n\n// Use the messages service from the server\nmessageService.create({\n  text: 'Message from client'\n})\n```\n\n## React Native\n\nReact Native usage is the same as for the [Node client](#node). Install the required packages into your [React Native](https://facebook.github.io/react-native/) project.\n\n```bash\nnpm install @feathersjs/feathers @feathersjs/socketio-client socket.io-client\n```\n\nThen in the main application file:\n\n```ts\nimport io from 'socket.io-client'\nimport { AsyncStorage } from 'react-native'\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport authentication from '@feathersjs/authentication-client'\n\nconst socket = io('http://api.my-feathers-server.com', {\n  transports: ['websocket'],\n  forceNew: true\n})\nconst client = feathers()\n\nclient.configure(socketio(socket))\nclient.configure(\n  authentication({\n    storage: AsyncStorage\n  })\n)\n\nconst messageService = client.service('messages')\n\nmessageService.on('created', (message: Message) => console.log('Created a message', message))\n\n// Use the messages service from the server\nmessageService.create({\n  text: 'Message from client'\n})\n```\n\nSince React Native for Android doesn't handle timeouts exceeding one minute, consider setting lower values for `pingInterval` and `pingTimeout` of [Socket.io](./socketio) **on your server**. This will stop warnings related to this [issue](https://github.com/facebook/react-native/issues/12981). For example:\n\n```js\nimport socketio from '@feathersjs/socketio'\n\nconst app = feathers()\n\napp.configure(\n  socketio({\n    pingInterval: 10000,\n    pingTimeout: 50000\n  })\n)\n```\n\n## Module loaders\n\nFeathers client libraries work with the out-of-the-box configuration of all modern module loaders like Webpack, Parcel, Vite etc.\n\n### Webpack\n\nNo additional setup should be necessary to use the Feathers client modules in a standard configuration with Webpack.\n\n### create-react-app\n\n[create-react-app](https://github.com/facebookincubator/create-react-app) uses [Webpack](#webpack) and also no longer requires additional setup to load the individual Feathers client modules.\n\n### Others\n\nFor non-CommonJS formats (like AMD) version of Feathers and its client modules the [@feathersjs/client module](#feathers-client) can be used.\n\n## @feathersjs/client\n\n::badges{npm=\"@feathersjs/client\" changelog=\"https://github.com/feathersjs/feathers/blob/dove/packages/client/CHANGELOG.md\"}\n::\n\n```\nnpm install @feathersjs/client --save\n```\n\n`@feathersjs/client` is a module that bundles the separate Feathers client-side modules into one file which can be loaded directly in the browser through a `<script>` tag and in most other JavaScript runtimes.\n\n<BlockQuote type=\"danger\">\nIf you are using a module loader like Webpack, Parcel etc., create-react-app and in React Native and Node you **should not use** `@feathersjs/client`. Use the individual client modules instead. This will give you the most modern builds and reduce bundle size and build/load time. See the [REST client](./client/rest) and [Socket.io client](./client/socketio) chapters for invidual module use.\n</BlockQuote>\n\nHere is a table of which Feathers client module is included:\n\n| Feathers module                   | @feathersjs/client      |\n| --------------------------------- | ----------------------- |\n| @feathersjs/feathers              | feathers (default)      |\n| @feathersjs/errors                | feathers.errors         |\n| @feathersjs/rest-client           | feathers.rest           |\n| @feathersjs/socketio-client       | feathers.socketio       |\n| @feathersjs/authentication-client | feathers.authentication |\n\nWhen you are loading `@feathersjs/client` you do not have to install or load any of the other modules listed in the table above.\n\n### When to use\n\n`@feathersjs/client` can be used directly in the browser using a `<script>` tag without a module loader as well as module loaders that do not support CommonJS (like RequireJS).\n\n### Load from CDN with `<script>`\n\nBelow is an example of the scripts you would use to load `@feathersjs/client` from [unpkg.com](https://unpkg.com).\n\n```html\n<script src=\"//unpkg.com/@feathersjs/client@^5.0.0/dist/feathers.js\"></script>\n<script src=\"//unpkg.com/socket.io-client@^4.0.0/dist/socket.io.js\"></script>\n<script>\n  // Socket.io is exposed as the `io` global.\n  const socket = io('http://localhost:3030')\n  // @feathersjs/client is exposed as the `feathers` global.\n  const app = feathers()\n\n  app.configure(feathers.socketio(socket))\n  app.configure(feathers.authentication())\n\n  app.service('messages').create({\n    text: 'A new message'\n  })\n\n  // feathers.errors is an object with all of the custom error types.\n</script>\n```",
    "rawContent": "## Typed client\n\nA Feathers application generated with Feathers v5 or later now exports a client file, including the types you defined in [schemas](./schema/index) on the server. For more information see the [CLI guide](../guides/cli/client)\n\n## Node\n\nTo connect to a Feathers server in NodeJS, install the desired client connection library (here, `socket.io-client`), alongside the Feathers core library, and the connection-specific library:\n\n```\nnpm install @feathersjs/feathers @feathersjs/socketio-client socket.io-client --save\n```\n\nThen initialize like this:\n\n```ts\nimport io from 'socket.io-client'\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\n\nconst socket = io('http://api.my-feathers-server.com')\nconst client = feathers()\n\nclient.configure(socketio(socket))\n\nconst messageService = client.service('messages')\n\nmessageService.on('created', (message: Message) => console.log('Created a message', message))\n\n// Use the messages service from the server\nmessageService.create({\n  text: 'Message from client'\n})\n```\n\n## React Native\n\nReact Native usage is the same as for the [Node client](#node). Install the required packages into your [React Native](https://facebook.github.io/react-native/) project.\n\n```bash\nnpm install @feathersjs/feathers @feathersjs/socketio-client socket.io-client\n```\n\nThen in the main application file:\n\n```ts\nimport io from 'socket.io-client'\nimport { AsyncStorage } from 'react-native'\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport authentication from '@feathersjs/authentication-client'\n\nconst socket = io('http://api.my-feathers-server.com', {\n  transports: ['websocket'],\n  forceNew: true\n})\nconst client = feathers()\n\nclient.configure(socketio(socket))\nclient.configure(\n  authentication({\n    storage: AsyncStorage\n  })\n)\n\nconst messageService = client.service('messages')\n\nmessageService.on('created', (message: Message) => console.log('Created a message', message))\n\n// Use the messages service from the server\nmessageService.create({\n  text: 'Message from client'\n})\n```\n\nSince React Native for Android doesn't handle timeouts exceeding one minute, consider setting lower values for `pingInterval` and `pingTimeout` of [Socket.io](./socketio) **on your server**. This will stop warnings related to this [issue](https://github.com/facebook/react-native/issues/12981). For example:\n\n```js\nimport socketio from '@feathersjs/socketio'\n\nconst app = feathers()\n\napp.configure(\n  socketio({\n    pingInterval: 10000,\n    pingTimeout: 50000\n  })\n)\n```\n\n## Module loaders\n\nFeathers client libraries work with the out-of-the-box configuration of all modern module loaders like Webpack, Parcel, Vite etc.\n\n### Webpack\n\nNo additional setup should be necessary to use the Feathers client modules in a standard configuration with Webpack.\n\n### create-react-app\n\n[create-react-app](https://github.com/facebookincubator/create-react-app) uses [Webpack](#webpack) and also no longer requires additional setup to load the individual Feathers client modules.\n\n### Others\n\nFor non-CommonJS formats (like AMD) version of Feathers and its client modules the [@feathersjs/client module](#feathers-client) can be used.\n\n## @feathersjs/client\n\n::badges{npm=\"@feathersjs/client\" changelog=\"https://github.com/feathersjs/feathers/blob/dove/packages/client/CHANGELOG.md\"}\n::\n\n```\nnpm install @feathersjs/client --save\n```\n\n`@feathersjs/client` is a module that bundles the separate Feathers client-side modules into one file which can be loaded directly in the browser through a `<script>` tag and in most other JavaScript runtimes.\n\n<BlockQuote type=\"danger\">\nIf you are using a module loader like Webpack, Parcel etc., create-react-app and in React Native and Node you **should not use** `@feathersjs/client`. Use the individual client modules instead. This will give you the most modern builds and reduce bundle size and build/load time. See the [REST client](./client/rest) and [Socket.io client](./client/socketio) chapters for invidual module use.\n</BlockQuote>\n\nHere is a table of which Feathers client module is included:\n\n| Feathers module                   | @feathersjs/client      |\n| --------------------------------- | ----------------------- |\n| @feathersjs/feathers              | feathers (default)      |\n| @feathersjs/errors                | feathers.errors         |\n| @feathersjs/rest-client           | feathers.rest           |\n| @feathersjs/socketio-client       | feathers.socketio       |\n| @feathersjs/authentication-client | feathers.authentication |\n\nWhen you are loading `@feathersjs/client` you do not have to install or load any of the other modules listed in the table above.\n\n### When to use\n\n`@feathersjs/client` can be used directly in the browser using a `<script>` tag without a module loader as well as module loaders that do not support CommonJS (like RequireJS).\n\n### Load from CDN with `<script>`\n\nBelow is an example of the scripts you would use to load `@feathersjs/client` from [unpkg.com](https://unpkg.com).\n\n```html\n<script src=\"//unpkg.com/@feathersjs/client@^5.0.0/dist/feathers.js\"></script>\n<script src=\"//unpkg.com/socket.io-client@^4.0.0/dist/socket.io.js\"></script>\n<script>\n  // Socket.io is exposed as the `io` global.\n  const socket = io('http://localhost:3030')\n  // @feathersjs/client is exposed as the `feathers` global.\n  const app = feathers()\n\n  app.configure(feathers.socketio(socket))\n  app.configure(feathers.authentication())\n\n  app.service('messages').create({\n    text: 'A new message'\n  })\n\n  // feathers.errors is an object with all of the custom error types.\n</script>\n```",
    "breadcrumb": "Feathers Client",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/client.md",
    "heading": "Feathers Client",
    "subHeadings": [
      "Typed client",
      "Node",
      "React Native",
      "Module loaders",
      "Webpack",
      "create-react-app",
      "Others",
      "@feathersjs/client",
      "When to use",
      "Load from CDN with `<script>`"
    ],
    "hasCode": true,
    "codeLanguages": [
      "text",
      "ts",
      "bash",
      "js",
      "html"
    ],
    "tokens": 1419,
    "category": "api",
    "tags": [
      "authentication",
      "schema",
      "rest",
      "create",
      "feathers client",
      "socket.io",
      "setup",
      "application"
    ]
  },
  {
    "id": "v6-cloudflare-0",
    "content": "# Cloudflare\nBreadcrumb: Cloudflare\nCovers: Setup | With Durable Objects | Environment Variables\nTopics: services, context, params, find, get, create, middleware, setup\n\n## Setup\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\n\nexport default {\n  fetch: handler\n}\n```\n\nThe `createHandler` returns a function with the signature `(request: Request) => Promise<Response>` which is the Web Standard used by Cloudflare Workers.\n\n## With Durable Objects\n\nCloudflare Workers can use Durable Objects for stateful services:\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nexport class MessagesDurableObject {\n  constructor(state, env) {\n    this.state = state\n    this.messages = []\n  }\n\n  async fetch(request) {\n    const app = feathers()\n\n    app.use('messages', {\n      messages: this.messages,\n\n      async find() {\n        return this.messages\n      },\n\n      async create(data) {\n        const message = { id: this.messages.length, ...data }\n        this.messages.push(message)\n        return message\n      }\n    })\n\n    const handler = createHandler(app)\n    return handler(request)\n  }\n}\n\nexport default {\n  async fetch(request, env) {\n    const id = env.MESSAGES.idFromName('default')\n    const obj = env.MESSAGES.get(id)\n    return obj.fetch(request)\n  }\n}\n```\n\n## Environment Variables\n\nAccess Cloudflare Workers environment variables through the request context:\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler, errorHandler, queryParser, bodyParser } from 'feathers/http'\n\nconst app = feathers()\n\n// Middleware to inject env into params\nconst envMiddleware = (env) => async (context, next) => {\n  context.params.env = env\n  await next()\n}\n\napp.use('messages', {\n  async find(params) {\n    const apiKey = params.env.API_KEY\n    // Use environment variables\n    return []\n  }\n})\n\nexport default {\n  fetch(request, env) {\n    const handler = createHandler(app, [\n      errorHandler(),\n      envMiddleware(env),\n      queryParser(),\n      bodyParser()\n    ])\n    return handler(request)\n  }\n}\n```",
    "rawContent": "## Setup\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\n\nexport default {\n  fetch: handler\n}\n```\n\nThe `createHandler` returns a function with the signature `(request: Request) => Promise<Response>` which is the Web Standard used by Cloudflare Workers.\n\n## With Durable Objects\n\nCloudflare Workers can use Durable Objects for stateful services:\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nexport class MessagesDurableObject {\n  constructor(state, env) {\n    this.state = state\n    this.messages = []\n  }\n\n  async fetch(request) {\n    const app = feathers()\n\n    app.use('messages', {\n      messages: this.messages,\n\n      async find() {\n        return this.messages\n      },\n\n      async create(data) {\n        const message = { id: this.messages.length, ...data }\n        this.messages.push(message)\n        return message\n      }\n    })\n\n    const handler = createHandler(app)\n    return handler(request)\n  }\n}\n\nexport default {\n  async fetch(request, env) {\n    const id = env.MESSAGES.idFromName('default')\n    const obj = env.MESSAGES.get(id)\n    return obj.fetch(request)\n  }\n}\n```\n\n## Environment Variables\n\nAccess Cloudflare Workers environment variables through the request context:\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler, errorHandler, queryParser, bodyParser } from 'feathers/http'\n\nconst app = feathers()\n\n// Middleware to inject env into params\nconst envMiddleware = (env) => async (context, next) => {\n  context.params.env = env\n  await next()\n}\n\napp.use('messages', {\n  async find(params) {\n    const apiKey = params.env.API_KEY\n    // Use environment variables\n    return []\n  }\n})\n\nexport default {\n  fetch(request, env) {\n    const handler = createHandler(app, [\n      errorHandler(),\n      envMiddleware(env),\n      queryParser(),\n      bodyParser()\n    ])\n    return handler(request)\n  }\n}\n```",
    "breadcrumb": "Cloudflare",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/cloudflare.md",
    "heading": "Cloudflare",
    "subHeadings": [
      "Setup",
      "With Durable Objects",
      "Environment Variables"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 520,
    "category": "api",
    "tags": [
      "services",
      "context",
      "params",
      "find",
      "get",
      "create",
      "middleware",
      "setup"
    ]
  },
  {
    "id": "v6-deno-0",
    "content": "# Deno\nBreadcrumb: Deno\nCovers: Setup | With Socket.io\nTopics: real-time, find, create, socket.io, setup\n\n## Setup\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\n\nDeno.serve({ port: 3030 }, handler)\n```\n\nThe `createHandler` returns a function with the signature `(request: Request) => Promise<Response>` which is the Web Standard used natively by Deno.\n\n## With Socket.io\n\nTo use real-time functionality with Socket.io in Deno:\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\nimport { Server } from 'socket.io'\nimport { socketio } from 'feathers/socketio'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\napp.configure(socketio())\n\nconst handler = createHandler(app)\nconst server = Deno.serve({ port: 3030 }, handler)\n\nawait app.setup(server)\n```",
    "rawContent": "## Setup\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\n\nDeno.serve({ port: 3030 }, handler)\n```\n\nThe `createHandler` returns a function with the signature `(request: Request) => Promise<Response>` which is the Web Standard used natively by Deno.\n\n## With Socket.io\n\nTo use real-time functionality with Socket.io in Deno:\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\nimport { Server } from 'socket.io'\nimport { socketio } from 'feathers/socketio'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\napp.configure(socketio())\n\nconst handler = createHandler(app)\nconst server = Deno.serve({ port: 3030 }, handler)\n\nawait app.setup(server)\n```",
    "breadcrumb": "Deno",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/deno.md",
    "heading": "Deno",
    "subHeadings": [
      "Setup",
      "With Socket.io"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 236,
    "category": "api",
    "tags": [
      "real-time",
      "find",
      "create",
      "socket.io",
      "setup"
    ]
  },
  {
    "id": "v6-errors-0",
    "content": "# Errors\nBreadcrumb: Errors\nCovers: Examples | Feathers errors | Custom errors | Error Handling\nTopics: hooks, validation, database, adapter, rest, get, create, error hooks, error handling, middleware, application\n\n## Examples\n\nHere are a few ways that you can use them:\n\n```ts\nimport { NotFound, GeneralError, BadRequest } from '@feathersjs/errors'\n\n// If you were to create an error yourself.\nconst notFound = new NotFound('User does not exist')\n\n// You can wrap existing errors\nconst existing = new GeneralError(new Error('I exist'))\n\n// You can also pass additional data\nconst data = new BadRequest('Invalid email', {\n  email: 'sergey@google.com'\n})\n\n// You can also pass additional data without a message\nconst dataWithoutMessage = new BadRequest({\n  email: 'sergey@google.com'\n})\n\n// If you need to pass multiple errors\nconst validationErrors = new BadRequest('Invalid Parameters', {\n  errors: { email: 'Email already taken' }\n})\n\n// You can also omit the error message and we'll put in a default one for you\nconst validationErrors = new BadRequest({\n  errors: {\n    email: 'Invalid Email'\n  }\n})\n```\n\n## Feathers errors\n\nThe following error types, all of which are instances of `FeathersError`, are available:\n\n- 400: `BadRequest`\n- 401: `NotAuthenticated`\n- 402: `PaymentError`\n- 403: `Forbidden`\n- 404: `NotFound`\n- 405: `MethodNotAllowed`\n- 406: `NotAcceptable`\n- 408: `Timeout`\n- 409: `Conflict`\n- 411: `LengthRequired`\n- 422: `Unprocessable`\n- 429: `TooManyRequests`\n- 500: `GeneralError`\n- 501: `NotImplemented`\n- 502: `BadGateway`\n- 503: `Unavailable`\n\n<BlockQuote type=\"tip\">\nAll of the Feathers core modules and most plugins and database adapters automatically emit the appropriate Feathers errors for you. For example, most of the database adapters will already send `Conflict` or `Unprocessable` errors on validation errors.\n</BlockQuote>\n\nFeathers errors contain the following fields:\n\n- `name` - The error name (e.g. \"BadRequest\", \"ValidationError\", etc.)\n- `message` - The error message string\n- `code` - The HTTP status code\n- `className` - A CSS class name that can be handy for styling errors based on the error type. (e.g. \"bad-request\" , etc.)\n- `data` - An object containing anything you passed to a Feathers error except for the `errors` object and `message`.\n- `errors` - An object containing whatever was passed to a Feathers error inside `errors`. This is typically validation errors or if you want to group multiple errors together.\n\n<BlockQuote type=\"warning\">\nTo convert a Feathers error back to an object call `error.toJSON()`. A normal `console.log` of a JavaScript Error object will not automatically show those additional properties described above (even though they can be accessed directly).\n</BlockQuote>\n\n## Custom errors\n\nYou can create custom errors by extending from the `FeathersError` class and calling its constructor with `(message, name, code, className, data)`:\n\n- `message` - The error message\n- `name` - The error name (e.g. `MyError`)\n- `code` - An [HTTP error code](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)\n- `className` - The full name of the error class (e.g. `my-error`)\n- `data` - Additional data to include in the error\n\n```ts\nimport { FeathersError } from '@feathersjs/errors'\n\nclass UnsupportedMediaType extends FeathersError {\n  constructor(message: string, data: any) {\n    super(message, 'UnsupportedMediaType', 415, 'unsupported-media-type', data)\n  }\n}\n\nconst error = new UnsupportedMediaType('Not supported')\n\nconsole.log(error.toJSON())\n```\n\n## Error Handling\n\nIt is important to make sure that errors get cleaned up before they go back to the client. [Express error handling middleware](https://docs.feathersjs.com/api/express.html#expresserrorhandler) works only for REST calls. If you want to make sure that ws errors are handled as well, you need to use [application error hooks](hooks#application-hooks) which are called on any service call error.\n\nHere is an example error handler you can add to app.hooks errors.\n\n```js\nconst errors = require('@feathersjs/errors')\nconst errorHandler = (ctx) => {\n  if (ctx.error) {\n    const error = ctx.error\n    if (!error.code) {\n      const newError = new errors.GeneralError('server error')\n      ctx.error = newError\n      return ctx\n    }\n    if (error.code === 404 || process.env.NODE_ENV === 'production') {\n      error.stack = null\n    }\n    return ctx\n  }\n}\n```\n\nthen add it as an [application level](./application#hooks-hooks) error hook\n\n```ts\napp.hooks({\n  //...\n  error: {\n    all: [errorHandler]\n  }\n})\n```",
    "rawContent": "## Examples\n\nHere are a few ways that you can use them:\n\n```ts\nimport { NotFound, GeneralError, BadRequest } from '@feathersjs/errors'\n\n// If you were to create an error yourself.\nconst notFound = new NotFound('User does not exist')\n\n// You can wrap existing errors\nconst existing = new GeneralError(new Error('I exist'))\n\n// You can also pass additional data\nconst data = new BadRequest('Invalid email', {\n  email: 'sergey@google.com'\n})\n\n// You can also pass additional data without a message\nconst dataWithoutMessage = new BadRequest({\n  email: 'sergey@google.com'\n})\n\n// If you need to pass multiple errors\nconst validationErrors = new BadRequest('Invalid Parameters', {\n  errors: { email: 'Email already taken' }\n})\n\n// You can also omit the error message and we'll put in a default one for you\nconst validationErrors = new BadRequest({\n  errors: {\n    email: 'Invalid Email'\n  }\n})\n```\n\n## Feathers errors\n\nThe following error types, all of which are instances of `FeathersError`, are available:\n\n- 400: `BadRequest`\n- 401: `NotAuthenticated`\n- 402: `PaymentError`\n- 403: `Forbidden`\n- 404: `NotFound`\n- 405: `MethodNotAllowed`\n- 406: `NotAcceptable`\n- 408: `Timeout`\n- 409: `Conflict`\n- 411: `LengthRequired`\n- 422: `Unprocessable`\n- 429: `TooManyRequests`\n- 500: `GeneralError`\n- 501: `NotImplemented`\n- 502: `BadGateway`\n- 503: `Unavailable`\n\n<BlockQuote type=\"tip\">\nAll of the Feathers core modules and most plugins and database adapters automatically emit the appropriate Feathers errors for you. For example, most of the database adapters will already send `Conflict` or `Unprocessable` errors on validation errors.\n</BlockQuote>\n\nFeathers errors contain the following fields:\n\n- `name` - The error name (e.g. \"BadRequest\", \"ValidationError\", etc.)\n- `message` - The error message string\n- `code` - The HTTP status code\n- `className` - A CSS class name that can be handy for styling errors based on the error type. (e.g. \"bad-request\" , etc.)\n- `data` - An object containing anything you passed to a Feathers error except for the `errors` object and `message`.\n- `errors` - An object containing whatever was passed to a Feathers error inside `errors`. This is typically validation errors or if you want to group multiple errors together.\n\n<BlockQuote type=\"warning\">\nTo convert a Feathers error back to an object call `error.toJSON()`. A normal `console.log` of a JavaScript Error object will not automatically show those additional properties described above (even though they can be accessed directly).\n</BlockQuote>\n\n## Custom errors\n\nYou can create custom errors by extending from the `FeathersError` class and calling its constructor with `(message, name, code, className, data)`:\n\n- `message` - The error message\n- `name` - The error name (e.g. `MyError`)\n- `code` - An [HTTP error code](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)\n- `className` - The full name of the error class (e.g. `my-error`)\n- `data` - Additional data to include in the error\n\n```ts\nimport { FeathersError } from '@feathersjs/errors'\n\nclass UnsupportedMediaType extends FeathersError {\n  constructor(message: string, data: any) {\n    super(message, 'UnsupportedMediaType', 415, 'unsupported-media-type', data)\n  }\n}\n\nconst error = new UnsupportedMediaType('Not supported')\n\nconsole.log(error.toJSON())\n```\n\n## Error Handling\n\nIt is important to make sure that errors get cleaned up before they go back to the client. [Express error handling middleware](https://docs.feathersjs.com/api/express.html#expresserrorhandler) works only for REST calls. If you want to make sure that ws errors are handled as well, you need to use [application error hooks](hooks#application-hooks) which are called on any service call error.\n\nHere is an example error handler you can add to app.hooks errors.\n\n```js\nconst errors = require('@feathersjs/errors')\nconst errorHandler = (ctx) => {\n  if (ctx.error) {\n    const error = ctx.error\n    if (!error.code) {\n      const newError = new errors.GeneralError('server error')\n      ctx.error = newError\n      return ctx\n    }\n    if (error.code === 404 || process.env.NODE_ENV === 'production') {\n      error.stack = null\n    }\n    return ctx\n  }\n}\n```\n\nthen add it as an [application level](./application#hooks-hooks) error hook\n\n```ts\napp.hooks({\n  //...\n  error: {\n    all: [errorHandler]\n  }\n})\n```",
    "breadcrumb": "Errors",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/errors.md",
    "heading": "Errors",
    "subHeadings": [
      "Examples",
      "Feathers errors",
      "Custom errors",
      "Error Handling"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text",
      "js"
    ],
    "tokens": 1084,
    "category": "api",
    "tags": [
      "hooks",
      "validation",
      "database",
      "adapter",
      "rest",
      "get",
      "create",
      "error hooks",
      "error handling",
      "middleware",
      "application"
    ]
  },
  {
    "id": "v6-events-0",
    "content": "# Events\nBreadcrumb: Events\nCovers: EventEmitters | Service Events | created | updated, patched | removed | Custom events\nTopics: hooks, services, context, params, real-time, channels, events, get, create, update, patch, remove, hook context, feathers client, socket.io, application\n\n## EventEmitters\n\nOnce registered, any [service](./services) gets turned into a standard [NodeJS EventEmitter](https://nodejs.org/api/events.html) and can be used accordingly.\n\n```ts\nconst messages = app.service('messages')\n\n// Listen to a normal service event\nmessages.on('patched', (message: Message) => console.log('message patched', message))\n\n// Only listen to an event once\nmesssages.once('removed', (message: Message) => console.log('First time a message has been removed', message))\n\n// A reference to a handler\nconst onCreatedListener = (message: Message) => console.log('New message created', message)\n\n// Listen `created` with a handler reference\nmessages.on('created', onCreatedListener)\n\n// Unbind the `created` event listener\nmessages.removeListener('created', onCreatedListener)\n\n// Send a custom event\nmessages.emit('customEvent', {\n  anything: 'Data can be anything'\n})\n```\n\n## Service Events\n\nAny service automatically emits `created`, `updated`, `patched` and `removed` events when the respective service method returns successfully. This works on the client as well as on the server. Events are not fired until all [hooks](./hooks) have executed. When the client is using [Socket.io](socketio), events will be pushed automatically from the server to all connected clients. This is how Feathers does real-time.\n\n<BlockQuote type=\"tip\">\nTo disable sending of events e.g. when updating a large amount of data, set [context.event](./hooks#context-event) to `null` in a hook.\n</BlockQuote>\n\nAdditionally to the event `data`, all events also get the [hook context](./hooks) from their method call passed as the second parameter.\n\n### created\n\nThe `created` event will fire with the result data when a service `create` returns successfully.\n\n```ts\nimport { feathers, type Params, type HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async create(data: Message) {\n    return data\n  }\n}\n\nconst app = feathers<{ messages: MessageService }>()\n\napp.use('messages', new MessageService())\n\n// Retrieve the wrapped service object which is also an EventEmitter\nconst messages = app.service('messages')\n\nmessages.on('created', (message: Message, contexHookContext) => console.log('created', message))\n\nmessages.create({\n  text: 'We have to do something!'\n})\n```\n\n### updated, patched\n\nThe `updated` and `patched` events will fire with the callback data when a service `update` or `patch` method calls back successfully.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Id, Params, HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async update(id: Id, data: Message) {\n    return data\n  }\n\n  async patch(id: Id, data: Message) {\n    return data\n  }\n}\n\nconst app = feathers<{ messages: MessageService }>()\n\napp.use('messages', new MessageService())\n\nconst messages = app.service('my/messages')\n\nmessages.on('updated', (message: Message, context: HookContext) => console.log('updated', message))\nmessages.on('patched', (message: Message) => console.log('patched', message))\n\nmessages.update(0, {\n  text: 'updated message'\n})\n\nmessages.patch(0, {\n  text: 'patched message'\n})\n```\n\n### removed\n\nThe `removed` event will fire with the callback data when a service `remove` calls back successfully.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Id, Params, HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async remove(id: Id, params: Params) {\n    return { id }\n  }\n}\n\nconst app = feathers<{ messages: MessageService }>()\n\napp.use('messages', new MessageService())\n\nconst messages = app.service('messages')\n\nmessages.on('removed', (message: Message, context: HookContext) => console.log('removed', message))\nmessages.remove(1)\n```\n\n## Custom events\n\nBy default, real-time clients will only receive the [standard events](#service-events). However, it is possible to define a list of custom events that should also be sent to the client when registering the service with [app.use](./application##use-path-service-options), when `service.emit('customevent', data)` is called on the server. The `context` for custom events won't be a full hook context but just an object containing `{ app, service, path, result }`.\n\n<BlockQuote type=\"warning\">\nCustom events can only be sent from the server to the client, not the other way (client to server). A [custom service](./services) should be used for those cases.\n</BlockQuote>\n\nFor example, a payment service that sends status events to the client while processing a payment could look like this:\n\n```ts\nclass PaymentService {\n  async create(data: any, params: Params) {\n    const customer = await createStripeCustomer(params.user)\n    this.emit('status', { status: 'created' })\n\n    const payment = await createPayment(data)\n    this.emit('status', { status: 'completed' })\n\n    return payment\n  }\n}\n\n// Then register it like this:\napp.use('payments', new PaymentService(), {\n  events: ['status']\n})\n```\n\nUsing `service.emit` custom events can also be sent in a hook:\n\n```js\napp.service('payments').hooks({\n  after: {\n    create(context: HookContext) {\n      context.service.emit('status', { status: 'completed' })\n    }\n  }\n})\n```\n\nCustom events can be [published through channels](./channels#publishing) just like standard events and listened to it in a [Feathers client](./client) or [directly on the socket connection](./client/socketio#listening-to-events):\n\n```js\nclient.service('payments').on('status', (data) => {})\n\n// or\nsocket.on('payments status', (data) => {})\n```",
    "rawContent": "## EventEmitters\n\nOnce registered, any [service](./services) gets turned into a standard [NodeJS EventEmitter](https://nodejs.org/api/events.html) and can be used accordingly.\n\n```ts\nconst messages = app.service('messages')\n\n// Listen to a normal service event\nmessages.on('patched', (message: Message) => console.log('message patched', message))\n\n// Only listen to an event once\nmesssages.once('removed', (message: Message) => console.log('First time a message has been removed', message))\n\n// A reference to a handler\nconst onCreatedListener = (message: Message) => console.log('New message created', message)\n\n// Listen `created` with a handler reference\nmessages.on('created', onCreatedListener)\n\n// Unbind the `created` event listener\nmessages.removeListener('created', onCreatedListener)\n\n// Send a custom event\nmessages.emit('customEvent', {\n  anything: 'Data can be anything'\n})\n```\n\n## Service Events\n\nAny service automatically emits `created`, `updated`, `patched` and `removed` events when the respective service method returns successfully. This works on the client as well as on the server. Events are not fired until all [hooks](./hooks) have executed. When the client is using [Socket.io](socketio), events will be pushed automatically from the server to all connected clients. This is how Feathers does real-time.\n\n<BlockQuote type=\"tip\">\nTo disable sending of events e.g. when updating a large amount of data, set [context.event](./hooks#context-event) to `null` in a hook.\n</BlockQuote>\n\nAdditionally to the event `data`, all events also get the [hook context](./hooks) from their method call passed as the second parameter.\n\n### created\n\nThe `created` event will fire with the result data when a service `create` returns successfully.\n\n```ts\nimport { feathers, type Params, type HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async create(data: Message) {\n    return data\n  }\n}\n\nconst app = feathers<{ messages: MessageService }>()\n\napp.use('messages', new MessageService())\n\n// Retrieve the wrapped service object which is also an EventEmitter\nconst messages = app.service('messages')\n\nmessages.on('created', (message: Message, contexHookContext) => console.log('created', message))\n\nmessages.create({\n  text: 'We have to do something!'\n})\n```\n\n### updated, patched\n\nThe `updated` and `patched` events will fire with the callback data when a service `update` or `patch` method calls back successfully.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Id, Params, HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async update(id: Id, data: Message) {\n    return data\n  }\n\n  async patch(id: Id, data: Message) {\n    return data\n  }\n}\n\nconst app = feathers<{ messages: MessageService }>()\n\napp.use('messages', new MessageService())\n\nconst messages = app.service('my/messages')\n\nmessages.on('updated', (message: Message, context: HookContext) => console.log('updated', message))\nmessages.on('patched', (message: Message) => console.log('patched', message))\n\nmessages.update(0, {\n  text: 'updated message'\n})\n\nmessages.patch(0, {\n  text: 'patched message'\n})\n```\n\n### removed\n\nThe `removed` event will fire with the callback data when a service `remove` calls back successfully.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Id, Params, HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async remove(id: Id, params: Params) {\n    return { id }\n  }\n}\n\nconst app = feathers<{ messages: MessageService }>()\n\napp.use('messages', new MessageService())\n\nconst messages = app.service('messages')\n\nmessages.on('removed', (message: Message, context: HookContext) => console.log('removed', message))\nmessages.remove(1)\n```\n\n## Custom events\n\nBy default, real-time clients will only receive the [standard events](#service-events). However, it is possible to define a list of custom events that should also be sent to the client when registering the service with [app.use](./application##use-path-service-options), when `service.emit('customevent', data)` is called on the server. The `context` for custom events won't be a full hook context but just an object containing `{ app, service, path, result }`.\n\n<BlockQuote type=\"warning\">\nCustom events can only be sent from the server to the client, not the other way (client to server). A [custom service](./services) should be used for those cases.\n</BlockQuote>\n\nFor example, a payment service that sends status events to the client while processing a payment could look like this:\n\n```ts\nclass PaymentService {\n  async create(data: any, params: Params) {\n    const customer = await createStripeCustomer(params.user)\n    this.emit('status', { status: 'created' })\n\n    const payment = await createPayment(data)\n    this.emit('status', { status: 'completed' })\n\n    return payment\n  }\n}\n\n// Then register it like this:\napp.use('payments', new PaymentService(), {\n  events: ['status']\n})\n```\n\nUsing `service.emit` custom events can also be sent in a hook:\n\n```js\napp.service('payments').hooks({\n  after: {\n    create(context: HookContext) {\n      context.service.emit('status', { status: 'completed' })\n    }\n  }\n})\n```\n\nCustom events can be [published through channels](./channels#publishing) just like standard events and listened to it in a [Feathers client](./client) or [directly on the socket connection](./client/socketio#listening-to-events):\n\n```js\nclient.service('payments').on('status', (data) => {})\n\n// or\nsocket.on('payments status', (data) => {})\n```",
    "breadcrumb": "Events",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/events.md",
    "heading": "Events",
    "subHeadings": [
      "EventEmitters",
      "Service Events",
      "created",
      "updated, patched",
      "removed",
      "Custom events"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text",
      "js"
    ],
    "tokens": 1404,
    "category": "api",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "real-time",
      "channels",
      "events",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "hook context",
      "feathers client",
      "socket.io",
      "application"
    ]
  },
  {
    "id": "v6-hooks-0",
    "content": "# Hooks\nBreadcrumb: Hooks\nCovers: Quick Example | Hook functions | before, after and error | around | Hook flow | Throwing an error | Setting `context.result` | Hook context | `context.app` | `context.service` | `context.path` | `context.method` | `context.type` | `context.params` | `context.id` | `context.data` | `context.error` | `context.result` | `context.dispatch` | `context.http` | `context.event` | `context.toJSON()` | Registering hooks | Application hooks | Service hooks | Setup and teardown\nTopics: hooks, services, context, params, authentication, schema, resolver, validation, database, mongodb, real-time, events, rest, find, get, create, update, patch, remove, around hooks, error hooks, hook context, hook functions, custom methods, socket.io, setup, teardown, application\n\n## Quick Example\n\nThe following example logs the runtime of any service method on the `messages` service and adds `createdAt` property before saving the data to the database:\n\n```ts\nimport { feathers, type HookContext, type NextFunction } from '@feathersjs/feathers'\n\nconst app = feathers()\n\napp.service('messages').hooks({\n  around: {\n    all: [\n      // A hook that wraps around all other hooks and the service method\n      // logging the total runtime of a successful call\n      async (context: HookContext, next: NextFunction) => {\n        const startTime = Date.now()\n\n        await next()\n\n        console.log(`Method ${context.method} on ${context.path} took ${Date.now() - startTime}ms`)\n      }\n    ]\n  },\n  before: {\n    create: [\n      async (context: HookContext) => {\n        context.data = {\n          ...context.data,\n          createdAt: Date.now()\n        }\n      }\n    ]\n  }\n})\n```\n\n<BlockQuote type=\"note\">\nWhile it is always possible to add properties like `createdAt` in the above example via hooks, the preferred way to make data modifications like this in Feathers 5 is via [schemas and resolvers](./schema/index).\n</BlockQuote>\n\n## Hook functions\n\n\n\n### before, after and error\n\n`before`, `after` and `error` hook functions are functions that are `async` or return a promise and take the [hook context](#hook-context) as the parameter and return nothing or throw an error.\n\n```ts\nimport { HookContext } from '../declarations'\n\nexport const hookFunction = async (context: HookContext) => {\n  // Do things here\n}\n```\n\nFor more information see the [hook flow](#hook-flow) section.\n\n### around\n\n`around` hooks are a special kind of hook that allow to control the entire `before`, `after` and `error` flow in a single function. They are a Feathers specific version of the generic [@feathersjs/hooks](https://github.com/feathersjs/hooks). An `around` hook is an `async` function that accepts two arguments:\n\n- The [hook context](#hook-context)\n- An asynchronous `next` function. Somewhere in the body of the hook function, there is a call to `await next()`, which calls the `next` hooks OR the original function if all other hooks have run.\n\nIn its simplest form, an around hook looks like this:\n\n```js\nimport { HookContext, NextFunction } from '../declarations'\n\nexport const myAfoundHook = async (context: HookContext, next: NextFunction) => {\n  try {\n    // Code before `await next()` runs before the main function\n    await next()\n    // Code after `await next()` runs after the main function.\n  } catch (error) {\n    // Do things on error\n  } finally {\n    // Do things always\n  }\n}\n```\n\nAny around hook can be wrapped around another function. Calling `await next()` will either call the next hook in the chain or the service method if all other hooks have run.\n\n## Hook flow\n\nIn general, hooks are executed in the order [they are registered](#registering-hooks) with `around` hooks running first:\n\n- `around` hooks (before `await next()`)\n- `before` hooks\n- service method\n- `after` hooks\n- `around` hooks (after `await next()`)\n\nNote that since `around` hooks wrap **around** everything, the first hook to run will be the last to execute its code after `await next()`. This is reverse of the order `after` hooks execute.\n\nThe hook flow can be affected as follows.\n\n### Throwing an error\n\nWhen an error is thrown (or the promise is rejected), all subsequent hooks - and the service method call if it didn't run already - will be skipped and only the error hooks will run.\n\nThe following example throws an error when the text for creating a new message is empty. You can also create very similar hooks to use your Node validation library of choice.\n\n```ts\napp.service('messages').hooks({\n  before: {\n    create: [\n      async (context: HookContext) => {\n        if (context.data.text.trim() === '') {\n          throw new Error('Message text can not be empty')\n        }\n      }\n    ]\n  }\n})\n```\n\n### Setting `context.result`\n\nWhen `context.result` is set in an `around` hook before calling `await next()` or in a `before` hook, the original [service method](./services) call will be skipped. All other hooks will still execute in their normal order. The following example always returns the currently [authenticated user](./authentication/service) instead of the actual user for all `get` method calls:\n\n```js\napp.service('users').hooks({\n  before: {\n    get: [\n      async (context: HookContext) => {\n        // Never call the actual users service\n        // just use the authenticated user\n        context.result = context.params.user\n      }\n    ]\n  }\n})\n```\n\n## Hook context\n\nThe hook `context` is passed to a hook function and contains information about the service method call. It has **read only** properties that should not be modified and **_writeable_** properties that can be changed for subsequent hooks.\n\n<BlockQuote type=\"tip\">\nThe `context` object is the same throughout a service method call so it is possible to add properties and use them in other hooks at a later time.\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nIf you want to inspect the hook context, e.g. via `console.log`, the object returned by [context.toJSON()](#contexttojson) should be used, otherwise you won't see all properties that are available.\n</BlockQuote>\n\n### `context.app`\n\n`context.app` is a _read only_ property that contains the [Feathers application object](./application). This can be used to retrieve other services (via `context.app.service('name')`) or configuration values.\n\n### `context.service`\n\n`context.service` is a _read only_ property and contains the service this hook currently runs on.\n\n### `context.path`\n\n`context.path` is a _read only_ property and contains the service name (or path) without leading or trailing slashes.\n\n### `context.method`\n\n`context.method` is a _read only_ property with the name of the [service method](./services) (`find`, `get`, `create`, `update`, `patch`, `remove`).\n\n### `context.type`\n\n`context.type` is a _read only_ property with the hook type (one of `around`, `before`, `after` or `error`).\n\n### `context.params`\n\n`context.params` is a **writeable** property that contains the [service method](./services) parameters (including `params.query`). For more information see the [service params documentation](./services#params).\n\n### `context.id`\n\n`context.id` is a **writeable** property and the `id` for a `get`, `remove`, `update` and `patch` service method call. For `remove`, `update` and `patch`, `context.id` can also be `null` when modifying multiple entries. In all other cases it will be `undefined`.\n\n### `context.data`\n\n`context.data` is a **writeable** property containing the data of a `create`, `update` and `patch` service method call.\n\n<BlockQuote type=\"note\">\n`context.data` will only be available for `create`, `update`, `patch` and [custom methods](./services#custom-methods).\n</BlockQuote>\n\n#### Working with Streams\n\nWhen using [streaming uploads](./client/rest#streaming-uploads), `context.data` will be a `ReadableStream`. Since streams can only be consumed once, around hooks are the recommended way to work with streaming data. Here are common patterns:\n\n**Passing streams through unchanged:**\n\nIf you only need to validate metadata or check permissions, you can let the stream pass through to the service:\n\n```ts\napp.service('uploads').hooks({\n  around: {\n    create: [\n      async (context: HookContext, next: NextFunction) => {\n        // Validate using headers - don't consume the stream\n        const contentType = context.params.headers?.['content-type']\n        if (!contentType?.startsWith('image/')) {\n          throw new BadRequest('Only images are allowed')\n        }\n\n        // Stream passes through unchanged\n        await next()\n      }\n    ]\n  }\n})\n```\n\n**Wrapping streams with transforms:**\n\nYou can wrap the incoming stream with a transform stream for processing:\n\n```ts\nimport { TransformStream } from 'node:stream/web'\n\napp.service('uploads').hooks({\n  around: {\n    create: [\n      async (context: HookContext, next: NextFunction) => {\n        const originalStream = context.data as ReadableStream\n\n        // Create a transform that tracks bytes\n        let totalBytes = 0\n        const countingTransform = new TransformStream({\n          transform(chunk, controller) {\n            totalBytes += chunk.length\n            controller.enqueue(chunk)\n          }\n        })\n\n        // Replace with transformed stream\n        context.data = originalStream.pipeThrough(countingTransform)\n\n        await next()\n\n        // After service completes, totalBytes is available\n        context.result.size = totalBytes\n      }\n    ]\n  }\n})\n```\n\n<BlockQuote type=\"warning\">\nStreams can only be consumed once. If you need to read the stream content in a hook (e.g., for validation), you must either buffer the entire stream or use a tee/transform approach. For large files, prefer validating metadata from headers rather than consuming the stream.\n</BlockQuote>\n\n### `context.error`\n\n`context.error` is a **writeable** property with the error object that was thrown in a failed method call. It can be modified to change the error that is returned at the end.\n\n<BlockQuote type=\"note\">\n`context.error` will only be available if `context.type` is `error`.\n</BlockQuote>\n\n### `context.result`\n\n`context.result` is a **writeable** property containing the result of the successful service method call. It is only available in `after` hooks. `context.result` can also be set in\n\n- An `around` or `before` hook to skip the actual service method (database) call\n- An `error` hook to swallow the error and return a result instead\n\n<BlockQuote type=\"note\">\n`context.result` will only be available if `context.type` is `after` or if `context.result` has been set.\n</BlockQuote>\n\n### `context.dispatch`\n\n`context.dispatch` is a **writeable, optional** property and contains a \"safe\" version of the data that should be sent to any client. If `context.dispatch` has not been set `context.result` will be sent to the client instead. `context.dispatch` only affects the data sent through a Feathers Transport like [REST](./express) or [Socket.io](./socketio). An internal method call will still get the data set in `context.result`.\n\n<BlockQuote type=\"warning\">\n`context.dispatch` is used by the `schemaHooks.resolveDispatch` [resolver](./schema/resolvers). Use dispatch resolvers whenever possible to get safe representations external data.\n</BlockQuote>\n\n### `context.http`\n\n`context.http` is a **writeable, optional** property that allows customizing HTTP response specific properties. The following properties can be set:\n\n- `context.http.status` - Sets the [HTTP status code](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) that should be returned. Usually the most appropriate status code will be picked automatically but there are cases where it needs to be customized.\n- `context.http.headers` - An object with additional HTTP response headers\n- `context.http.location` - Setting this property will trigger a redirect for HTTP requests.\n\n<BlockQuote type=\"warning\">\nSetting `context.http` properties will have no effect when using a websocket real-time connection.\n</BlockQuote>\n\n### `context.event`\n\n`context.event` is a **writeable, optional** property that allows service events to be skipped by setting it to `null`\n\n### `context.toJSON()`\n\n`context.toJSON()` returns a full object representation of the hook context and all its properties.\n\n## Registering hooks\n\nHook functions are registered on a service through the `app.service(<servicename>).hooks(hooks)` method. The most commonly used registration format is\n\n```js\n{\n  [type]: { // around, before, after or error\n    all: [\n      // list of hooks that should run for every method here\n    ],\n    [methodName]: [\n      // list of method hooks here\n    ]\n  }\n}\n```\n\nThis means usual hook registration looks like this:\n\n```ts\n// The standard all at once way (also used by the generator)\n// an array of functions per service method name (and for `all` methods)\napp.service('servicename').hooks({\n  around: {\n    all: [\n      async (context: HookContext, next: NextFunction) => {\n        console.log('around all hook ran')\n        await next()\n      }\n    ],\n    find: [\n      /* other hook functions here */\n    ],\n    get: [],\n    create: [],\n    update: [],\n    patch: [],\n    remove: [],\n    // Custom methods use hooks as well\n    myCustomMethod: []\n  },\n  before: {\n    all: [async (context: HookContext) => console.log('before all hook ran')],\n    find: [\n      /* other hook functions here */\n    ],\n    get: []\n    // ...etc\n  },\n  after: {\n    find: [async (context: HookContext) => console.log('after find hook ran')]\n  },\n  error: {}\n})\n```\n\n<BlockQuote type=\"warning\">\nHooks will only be available for the standard service methods or methods passed in `options.methods` to [app.use](application#usepath-service--options). See the [documentation for @feathersjs/hooks](https://github.com/feathersjs/hooks) how to use hooks on other methods.\n</BlockQuote>\n\nSince around hooks offer the same functionality as `before`, `after` and `error` hooks at the same time they can also be registered without a nested object:\n\n```ts\nimport { HookContext, NextFunction } from './declarations'\n\n// Passing an array of around hooks that run for every method\napp.service('servicename').hooks([\n  async (context: HookContext, next: NextFunction) => {\n    console.log('around all hook ran')\n    await next()\n  }\n])\n\n// Passing an object with method names and a list of around hooks\napp.service('servicename').hooks({\n  get: [\n    async (context: HookContext, next: NextFunction) => {\n      console.log('around get hook ran')\n      await next()\n    }\n  ],\n  create: [],\n  update: [],\n  patch: [],\n  remove: [],\n  myCustomMethod: []\n})\n```\n\n## Application hooks\n\n\n\n### Service hooks\n\nTo add hooks to every service `app.hooks(hooks)` can be used. Application hooks are [registered in the same format as service hooks](#registering-hooks) and also work exactly the same. Note when application hooks will be executed:\n\n- `around` application hook will run around all other hooks\n- `before` application hooks will always run _before_ all service `before` hooks\n- `after` application hooks will always run _after_ all service `after` hooks\n- `error` application hooks will always run _after_ all service `error` hooks\n\nHere is an example for a very useful application hook that logs every service method error with the service and method name as well as the error stack.\n\n```ts\nimport { HookContext } from './declarations'\n\napp.hooks({\n  error: {\n    all: [\n      async (context: HookContext) => {\n        console.error(`Error in '${context.path}' service method '${context.method}'`, context.error.stack)\n      }\n    ]\n  }\n})\n```\n\n### Setup and teardown\n\nA special kind of application hooks are [app.setup](./application#setupserver) and [app.teardown](./application#teardownserver) hooks. They are around hooks that can be used to initialize database connections etc. and only run once when the application starts or shuts down. Setup and teardown hooks only have `context.app` and `context.server` available in the hook context.\n\n```ts\nimport { MongoClient } from 'mongodb'\n\napp.hooks({\n  setup: [\n    async (context: HookContext, next: NextFunction) => {\n      // E.g. wait for MongoDB connection to complete\n      await context.app.get('mongoClient').connect()\n      await next()\n    }\n  ],\n  teardown: [\n    async (context: HookContext, next: NextFunction) => {\n      // Close MongoDB connection\n      await context.app.get('mongoClient').close()\n      await next()\n    }\n  ]\n})\n```",
    "rawContent": "## Quick Example\n\nThe following example logs the runtime of any service method on the `messages` service and adds `createdAt` property before saving the data to the database:\n\n```ts\nimport { feathers, type HookContext, type NextFunction } from '@feathersjs/feathers'\n\nconst app = feathers()\n\napp.service('messages').hooks({\n  around: {\n    all: [\n      // A hook that wraps around all other hooks and the service method\n      // logging the total runtime of a successful call\n      async (context: HookContext, next: NextFunction) => {\n        const startTime = Date.now()\n\n        await next()\n\n        console.log(`Method ${context.method} on ${context.path} took ${Date.now() - startTime}ms`)\n      }\n    ]\n  },\n  before: {\n    create: [\n      async (context: HookContext) => {\n        context.data = {\n          ...context.data,\n          createdAt: Date.now()\n        }\n      }\n    ]\n  }\n})\n```\n\n<BlockQuote type=\"note\">\nWhile it is always possible to add properties like `createdAt` in the above example via hooks, the preferred way to make data modifications like this in Feathers 5 is via [schemas and resolvers](./schema/index).\n</BlockQuote>\n\n## Hook functions\n\n\n\n### before, after and error\n\n`before`, `after` and `error` hook functions are functions that are `async` or return a promise and take the [hook context](#hook-context) as the parameter and return nothing or throw an error.\n\n```ts\nimport { HookContext } from '../declarations'\n\nexport const hookFunction = async (context: HookContext) => {\n  // Do things here\n}\n```\n\nFor more information see the [hook flow](#hook-flow) section.\n\n### around\n\n`around` hooks are a special kind of hook that allow to control the entire `before`, `after` and `error` flow in a single function. They are a Feathers specific version of the generic [@feathersjs/hooks](https://github.com/feathersjs/hooks). An `around` hook is an `async` function that accepts two arguments:\n\n- The [hook context](#hook-context)\n- An asynchronous `next` function. Somewhere in the body of the hook function, there is a call to `await next()`, which calls the `next` hooks OR the original function if all other hooks have run.\n\nIn its simplest form, an around hook looks like this:\n\n```js\nimport { HookContext, NextFunction } from '../declarations'\n\nexport const myAfoundHook = async (context: HookContext, next: NextFunction) => {\n  try {\n    // Code before `await next()` runs before the main function\n    await next()\n    // Code after `await next()` runs after the main function.\n  } catch (error) {\n    // Do things on error\n  } finally {\n    // Do things always\n  }\n}\n```\n\nAny around hook can be wrapped around another function. Calling `await next()` will either call the next hook in the chain or the service method if all other hooks have run.\n\n## Hook flow\n\nIn general, hooks are executed in the order [they are registered](#registering-hooks) with `around` hooks running first:\n\n- `around` hooks (before `await next()`)\n- `before` hooks\n- service method\n- `after` hooks\n- `around` hooks (after `await next()`)\n\nNote that since `around` hooks wrap **around** everything, the first hook to run will be the last to execute its code after `await next()`. This is reverse of the order `after` hooks execute.\n\nThe hook flow can be affected as follows.\n\n### Throwing an error\n\nWhen an error is thrown (or the promise is rejected), all subsequent hooks - and the service method call if it didn't run already - will be skipped and only the error hooks will run.\n\nThe following example throws an error when the text for creating a new message is empty. You can also create very similar hooks to use your Node validation library of choice.\n\n```ts\napp.service('messages').hooks({\n  before: {\n    create: [\n      async (context: HookContext) => {\n        if (context.data.text.trim() === '') {\n          throw new Error('Message text can not be empty')\n        }\n      }\n    ]\n  }\n})\n```\n\n### Setting `context.result`\n\nWhen `context.result` is set in an `around` hook before calling `await next()` or in a `before` hook, the original [service method](./services) call will be skipped. All other hooks will still execute in their normal order. The following example always returns the currently [authenticated user](./authentication/service) instead of the actual user for all `get` method calls:\n\n```js\napp.service('users').hooks({\n  before: {\n    get: [\n      async (context: HookContext) => {\n        // Never call the actual users service\n        // just use the authenticated user\n        context.result = context.params.user\n      }\n    ]\n  }\n})\n```\n\n## Hook context\n\nThe hook `context` is passed to a hook function and contains information about the service method call. It has **read only** properties that should not be modified and **_writeable_** properties that can be changed for subsequent hooks.\n\n<BlockQuote type=\"tip\">\nThe `context` object is the same throughout a service method call so it is possible to add properties and use them in other hooks at a later time.\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nIf you want to inspect the hook context, e.g. via `console.log`, the object returned by [context.toJSON()](#contexttojson) should be used, otherwise you won't see all properties that are available.\n</BlockQuote>\n\n### `context.app`\n\n`context.app` is a _read only_ property that contains the [Feathers application object](./application). This can be used to retrieve other services (via `context.app.service('name')`) or configuration values.\n\n### `context.service`\n\n`context.service` is a _read only_ property and contains the service this hook currently runs on.\n\n### `context.path`\n\n`context.path` is a _read only_ property and contains the service name (or path) without leading or trailing slashes.\n\n### `context.method`\n\n`context.method` is a _read only_ property with the name of the [service method](./services) (`find`, `get`, `create`, `update`, `patch`, `remove`).\n\n### `context.type`\n\n`context.type` is a _read only_ property with the hook type (one of `around`, `before`, `after` or `error`).\n\n### `context.params`\n\n`context.params` is a **writeable** property that contains the [service method](./services) parameters (including `params.query`). For more information see the [service params documentation](./services#params).\n\n### `context.id`\n\n`context.id` is a **writeable** property and the `id` for a `get`, `remove`, `update` and `patch` service method call. For `remove`, `update` and `patch`, `context.id` can also be `null` when modifying multiple entries. In all other cases it will be `undefined`.\n\n### `context.data`\n\n`context.data` is a **writeable** property containing the data of a `create`, `update` and `patch` service method call.\n\n<BlockQuote type=\"note\">\n`context.data` will only be available for `create`, `update`, `patch` and [custom methods](./services#custom-methods).\n</BlockQuote>\n\n#### Working with Streams\n\nWhen using [streaming uploads](./client/rest#streaming-uploads), `context.data` will be a `ReadableStream`. Since streams can only be consumed once, around hooks are the recommended way to work with streaming data. Here are common patterns:\n\n**Passing streams through unchanged:**\n\nIf you only need to validate metadata or check permissions, you can let the stream pass through to the service:\n\n```ts\napp.service('uploads').hooks({\n  around: {\n    create: [\n      async (context: HookContext, next: NextFunction) => {\n        // Validate using headers - don't consume the stream\n        const contentType = context.params.headers?.['content-type']\n        if (!contentType?.startsWith('image/')) {\n          throw new BadRequest('Only images are allowed')\n        }\n\n        // Stream passes through unchanged\n        await next()\n      }\n    ]\n  }\n})\n```\n\n**Wrapping streams with transforms:**\n\nYou can wrap the incoming stream with a transform stream for processing:\n\n```ts\nimport { TransformStream } from 'node:stream/web'\n\napp.service('uploads').hooks({\n  around: {\n    create: [\n      async (context: HookContext, next: NextFunction) => {\n        const originalStream = context.data as ReadableStream\n\n        // Create a transform that tracks bytes\n        let totalBytes = 0\n        const countingTransform = new TransformStream({\n          transform(chunk, controller) {\n            totalBytes += chunk.length\n            controller.enqueue(chunk)\n          }\n        })\n\n        // Replace with transformed stream\n        context.data = originalStream.pipeThrough(countingTransform)\n\n        await next()\n\n        // After service completes, totalBytes is available\n        context.result.size = totalBytes\n      }\n    ]\n  }\n})\n```\n\n<BlockQuote type=\"warning\">\nStreams can only be consumed once. If you need to read the stream content in a hook (e.g., for validation), you must either buffer the entire stream or use a tee/transform approach. For large files, prefer validating metadata from headers rather than consuming the stream.\n</BlockQuote>\n\n### `context.error`\n\n`context.error` is a **writeable** property with the error object that was thrown in a failed method call. It can be modified to change the error that is returned at the end.\n\n<BlockQuote type=\"note\">\n`context.error` will only be available if `context.type` is `error`.\n</BlockQuote>\n\n### `context.result`\n\n`context.result` is a **writeable** property containing the result of the successful service method call. It is only available in `after` hooks. `context.result` can also be set in\n\n- An `around` or `before` hook to skip the actual service method (database) call\n- An `error` hook to swallow the error and return a result instead\n\n<BlockQuote type=\"note\">\n`context.result` will only be available if `context.type` is `after` or if `context.result` has been set.\n</BlockQuote>\n\n### `context.dispatch`\n\n`context.dispatch` is a **writeable, optional** property and contains a \"safe\" version of the data that should be sent to any client. If `context.dispatch` has not been set `context.result` will be sent to the client instead. `context.dispatch` only affects the data sent through a Feathers Transport like [REST](./express) or [Socket.io](./socketio). An internal method call will still get the data set in `context.result`.\n\n<BlockQuote type=\"warning\">\n`context.dispatch` is used by the `schemaHooks.resolveDispatch` [resolver](./schema/resolvers). Use dispatch resolvers whenever possible to get safe representations external data.\n</BlockQuote>\n\n### `context.http`\n\n`context.http` is a **writeable, optional** property that allows customizing HTTP response specific properties. The following properties can be set:\n\n- `context.http.status` - Sets the [HTTP status code](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) that should be returned. Usually the most appropriate status code will be picked automatically but there are cases where it needs to be customized.\n- `context.http.headers` - An object with additional HTTP response headers\n- `context.http.location` - Setting this property will trigger a redirect for HTTP requests.\n\n<BlockQuote type=\"warning\">\nSetting `context.http` properties will have no effect when using a websocket real-time connection.\n</BlockQuote>\n\n### `context.event`\n\n`context.event` is a **writeable, optional** property that allows service events to be skipped by setting it to `null`\n\n### `context.toJSON()`\n\n`context.toJSON()` returns a full object representation of the hook context and all its properties.\n\n## Registering hooks\n\nHook functions are registered on a service through the `app.service(<servicename>).hooks(hooks)` method. The most commonly used registration format is\n\n```js\n{\n  [type]: { // around, before, after or error\n    all: [\n      // list of hooks that should run for every method here\n    ],\n    [methodName]: [\n      // list of method hooks here\n    ]\n  }\n}\n```\n\nThis means usual hook registration looks like this:\n\n```ts\n// The standard all at once way (also used by the generator)\n// an array of functions per service method name (and for `all` methods)\napp.service('servicename').hooks({\n  around: {\n    all: [\n      async (context: HookContext, next: NextFunction) => {\n        console.log('around all hook ran')\n        await next()\n      }\n    ],\n    find: [\n      /* other hook functions here */\n    ],\n    get: [],\n    create: [],\n    update: [],\n    patch: [],\n    remove: [],\n    // Custom methods use hooks as well\n    myCustomMethod: []\n  },\n  before: {\n    all: [async (context: HookContext) => console.log('before all hook ran')],\n    find: [\n      /* other hook functions here */\n    ],\n    get: []\n    // ...etc\n  },\n  after: {\n    find: [async (context: HookContext) => console.log('after find hook ran')]\n  },\n  error: {}\n})\n```\n\n<BlockQuote type=\"warning\">\nHooks will only be available for the standard service methods or methods passed in `options.methods` to [app.use](application#usepath-service--options). See the [documentation for @feathersjs/hooks](https://github.com/feathersjs/hooks) how to use hooks on other methods.\n</BlockQuote>\n\nSince around hooks offer the same functionality as `before`, `after` and `error` hooks at the same time they can also be registered without a nested object:\n\n```ts\nimport { HookContext, NextFunction } from './declarations'\n\n// Passing an array of around hooks that run for every method\napp.service('servicename').hooks([\n  async (context: HookContext, next: NextFunction) => {\n    console.log('around all hook ran')\n    await next()\n  }\n])\n\n// Passing an object with method names and a list of around hooks\napp.service('servicename').hooks({\n  get: [\n    async (context: HookContext, next: NextFunction) => {\n      console.log('around get hook ran')\n      await next()\n    }\n  ],\n  create: [],\n  update: [],\n  patch: [],\n  remove: [],\n  myCustomMethod: []\n})\n```\n\n## Application hooks\n\n\n\n### Service hooks\n\nTo add hooks to every service `app.hooks(hooks)` can be used. Application hooks are [registered in the same format as service hooks](#registering-hooks) and also work exactly the same. Note when application hooks will be executed:\n\n- `around` application hook will run around all other hooks\n- `before` application hooks will always run _before_ all service `before` hooks\n- `after` application hooks will always run _after_ all service `after` hooks\n- `error` application hooks will always run _after_ all service `error` hooks\n\nHere is an example for a very useful application hook that logs every service method error with the service and method name as well as the error stack.\n\n```ts\nimport { HookContext } from './declarations'\n\napp.hooks({\n  error: {\n    all: [\n      async (context: HookContext) => {\n        console.error(`Error in '${context.path}' service method '${context.method}'`, context.error.stack)\n      }\n    ]\n  }\n})\n```\n\n### Setup and teardown\n\nA special kind of application hooks are [app.setup](./application#setupserver) and [app.teardown](./application#teardownserver) hooks. They are around hooks that can be used to initialize database connections etc. and only run once when the application starts or shuts down. Setup and teardown hooks only have `context.app` and `context.server` available in the hook context.\n\n```ts\nimport { MongoClient } from 'mongodb'\n\napp.hooks({\n  setup: [\n    async (context: HookContext, next: NextFunction) => {\n      // E.g. wait for MongoDB connection to complete\n      await context.app.get('mongoClient').connect()\n      await next()\n    }\n  ],\n  teardown: [\n    async (context: HookContext, next: NextFunction) => {\n      // Close MongoDB connection\n      await context.app.get('mongoClient').close()\n      await next()\n    }\n  ]\n})\n```",
    "breadcrumb": "Hooks",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/hooks.md",
    "heading": "Hooks",
    "subHeadings": [
      "Quick Example",
      "Hook functions",
      "before, after and error",
      "around",
      "Hook flow",
      "Throwing an error",
      "Setting `context.result`",
      "Hook context",
      "`context.app`",
      "`context.service`",
      "`context.path`",
      "`context.method`",
      "`context.type`",
      "`context.params`",
      "`context.id`",
      "`context.data`",
      "`context.error`",
      "`context.result`",
      "`context.dispatch`",
      "`context.http`",
      "`context.event`",
      "`context.toJSON()`",
      "Registering hooks",
      "Application hooks",
      "Service hooks",
      "Setup and teardown"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text",
      "js"
    ],
    "tokens": 3908,
    "category": "api",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "authentication",
      "schema",
      "resolver",
      "validation",
      "database",
      "mongodb",
      "real-time",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "around hooks",
      "error hooks",
      "hook context",
      "hook functions",
      "custom methods",
      "socket.io",
      "setup",
      "teardown",
      "application"
    ]
  },
  {
    "id": "v6-http-0",
    "content": "# HTTP\nBreadcrumb: HTTP\nCovers: createHandler | Options | Runtime Usage | Deno | Bun | Cloudflare Workers | Node.js | toNodeHandler | Middleware | errorHandler | queryParser | bodyParser | Custom Middleware | params | params.query | params.provider | params.headers | params.route | params.request | Content Types | JSON | Form Data | File Uploads | Streaming | Returning Responses | Async Iterators (SSE) | CORS | Custom Methods\nTopics: services, context, params, provider, authorization, adapter, events, rest, find, get, create, patch, custom methods, error handling, middleware, setup, application\n\n## createHandler\n\n`createHandler(app, middleware?)` creates a Web Standard request handler that processes HTTP requests for your Feathers application.\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\n```\n\nThe handler has the signature `(request: Request) => Promise<Response>` which is the Web Standard used by Deno, Bun, and Cloudflare Workers.\n\n### Options\n\n- `app` - The Feathers application\n- `middleware` - Optional array of middleware. Defaults to `[errorHandler(), queryParser(), bodyParser()]`\n\n## Runtime Usage\n\n\n\n### Deno\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n// ... configure your app\n\nconst handler = createHandler(app)\n\nDeno.serve({ port: 3030 }, handler)\n```\n\n### Bun\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n// ... configure your app\n\nconst handler = createHandler(app)\n\nBun.serve({\n  port: 3030,\n  fetch: handler\n})\n```\n\n### Cloudflare Workers\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n// ... configure your app\n\nconst handler = createHandler(app)\n\nexport default {\n  fetch: handler\n}\n```\n\n### Node.js\n\nNode.js does not have a built-in Web Standard HTTP server, so an adapter is required. The `toNodeHandler` function converts the Web Standard handler to work with Node's `http.createServer`.\n\n```ts\nimport { createServer } from 'node:http'\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\nimport { toNodeHandler } from 'feathers/http/node'\n\nconst app = feathers()\n// ... configure your app\n\nconst handler = createHandler(app)\nconst server = createServer(toNodeHandler(handler))\n\nserver.listen(3030, () => {\n  console.log('Server running on http://localhost:3030')\n})\n\n// Call app.setup to initialize all services\nawait app.setup(server)\n```\n\n## toNodeHandler\n\n`toNodeHandler(handler)` converts a Web Standard `(Request) => Promise<Response>` handler to Node's `(IncomingMessage, ServerResponse) => void` signature.\n\n```ts\nimport { toNodeHandler } from 'feathers/http/node'\n\nconst nodeHandler = toNodeHandler(handler)\n```\n\nThis adapter:\n\n- Converts Node's `IncomingMessage` to a Web Standard `Request`\n- Buffers JSON, form-urlencoded, and multipart requests for proper parsing\n- Streams all other content types directly\n- Writes the Web Standard `Response` back to Node's `ServerResponse`\n\n## Middleware\n\nThe HTTP handler uses a middleware chain for request processing. The default middleware handles common tasks like error handling, query parsing, and body parsing.\n\n### errorHandler\n\nCatches errors and returns them as properly formatted JSON responses with appropriate status codes.\n\n```ts\nimport { errorHandler } from 'feathers/http'\n```\n\n### queryParser\n\nParses URL query parameters using [qs](https://www.npmjs.com/package/qs) and adds them to `params.query`.\n\n```ts\nimport { queryParser } from 'feathers/http'\n\n// With custom parser\nimport qs from 'qs'\nqueryParser((query) => qs.parse(query, { arrayLimit: 200 }))\n```\n\n### bodyParser\n\nParses request bodies based on content type:\n\n| Content-Type                        | Parsing Method                       |\n| ----------------------------------- | ------------------------------------ |\n| `application/json`                  | `request.json()`                     |\n| `application/x-www-form-urlencoded` | `request.text()` â†’ `URLSearchParams` |\n| `multipart/form-data`               | `request.formData()`                 |\n| Everything else                     | Streams `request.body` directly      |\n\n```ts\nimport { bodyParser } from 'feathers/http'\n```\n\n### Custom Middleware\n\nYou can provide custom middleware to the handler:\n\n```ts\nimport { createHandler, errorHandler, queryParser, bodyParser } from 'feathers/http'\n\nconst customLogger = async (context, next) => {\n  console.log(`${context.request.method} ${context.request.url}`)\n  await next()\n}\n\nconst handler = createHandler(app, [errorHandler(), customLogger, queryParser(), bodyParser()])\n```\n\n## params\n\n\n\n### params.query\n\nContains the URL query parameters parsed by the `queryParser` middleware.\n\n```ts\n// GET /messages?status=read&limit=10\n// params.query = { status: 'read', limit: '10' }\n```\n\n### params.provider\n\nFor any service method call made through HTTP, `params.provider` will be set to `'rest'`.\n\n### params.headers\n\nContains the request headers as a plain object.\n\n```ts\n// params.headers = { 'content-type': 'application/json', ... }\n```\n\n### params.route\n\nRoute placeholders in a service URL will be added to `params.route`.\n\n```ts\napp.use('users/:userId/messages', messageService)\n\n// GET /users/123/messages\n// params.route = { userId: '123' }\n```\n\n### params.request\n\nThe original Web Standard `Request` object is available as `params.request`.\n\n## Content Types\n\n\n\n### JSON\n\nStandard JSON requests and responses:\n\n```ts\n// Request\nPOST /messages\nContent-Type: application/json\n\n{ \"text\": \"Hello world\" }\n\n// Service receives\ndata = { text: 'Hello world' }\n```\n\n### Form Data\n\nURL-encoded and multipart form data are automatically parsed:\n\n```ts\n// Request\nPOST /messages\nContent-Type: application/x-www-form-urlencoded\n\ntext=Hello+world&status=sent\n\n// Service receives\ndata = { text: 'Hello world', status: 'sent' }\n```\n\n### File Uploads\n\nMultipart file uploads use the Web Standard `FormData` API:\n\n```ts\n// Request\nPOST /uploads\nContent-Type: multipart/form-data\n\n// Service receives\ndata = {\n  file: File,           // Web Standard File object\n  description: 'string'\n}\n```\n\nMultiple files with the same field name become an array:\n\n```ts\ndata = {\n  files: [File, File, File]\n}\n```\n\n### Streaming\n\nNon-buffered content types are streamed directly to the service:\n\n```ts\nclass UploadService {\n  async create(stream: ReadableStream, params: Params) {\n    // Stream data directly to storage\n    const reader = stream.getReader()\n\n    while (true) {\n      const { done, value } = await reader.read()\n      if (done) break\n      // Process chunks\n    }\n\n    return { uploaded: true }\n  }\n}\n```\n\n## Returning Responses\n\nServices can return a Web Standard `Response` directly for full control:\n\n```ts\nclass DownloadService {\n  async get(id: string) {\n    const file = await storage.get(id)\n\n    return new Response(file.stream, {\n      headers: {\n        'Content-Type': file.contentType,\n        'Content-Disposition': `attachment; filename=\"${file.name}\"`\n      }\n    })\n  }\n}\n```\n\n## Async Iterators (SSE)\n\nServices can return async iterators for Server-Sent Events:\n\n```ts\nclass StreamService {\n  async find() {\n    return (async function* () {\n      for (let i = 0; i < 10; i++) {\n        yield { count: i }\n        await new Promise((resolve) => setTimeout(resolve, 1000))\n      }\n    })()\n  }\n}\n```\n\nThe response will be sent as `text/event-stream`:\n\n```\ndata: {\"count\":0}\n\ndata: {\"count\":1}\n\ndata: {\"count\":2}\n...\n```\n\n## CORS\n\nThe handler automatically sets CORS headers based on the request's `Origin` header:\n\n```\nAccess-Control-Allow-Origin: <request origin or *>\n```\n\nFor preflight `OPTIONS` requests, the handler returns:\n\n```\nAccess-Control-Allow-Origin: <origin>\nAccess-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, OPTIONS\nAccess-Control-Allow-Headers: accept, accept-language, content-language, content-type, range, authorization, x-service-method\nAccess-Control-Allow-Credentials: true\n```\n\n## Custom Methods\n\n[Custom service methods](./services#custom-methods) can be called via HTTP by setting the `X-Service-Method` header:\n\n```\nPOST /messages\nX-Service-Method: myCustomMethod\nContent-Type: application/json\n\n{ \"data\": \"value\" }\n```\n\nThis will call `messages.myCustomMethod({ data: 'value' }, params)`.",
    "rawContent": "## createHandler\n\n`createHandler(app, middleware?)` creates a Web Standard request handler that processes HTTP requests for your Feathers application.\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\n```\n\nThe handler has the signature `(request: Request) => Promise<Response>` which is the Web Standard used by Deno, Bun, and Cloudflare Workers.\n\n### Options\n\n- `app` - The Feathers application\n- `middleware` - Optional array of middleware. Defaults to `[errorHandler(), queryParser(), bodyParser()]`\n\n## Runtime Usage\n\n\n\n### Deno\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n// ... configure your app\n\nconst handler = createHandler(app)\n\nDeno.serve({ port: 3030 }, handler)\n```\n\n### Bun\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n// ... configure your app\n\nconst handler = createHandler(app)\n\nBun.serve({\n  port: 3030,\n  fetch: handler\n})\n```\n\n### Cloudflare Workers\n\n```ts\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\n\nconst app = feathers()\n// ... configure your app\n\nconst handler = createHandler(app)\n\nexport default {\n  fetch: handler\n}\n```\n\n### Node.js\n\nNode.js does not have a built-in Web Standard HTTP server, so an adapter is required. The `toNodeHandler` function converts the Web Standard handler to work with Node's `http.createServer`.\n\n```ts\nimport { createServer } from 'node:http'\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\nimport { toNodeHandler } from 'feathers/http/node'\n\nconst app = feathers()\n// ... configure your app\n\nconst handler = createHandler(app)\nconst server = createServer(toNodeHandler(handler))\n\nserver.listen(3030, () => {\n  console.log('Server running on http://localhost:3030')\n})\n\n// Call app.setup to initialize all services\nawait app.setup(server)\n```\n\n## toNodeHandler\n\n`toNodeHandler(handler)` converts a Web Standard `(Request) => Promise<Response>` handler to Node's `(IncomingMessage, ServerResponse) => void` signature.\n\n```ts\nimport { toNodeHandler } from 'feathers/http/node'\n\nconst nodeHandler = toNodeHandler(handler)\n```\n\nThis adapter:\n\n- Converts Node's `IncomingMessage` to a Web Standard `Request`\n- Buffers JSON, form-urlencoded, and multipart requests for proper parsing\n- Streams all other content types directly\n- Writes the Web Standard `Response` back to Node's `ServerResponse`\n\n## Middleware\n\nThe HTTP handler uses a middleware chain for request processing. The default middleware handles common tasks like error handling, query parsing, and body parsing.\n\n### errorHandler\n\nCatches errors and returns them as properly formatted JSON responses with appropriate status codes.\n\n```ts\nimport { errorHandler } from 'feathers/http'\n```\n\n### queryParser\n\nParses URL query parameters using [qs](https://www.npmjs.com/package/qs) and adds them to `params.query`.\n\n```ts\nimport { queryParser } from 'feathers/http'\n\n// With custom parser\nimport qs from 'qs'\nqueryParser((query) => qs.parse(query, { arrayLimit: 200 }))\n```\n\n### bodyParser\n\nParses request bodies based on content type:\n\n| Content-Type                        | Parsing Method                       |\n| ----------------------------------- | ------------------------------------ |\n| `application/json`                  | `request.json()`                     |\n| `application/x-www-form-urlencoded` | `request.text()` â†’ `URLSearchParams` |\n| `multipart/form-data`               | `request.formData()`                 |\n| Everything else                     | Streams `request.body` directly      |\n\n```ts\nimport { bodyParser } from 'feathers/http'\n```\n\n### Custom Middleware\n\nYou can provide custom middleware to the handler:\n\n```ts\nimport { createHandler, errorHandler, queryParser, bodyParser } from 'feathers/http'\n\nconst customLogger = async (context, next) => {\n  console.log(`${context.request.method} ${context.request.url}`)\n  await next()\n}\n\nconst handler = createHandler(app, [errorHandler(), customLogger, queryParser(), bodyParser()])\n```\n\n## params\n\n\n\n### params.query\n\nContains the URL query parameters parsed by the `queryParser` middleware.\n\n```ts\n// GET /messages?status=read&limit=10\n// params.query = { status: 'read', limit: '10' }\n```\n\n### params.provider\n\nFor any service method call made through HTTP, `params.provider` will be set to `'rest'`.\n\n### params.headers\n\nContains the request headers as a plain object.\n\n```ts\n// params.headers = { 'content-type': 'application/json', ... }\n```\n\n### params.route\n\nRoute placeholders in a service URL will be added to `params.route`.\n\n```ts\napp.use('users/:userId/messages', messageService)\n\n// GET /users/123/messages\n// params.route = { userId: '123' }\n```\n\n### params.request\n\nThe original Web Standard `Request` object is available as `params.request`.\n\n## Content Types\n\n\n\n### JSON\n\nStandard JSON requests and responses:\n\n```ts\n// Request\nPOST /messages\nContent-Type: application/json\n\n{ \"text\": \"Hello world\" }\n\n// Service receives\ndata = { text: 'Hello world' }\n```\n\n### Form Data\n\nURL-encoded and multipart form data are automatically parsed:\n\n```ts\n// Request\nPOST /messages\nContent-Type: application/x-www-form-urlencoded\n\ntext=Hello+world&status=sent\n\n// Service receives\ndata = { text: 'Hello world', status: 'sent' }\n```\n\n### File Uploads\n\nMultipart file uploads use the Web Standard `FormData` API:\n\n```ts\n// Request\nPOST /uploads\nContent-Type: multipart/form-data\n\n// Service receives\ndata = {\n  file: File,           // Web Standard File object\n  description: 'string'\n}\n```\n\nMultiple files with the same field name become an array:\n\n```ts\ndata = {\n  files: [File, File, File]\n}\n```\n\n### Streaming\n\nNon-buffered content types are streamed directly to the service:\n\n```ts\nclass UploadService {\n  async create(stream: ReadableStream, params: Params) {\n    // Stream data directly to storage\n    const reader = stream.getReader()\n\n    while (true) {\n      const { done, value } = await reader.read()\n      if (done) break\n      // Process chunks\n    }\n\n    return { uploaded: true }\n  }\n}\n```\n\n## Returning Responses\n\nServices can return a Web Standard `Response` directly for full control:\n\n```ts\nclass DownloadService {\n  async get(id: string) {\n    const file = await storage.get(id)\n\n    return new Response(file.stream, {\n      headers: {\n        'Content-Type': file.contentType,\n        'Content-Disposition': `attachment; filename=\"${file.name}\"`\n      }\n    })\n  }\n}\n```\n\n## Async Iterators (SSE)\n\nServices can return async iterators for Server-Sent Events:\n\n```ts\nclass StreamService {\n  async find() {\n    return (async function* () {\n      for (let i = 0; i < 10; i++) {\n        yield { count: i }\n        await new Promise((resolve) => setTimeout(resolve, 1000))\n      }\n    })()\n  }\n}\n```\n\nThe response will be sent as `text/event-stream`:\n\n```\ndata: {\"count\":0}\n\ndata: {\"count\":1}\n\ndata: {\"count\":2}\n...\n```\n\n## CORS\n\nThe handler automatically sets CORS headers based on the request's `Origin` header:\n\n```\nAccess-Control-Allow-Origin: <request origin or *>\n```\n\nFor preflight `OPTIONS` requests, the handler returns:\n\n```\nAccess-Control-Allow-Origin: <origin>\nAccess-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, OPTIONS\nAccess-Control-Allow-Headers: accept, accept-language, content-language, content-type, range, authorization, x-service-method\nAccess-Control-Allow-Credentials: true\n```\n\n## Custom Methods\n\n[Custom service methods](./services#custom-methods) can be called via HTTP by setting the `X-Service-Method` header:\n\n```\nPOST /messages\nX-Service-Method: myCustomMethod\nContent-Type: application/json\n\n{ \"data\": \"value\" }\n```\n\nThis will call `messages.myCustomMethod({ data: 'value' }, params)`.",
    "breadcrumb": "HTTP",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/http.md",
    "heading": "HTTP",
    "subHeadings": [
      "createHandler",
      "Options",
      "Runtime Usage",
      "Deno",
      "Bun",
      "Cloudflare Workers",
      "Node.js",
      "toNodeHandler",
      "Middleware",
      "errorHandler",
      "queryParser",
      "bodyParser",
      "Custom Middleware",
      "params",
      "params.query",
      "params.provider",
      "params.headers",
      "params.route",
      "params.request",
      "Content Types",
      "JSON",
      "Form Data",
      "File Uploads",
      "Streaming",
      "Returning Responses",
      "Async Iterators (SSE)",
      "CORS",
      "Custom Methods"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 1983,
    "category": "api",
    "tags": [
      "services",
      "context",
      "params",
      "provider",
      "authorization",
      "adapter",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "patch",
      "custom methods",
      "error handling",
      "middleware",
      "setup",
      "application"
    ]
  },
  {
    "id": "v6-index-0",
    "content": "# API\nBreadcrumb: API\nCovers: Core | Transports | Client\nTopics: hooks, services, real-time, channels, events, rest, feathers client, socket.io, middleware, application\n\n## Core\n\nFeathers core functionality that works on the client and the server\n\n- [Application](./application) - The main Feathers application API\n- [Services](./services) - Service objects and their methods and Feathers specific functionality\n- [Hooks](./hooks) - Pluggable middleware for service methods\n- [Events](./events) - Events sent by Feathers service methods\n- [Errors](./errors) - A collection of error classes used throughout Feathers\n\n## Transports\n\nExpose a Feathers application as an API server\n\n- [HTTP](./http) - Web Standard HTTP handler for Deno, Bun, Cloudflare Workers, and Node.js\n- [Channels](./channels) - Channels are used to send real-time events to clients\n\n## Client\n\nMore details on how to use Feathers on the client\n\n- [Usage](./client) - Feathers client usage in Node, React Native and the browser (also with Webpack and Browserify)\n- [REST](./client/rest) - Feathers client and direct REST API server usage\n- [Socket.io](./client/socketio) - Feathers client and direct Socket.io API server usage",
    "rawContent": "## Core\n\nFeathers core functionality that works on the client and the server\n\n- [Application](./application) - The main Feathers application API\n- [Services](./services) - Service objects and their methods and Feathers specific functionality\n- [Hooks](./hooks) - Pluggable middleware for service methods\n- [Events](./events) - Events sent by Feathers service methods\n- [Errors](./errors) - A collection of error classes used throughout Feathers\n\n## Transports\n\nExpose a Feathers application as an API server\n\n- [HTTP](./http) - Web Standard HTTP handler for Deno, Bun, Cloudflare Workers, and Node.js\n- [Channels](./channels) - Channels are used to send real-time events to clients\n\n## Client\n\nMore details on how to use Feathers on the client\n\n- [Usage](./client) - Feathers client usage in Node, React Native and the browser (also with Webpack and Browserify)\n- [REST](./client/rest) - Feathers client and direct REST API server usage\n- [Socket.io](./client/socketio) - Feathers client and direct Socket.io API server usage",
    "breadcrumb": "API",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/index.md",
    "heading": "API",
    "subHeadings": [
      "Core",
      "Transports",
      "Client"
    ],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 257,
    "category": "api",
    "tags": [
      "hooks",
      "services",
      "real-time",
      "channels",
      "events",
      "rest",
      "feathers client",
      "socket.io",
      "middleware",
      "application"
    ]
  },
  {
    "id": "v6-nodejs-0",
    "content": "# Node.js\nBreadcrumb: Node.js\nCovers: Setup | toNodeHandler\nTopics: services, adapter, find, create, setup\n\n## Setup\n\n```ts\nimport { createServer } from 'node:http'\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\nimport { toNodeHandler } from 'feathers/http/node'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\nconst server = createServer(toNodeHandler(handler))\n\nserver.listen(3030, () => {\n  console.log('Server running on http://localhost:3030')\n})\n\n// Call app.setup to initialize all services\nawait app.setup(server)\n```\n\n## toNodeHandler\n\n`toNodeHandler(handler)` converts a Web Standard `(Request) => Promise<Response>` handler to Node's `(IncomingMessage, ServerResponse) => void` signature.\n\n```ts\nimport { toNodeHandler } from 'feathers/http/node'\n\nconst nodeHandler = toNodeHandler(handler)\n```\n\nThis adapter:\n\n- Converts Node's `IncomingMessage` to a Web Standard `Request`\n- Buffers JSON, form-urlencoded, and multipart requests for proper parsing\n- Streams all other content types directly\n- Writes the Web Standard `Response` back to Node's `ServerResponse`",
    "rawContent": "## Setup\n\n```ts\nimport { createServer } from 'node:http'\nimport { feathers } from 'feathers'\nimport { createHandler } from 'feathers/http'\nimport { toNodeHandler } from 'feathers/http/node'\n\nconst app = feathers()\n\napp.use('messages', {\n  async find() {\n    return [{ id: 1, text: 'Hello world' }]\n  }\n})\n\nconst handler = createHandler(app)\nconst server = createServer(toNodeHandler(handler))\n\nserver.listen(3030, () => {\n  console.log('Server running on http://localhost:3030')\n})\n\n// Call app.setup to initialize all services\nawait app.setup(server)\n```\n\n## toNodeHandler\n\n`toNodeHandler(handler)` converts a Web Standard `(Request) => Promise<Response>` handler to Node's `(IncomingMessage, ServerResponse) => void` signature.\n\n```ts\nimport { toNodeHandler } from 'feathers/http/node'\n\nconst nodeHandler = toNodeHandler(handler)\n```\n\nThis adapter:\n\n- Converts Node's `IncomingMessage` to a Web Standard `Request`\n- Buffers JSON, form-urlencoded, and multipart requests for proper parsing\n- Streams all other content types directly\n- Writes the Web Standard `Response` back to Node's `ServerResponse`",
    "breadcrumb": "Node.js",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/nodejs.md",
    "heading": "Node.js",
    "subHeadings": [
      "Setup",
      "toNodeHandler"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 276,
    "category": "api",
    "tags": [
      "services",
      "adapter",
      "find",
      "create",
      "setup"
    ]
  },
  {
    "id": "v6-services-0",
    "content": "# Services\nBreadcrumb: Services\nCovers: Service methods | params | .find(params) | .get(id, params) | .create(data, params) | .update(id, data, params) | .patch(id, data, params) | .remove(id, params) | .setup(app, path) | .teardown(app, path) | Custom Methods | Feathers functionality | .hooks(hooks) | .publish([event, ] publisher) | .on(eventname, listener) | .emit(eventname, data) | .removeListener(eventname)\nTopics: hooks, services, params, provider, authentication, database, adapter, pagination, real-time, websockets, channels, events, rest, find, get, create, update, patch, remove, custom methods, socket.io, setup, teardown, application\n\n## Service methods\n\nService methods are pre-defined [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) and [custom methods](#custom-methods) that your service provides or that have already been implemented by one of the [database adapters](./databases/common). Below is an example of a Feathers service as a class or object.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params, Id, NullableId } from '@feathersjs/feathers'\n\nclass MyServiceClass {\n  async find(params: Params) {\n    return []\n  }\n  async get(id: Id, params: Params) {}\n  async create(data: any, params: Params) {}\n  async update(id: NullableId, data: any, params: Params) {}\n  async patch(id: NullableId, data: any, params: Params) {}\n  async remove(id: NullableId, params: Params) {}\n  async setup(app: Application, path: string) {}\n  async teardown(app: Application, path: string) {}\n}\n\nconst myServiceObject = {\n  async find(params: Params) {\n    return []\n  },\n  async get(id: Id, params: Params) {},\n  async create(data: any, params: Params) {},\n  async update(id: NullableId, data: any, params: Params) {},\n  async patch(id: NullableId, data: any, params: Params) {},\n  async remove(id: NullableId, params: Params) {},\n  async setup(app: Application, path: string) {},\n  async teardown(app: Application, path: string) {}\n}\n\ntype ServiceTypes = {\n  'my-service': MyServiceClass\n  'my-service-object': typeof myServiceObject\n}\n\nconst app = feathers<ServiceTypes>()\n\napp.use('my-service', new MyServiceClass())\napp.use('my-service-object', myServiceObject)\n```\n\n<BlockQuote type=\"danger\">\nAlways use the service returned by `app.service(path)` not the service object or class directly or you will not get any of the [Feathers service functionality](services#feathers-functionality)\n</BlockQuote>\n\n<BlockQuote type=\"tip\">\nMethods are optional and if a method is not implemented Feathers will automatically emit a `NotImplemented` error. At least one standard service method must be implemented to be considered a service. If you used `methods` option when registering the service via [app.use](./application#usepath-service--options), all methods listed must be available.\n</BlockQuote>\n\nService methods must use [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) or return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) and have the following parameters:\n\n- `id` â€” The identifier for the resource. A resource is the data identified by a unique id.\n- `data` â€” The resource data.\n- `params` - Additional parameters for the method call (see [params](#params))\n\nOnce registered, the service can be retrieved and used via [app.service()](./application#servicepath):\n\n```js\nconst myService = app.service('my-service')\n\nconst items = await myService.find()\n\nconst item = await app.service('my-service').get(1)\n\nconsole.log('.get(1)', item)\n```\n\n<BlockQuote type=\"note\">\nAlthough probably the most common use case, a service does not necessarily have to connect to a database. A custom service can implement any functionality like talking to another API or send an email etc.\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nThis section describes the general usage of service methods and how to implement them. They are already implemented by the official Feathers database adapters. For specifics on how to use the database adapters, see the [database adapters documentation](./databases/common).\n</BlockQuote>\n\n### params\n\n`params` contain additional information for the service method call. Some properties in `params` can be set by Feathers already. Commonly used are:\n\n- `params.query` - the query parameters from the client, either passed as URL query parameters (see the [REST](./express) chapter) or through websockets (see [Socket.io](./socketio)).\n- `params.provider` - The transport (`rest` or `socketio`) used for this service call. Will be `undefined` for internal calls from the server (unless passed explicitly).\n- `params.authentication` - The authentication information to use for the [authentication service](./authentication/service)\n- `params.user` - The authenticated user, either set by [Feathers authentication](./authentication/) or passed explicitly.\n- `params.connection` - If the service call has been made by a real-time transport (e.g. through websockets), `params.connection` is the connection object that can be used with [channels](./channels).\n- `params.headers` - The HTTP headers connected to this service call if available. This is either the headers of the REST call or the headers passed when initializing a websocket connection.\n\n<BlockQuote type=\"warning\">\nFor external calls only `params.query` will be sent between the client and server. This is because other parameters in `params` on the server often contain security critical information (like `params.user` or `params.authentication`).\n</BlockQuote>\n\n### .find(params)\n\n`service.find(params) -> Promise` - Retrieves a list of all resources from the service. `params.query` can be used to filter and limit the returned data.\n\n```ts\nclass MessageService {\n  async find(params: Params) {\n    return [\n      {\n        id: 1,\n        text: 'Message 1'\n      },\n      {\n        id: 2,\n        text: 'Message 2'\n      }\n    ]\n  }\n}\n\napp.use('messages', new MessageService())\n```\n\n<BlockQuote type=\"note\">\n`find` does not have to return an array. It can also return an object. The database adapters already do this for [pagination](./databases/common#pagination).\n</BlockQuote>\n\n### .get(id, params)\n\n`service.get(id, params) -> Promise` - Retrieves a single resource with the given `id` from the service.\n\n```ts\nimport type { Id, Params } from '@feathersjs/feathers'\n\nclass TodoService {\n  async get(id: Id, params: Params) {\n    return {\n      id,\n      text: `You have to do ${id}!`\n    }\n  }\n}\n\napp.use('todos', new TodoService())\n```\n\n### .create(data, params)\n\n`service.create(data, params) -> Promise` - Creates a new resource with `data`. The method should return with the newly created data. `data` may also be an array.\n\nA successful `create` method call emits the [`created` service event](./events#created) with the returned data or a separate event for every item if the returned data is an array.\n\n```ts\nimport type { Id, Params } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  messages: Message[] = []\n\n  async create(data: Message, params: Params) {\n    this.messages.push(data)\n\n    return data\n  }\n}\n\napp.use('messages', new MessageService())\n```\n\n<BlockQuote type=\"warning\">\nNote that `data` may also be an array. When using a [database adapters](./databases/adapters) the [`multi` option](./databases/common) has to be set to allow arrays.\n</BlockQuote>\n\n### .update(id, data, params)\n\n`service.update(id, data, params) -> Promise` - Replaces the resource identified by `id` with `data`. The method should return with the complete, updated resource data. `id` can also be `null` when updating multiple records.\n\nA successful `update` method call emits the [`updated` service event](./events#updated-patched). If an array is returned, it will send an individual `updated` event for every item.\n\n<BlockQuote type=\"note\">\nThe [database adapters](./databases/adapters) do not support completely replacing multiple entries.\n</BlockQuote>\n\n### .patch(id, data, params)\n\n`patch(id, data, params) -> Promise` - Merges the existing data of the resource identified by `id` with the new `data`. `id` can also be `null` indicating that multiple resources should be patched with `params.query` containing the query criteria.\n\nA successful `patch` method call emits the [`patched` service event](./events#updated-patched) with the returned data. When an array is returned when patching mutiple items, it will send an individual `patched` event for every item in the array.\n\nThe method should return with the complete, updated resource data. Implement `patch` additionally (or instead of) `update` if you want to distinguish between partial and full updates and support the `PATCH` HTTP method.\n\n<BlockQuote type=\"note\">\nWith [database adapters](./databases/adapters) the [`multi` option](./databases/common) has to be set explicitly to support patching multiple entries.\n</BlockQuote>\n\n### .remove(id, params)\n\n`service.remove(id, params) -> Promise` - Removes the resource with `id`. The method should return with the removed data. `id` can also be `null`, which indicates the deletion of multiple resources, with `params.query` containing the query criteria.\n\nA successful `remove` method call emits the [`removed` service event](./events#removed) with the returned data or a separate event for every item if the returned data is an array.\n\n<BlockQuote type=\"note\">\nWith [database adapters](./databases/adapters) the [`multi` option](./databases/common) has to be set explicitly to support removing multiple entries.\n</BlockQuote>\n\n### .setup(app, path)\n\n`service.setup(app, path) -> Promise` is a special method that initializes the service, passing an instance of the Feathers application and the path it has been registered on.\n\nWhen calling [app.listen](application#listenport) or [app.setup](application#setupserver) all registered services `setup` methods will be called. If a service is registered afterwards, the `setup` method will be called immediately.\n\n### .teardown(app, path)\n\n`service.teardown(app, path) -> Promise` is a special method that shuts down the service, passing an instance of the Feathers application and the path it has been registered on. If a service implements a `teardown` method, it will be called during [app.teardown()](application#teardownserver) or when unregistering the service via [app.unuse](./application#unusepath).\n\n## Custom Methods\n\nA custom method is any other service method you want to expose publicly. A custom method **must have** the signature of `(data, params)` with the same semantics as standard service methods (`data` is the payload, `params` is the service [params](#params)). They can be used with [hooks](./hooks) (including authentication) and must be `async` or return a Promise.\n\nIn order to register a public custom method, the names of _all methods_ have to be passed as the `methods` option when registering the service with [app.use()](./application#usepath-service--options)\n\n```ts\nimport type { Id, Params } from '@feathersjs/feathers'\n\ntype CustomData = {\n  name: string\n}\n\nclass MyService {\n  async get(id: Id, params: Params) {\n    return {\n      id,\n      message: `You have to do ${id}`\n    }\n  }\n\n  async myCustomMethod(data: CustomData, params: Params) {\n    return data\n  }\n}\n\ntype ServiceTypes = {\n  'my-service': MyService\n}\n\nconst app = feathers<ServiceTypes>()\n  .configure(rest())\n  .use('my-service', new MyService(), {\n    // Pass all methods you want to expose\n    methods: ['get', 'myCustomMethod']\n  })\n```\n\nSee the [REST client](./client/rest) and [Socket.io client](./client/socketio) chapters on how to use those custom methods on the client.\n\n<BlockQuote type=\"warning\">\nWhen passing the `methods` option **all methods** you want to expose, including standard service methods, must be listed. This allows to completely disable standard service method you might not want to expose. The `methods` option only applies to external access (via a transport like HTTP or websockets). All methods continue to be available internally on the server.\n</BlockQuote>\n\n## Feathers functionality\n\nWhen registering a service, Feathers (or its plugins) can also add its own methods to a service. Most notably, every service will automatically become an instance of a [NodeJS EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter).\n\n### .hooks(hooks)\n\nRegister [hooks](./hooks) for this service.\n\n### .publish([event, ] publisher)\n\nRegister an event publishing callback. For more information, see the [channels chapter](./channels).\n\n### .on(eventname, listener)\n\nProvided by the core [NodeJS EventEmitter .on](https://nodejs.org/api/events.html#events_emitter_on_eventname_listener). Registers a `listener` method (`function(data) {}`) for the given `eventname`.\n\n<BlockQuote type=\"note\">\nFor more information about service events, see the [Events chapter](./events).\n</BlockQuote>\n\n### .emit(eventname, data)\n\nProvided by the core [NodeJS EventEmitter .emit](https://nodejs.org/api/events.html#events_emitter_emit_eventname_args). Emits the event `eventname` to all event listeners.\n\n### .removeListener(eventname)\n\nProvided by the core [NodeJS EventEmitter .removeListener](https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener). Removes all listeners, or the given listener, for `eventname`.",
    "rawContent": "## Service methods\n\nService methods are pre-defined [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) and [custom methods](#custom-methods) that your service provides or that have already been implemented by one of the [database adapters](./databases/common). Below is an example of a Feathers service as a class or object.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params, Id, NullableId } from '@feathersjs/feathers'\n\nclass MyServiceClass {\n  async find(params: Params) {\n    return []\n  }\n  async get(id: Id, params: Params) {}\n  async create(data: any, params: Params) {}\n  async update(id: NullableId, data: any, params: Params) {}\n  async patch(id: NullableId, data: any, params: Params) {}\n  async remove(id: NullableId, params: Params) {}\n  async setup(app: Application, path: string) {}\n  async teardown(app: Application, path: string) {}\n}\n\nconst myServiceObject = {\n  async find(params: Params) {\n    return []\n  },\n  async get(id: Id, params: Params) {},\n  async create(data: any, params: Params) {},\n  async update(id: NullableId, data: any, params: Params) {},\n  async patch(id: NullableId, data: any, params: Params) {},\n  async remove(id: NullableId, params: Params) {},\n  async setup(app: Application, path: string) {},\n  async teardown(app: Application, path: string) {}\n}\n\ntype ServiceTypes = {\n  'my-service': MyServiceClass\n  'my-service-object': typeof myServiceObject\n}\n\nconst app = feathers<ServiceTypes>()\n\napp.use('my-service', new MyServiceClass())\napp.use('my-service-object', myServiceObject)\n```\n\n<BlockQuote type=\"danger\">\nAlways use the service returned by `app.service(path)` not the service object or class directly or you will not get any of the [Feathers service functionality](services#feathers-functionality)\n</BlockQuote>\n\n<BlockQuote type=\"tip\">\nMethods are optional and if a method is not implemented Feathers will automatically emit a `NotImplemented` error. At least one standard service method must be implemented to be considered a service. If you used `methods` option when registering the service via [app.use](./application#usepath-service--options), all methods listed must be available.\n</BlockQuote>\n\nService methods must use [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) or return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) and have the following parameters:\n\n- `id` â€” The identifier for the resource. A resource is the data identified by a unique id.\n- `data` â€” The resource data.\n- `params` - Additional parameters for the method call (see [params](#params))\n\nOnce registered, the service can be retrieved and used via [app.service()](./application#servicepath):\n\n```js\nconst myService = app.service('my-service')\n\nconst items = await myService.find()\n\nconst item = await app.service('my-service').get(1)\n\nconsole.log('.get(1)', item)\n```\n\n<BlockQuote type=\"note\">\nAlthough probably the most common use case, a service does not necessarily have to connect to a database. A custom service can implement any functionality like talking to another API or send an email etc.\n</BlockQuote>\n\n<BlockQuote type=\"warning\">\nThis section describes the general usage of service methods and how to implement them. They are already implemented by the official Feathers database adapters. For specifics on how to use the database adapters, see the [database adapters documentation](./databases/common).\n</BlockQuote>\n\n### params\n\n`params` contain additional information for the service method call. Some properties in `params` can be set by Feathers already. Commonly used are:\n\n- `params.query` - the query parameters from the client, either passed as URL query parameters (see the [REST](./express) chapter) or through websockets (see [Socket.io](./socketio)).\n- `params.provider` - The transport (`rest` or `socketio`) used for this service call. Will be `undefined` for internal calls from the server (unless passed explicitly).\n- `params.authentication` - The authentication information to use for the [authentication service](./authentication/service)\n- `params.user` - The authenticated user, either set by [Feathers authentication](./authentication/) or passed explicitly.\n- `params.connection` - If the service call has been made by a real-time transport (e.g. through websockets), `params.connection` is the connection object that can be used with [channels](./channels).\n- `params.headers` - The HTTP headers connected to this service call if available. This is either the headers of the REST call or the headers passed when initializing a websocket connection.\n\n<BlockQuote type=\"warning\">\nFor external calls only `params.query` will be sent between the client and server. This is because other parameters in `params` on the server often contain security critical information (like `params.user` or `params.authentication`).\n</BlockQuote>\n\n### .find(params)\n\n`service.find(params) -> Promise` - Retrieves a list of all resources from the service. `params.query` can be used to filter and limit the returned data.\n\n```ts\nclass MessageService {\n  async find(params: Params) {\n    return [\n      {\n        id: 1,\n        text: 'Message 1'\n      },\n      {\n        id: 2,\n        text: 'Message 2'\n      }\n    ]\n  }\n}\n\napp.use('messages', new MessageService())\n```\n\n<BlockQuote type=\"note\">\n`find` does not have to return an array. It can also return an object. The database adapters already do this for [pagination](./databases/common#pagination).\n</BlockQuote>\n\n### .get(id, params)\n\n`service.get(id, params) -> Promise` - Retrieves a single resource with the given `id` from the service.\n\n```ts\nimport type { Id, Params } from '@feathersjs/feathers'\n\nclass TodoService {\n  async get(id: Id, params: Params) {\n    return {\n      id,\n      text: `You have to do ${id}!`\n    }\n  }\n}\n\napp.use('todos', new TodoService())\n```\n\n### .create(data, params)\n\n`service.create(data, params) -> Promise` - Creates a new resource with `data`. The method should return with the newly created data. `data` may also be an array.\n\nA successful `create` method call emits the [`created` service event](./events#created) with the returned data or a separate event for every item if the returned data is an array.\n\n```ts\nimport type { Id, Params } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  messages: Message[] = []\n\n  async create(data: Message, params: Params) {\n    this.messages.push(data)\n\n    return data\n  }\n}\n\napp.use('messages', new MessageService())\n```\n\n<BlockQuote type=\"warning\">\nNote that `data` may also be an array. When using a [database adapters](./databases/adapters) the [`multi` option](./databases/common) has to be set to allow arrays.\n</BlockQuote>\n\n### .update(id, data, params)\n\n`service.update(id, data, params) -> Promise` - Replaces the resource identified by `id` with `data`. The method should return with the complete, updated resource data. `id` can also be `null` when updating multiple records.\n\nA successful `update` method call emits the [`updated` service event](./events#updated-patched). If an array is returned, it will send an individual `updated` event for every item.\n\n<BlockQuote type=\"note\">\nThe [database adapters](./databases/adapters) do not support completely replacing multiple entries.\n</BlockQuote>\n\n### .patch(id, data, params)\n\n`patch(id, data, params) -> Promise` - Merges the existing data of the resource identified by `id` with the new `data`. `id` can also be `null` indicating that multiple resources should be patched with `params.query` containing the query criteria.\n\nA successful `patch` method call emits the [`patched` service event](./events#updated-patched) with the returned data. When an array is returned when patching mutiple items, it will send an individual `patched` event for every item in the array.\n\nThe method should return with the complete, updated resource data. Implement `patch` additionally (or instead of) `update` if you want to distinguish between partial and full updates and support the `PATCH` HTTP method.\n\n<BlockQuote type=\"note\">\nWith [database adapters](./databases/adapters) the [`multi` option](./databases/common) has to be set explicitly to support patching multiple entries.\n</BlockQuote>\n\n### .remove(id, params)\n\n`service.remove(id, params) -> Promise` - Removes the resource with `id`. The method should return with the removed data. `id` can also be `null`, which indicates the deletion of multiple resources, with `params.query` containing the query criteria.\n\nA successful `remove` method call emits the [`removed` service event](./events#removed) with the returned data or a separate event for every item if the returned data is an array.\n\n<BlockQuote type=\"note\">\nWith [database adapters](./databases/adapters) the [`multi` option](./databases/common) has to be set explicitly to support removing multiple entries.\n</BlockQuote>\n\n### .setup(app, path)\n\n`service.setup(app, path) -> Promise` is a special method that initializes the service, passing an instance of the Feathers application and the path it has been registered on.\n\nWhen calling [app.listen](application#listenport) or [app.setup](application#setupserver) all registered services `setup` methods will be called. If a service is registered afterwards, the `setup` method will be called immediately.\n\n### .teardown(app, path)\n\n`service.teardown(app, path) -> Promise` is a special method that shuts down the service, passing an instance of the Feathers application and the path it has been registered on. If a service implements a `teardown` method, it will be called during [app.teardown()](application#teardownserver) or when unregistering the service via [app.unuse](./application#unusepath).\n\n## Custom Methods\n\nA custom method is any other service method you want to expose publicly. A custom method **must have** the signature of `(data, params)` with the same semantics as standard service methods (`data` is the payload, `params` is the service [params](#params)). They can be used with [hooks](./hooks) (including authentication) and must be `async` or return a Promise.\n\nIn order to register a public custom method, the names of _all methods_ have to be passed as the `methods` option when registering the service with [app.use()](./application#usepath-service--options)\n\n```ts\nimport type { Id, Params } from '@feathersjs/feathers'\n\ntype CustomData = {\n  name: string\n}\n\nclass MyService {\n  async get(id: Id, params: Params) {\n    return {\n      id,\n      message: `You have to do ${id}`\n    }\n  }\n\n  async myCustomMethod(data: CustomData, params: Params) {\n    return data\n  }\n}\n\ntype ServiceTypes = {\n  'my-service': MyService\n}\n\nconst app = feathers<ServiceTypes>()\n  .configure(rest())\n  .use('my-service', new MyService(), {\n    // Pass all methods you want to expose\n    methods: ['get', 'myCustomMethod']\n  })\n```\n\nSee the [REST client](./client/rest) and [Socket.io client](./client/socketio) chapters on how to use those custom methods on the client.\n\n<BlockQuote type=\"warning\">\nWhen passing the `methods` option **all methods** you want to expose, including standard service methods, must be listed. This allows to completely disable standard service method you might not want to expose. The `methods` option only applies to external access (via a transport like HTTP or websockets). All methods continue to be available internally on the server.\n</BlockQuote>\n\n## Feathers functionality\n\nWhen registering a service, Feathers (or its plugins) can also add its own methods to a service. Most notably, every service will automatically become an instance of a [NodeJS EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter).\n\n### .hooks(hooks)\n\nRegister [hooks](./hooks) for this service.\n\n### .publish([event, ] publisher)\n\nRegister an event publishing callback. For more information, see the [channels chapter](./channels).\n\n### .on(eventname, listener)\n\nProvided by the core [NodeJS EventEmitter .on](https://nodejs.org/api/events.html#events_emitter_on_eventname_listener). Registers a `listener` method (`function(data) {}`) for the given `eventname`.\n\n<BlockQuote type=\"note\">\nFor more information about service events, see the [Events chapter](./events).\n</BlockQuote>\n\n### .emit(eventname, data)\n\nProvided by the core [NodeJS EventEmitter .emit](https://nodejs.org/api/events.html#events_emitter_emit_eventname_args). Emits the event `eventname` to all event listeners.\n\n### .removeListener(eventname)\n\nProvided by the core [NodeJS EventEmitter .removeListener](https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener). Removes all listeners, or the given listener, for `eventname`.",
    "breadcrumb": "Services",
    "version": "v6",
    "sourceFile": "docs/v6_docs/api/services.md",
    "heading": "Services",
    "subHeadings": [
      "Service methods",
      "params",
      ".find(params)",
      ".get(id, params)",
      ".create(data, params)",
      ".update(id, data, params)",
      ".patch(id, data, params)",
      ".remove(id, params)",
      ".setup(app, path)",
      ".teardown(app, path)",
      "Custom Methods",
      "Feathers functionality",
      ".hooks(hooks)",
      ".publish([event, ] publisher)",
      ".on(eventname, listener)",
      ".emit(eventname, data)",
      ".removeListener(eventname)"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text",
      "js"
    ],
    "tokens": 3192,
    "category": "api",
    "tags": [
      "hooks",
      "services",
      "params",
      "provider",
      "authentication",
      "database",
      "adapter",
      "pagination",
      "real-time",
      "websockets",
      "channels",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "custom methods",
      "socket.io",
      "setup",
      "teardown",
      "application"
    ]
  },
  {
    "id": "v6-_discord-0",
    "content": "# Discord\nBreadcrumb: Discord\nCovers: Application client and secret\nTopics: authentication, authorization, jwt, oauth, get, remove, application\n\n## Application client and secret\n\nThe client id (App ID) and secret can be found [here](https://discord.com/developers/applications/):\n\nNow add this to your src/authentication.ts:\n\n```ts\nimport {OAuthProfile, OAuthStrategy} from \"@feathersjs/authentication-oauth\";\nimport {AuthenticationRequest} from \"@feathersjs/authentication\";\nimport axios, {AxiosRequestConfig} from 'axios'\nimport {ServiceAddons} from '@feathersjs/feathers';\nimport {AuthenticationService, JWTStrategy} from '@feathersjs/authentication';\nimport {LocalStrategy} from '@feathersjs/authentication-local';\nimport {oauth} from '@feathersjs/authentication-oauth';\nimport {Application} from './declarations';\n\nexport default function (app: Application) {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('jwt', new JWTStrategy());\n  authentication.register('local', new LocalStrategy());\n  authentication.register('discord', new DiscordStrategy());\n\n  app.use('/authentication', authentication);\n  app.configure(oauth());\n}\n\nexport class DiscordStrategy extends OAuthStrategy {\n  async getProfile(authResult: AuthenticationRequest) {\n    // This is the OAuth access token that can be used\n    // for Discord API requests as the Bearer token\n    const accessToken = authResult.access_token;\n    const userOptions: AxiosRequestConfig = {\n      method: 'GET',\n      headers: {'Authorization': `Bearer ${accessToken}`},\n      url: `https://discord.com/api/users/@me`,\n    };\n    const {data} = await axios(userOptions);\n    return data;\n  }\n\n  async getEntityData(profile: OAuthProfile) {\n    // `profile` is the data returned by getProfile\n    const baseData = await super.getEntityData(profile);\n\n    if (profile.avatar == null) {\n      profile.avatar = 'https://cdn.discordapp.com/embed/avatars/0.png'\n    } else {\n      const isGif = profile.avatar.startsWith('a_');\n      profile.avatar = `https://cdn.discordapp.com/avatars/${profile['id']}/${profile['avatar']}.${isGif ? 'gif' : 'png'}`\n    }\n\n    return {\n      ...baseData,\n      username: profile.username,\n      email: profile.email,\n      avatar: profile.avatar,\n    };\n  }\n}\n```\n\nIf you don't need the avatar then you can simply remove the lines of code.\nIf the user doesn't have an avatar then we will set it to Discord's default avatar.",
    "rawContent": "## Application client and secret\n\nThe client id (App ID) and secret can be found [here](https://discord.com/developers/applications/):\n\nNow add this to your src/authentication.ts:\n\n```ts\nimport {OAuthProfile, OAuthStrategy} from \"@feathersjs/authentication-oauth\";\nimport {AuthenticationRequest} from \"@feathersjs/authentication\";\nimport axios, {AxiosRequestConfig} from 'axios'\nimport {ServiceAddons} from '@feathersjs/feathers';\nimport {AuthenticationService, JWTStrategy} from '@feathersjs/authentication';\nimport {LocalStrategy} from '@feathersjs/authentication-local';\nimport {oauth} from '@feathersjs/authentication-oauth';\nimport {Application} from './declarations';\n\nexport default function (app: Application) {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('jwt', new JWTStrategy());\n  authentication.register('local', new LocalStrategy());\n  authentication.register('discord', new DiscordStrategy());\n\n  app.use('/authentication', authentication);\n  app.configure(oauth());\n}\n\nexport class DiscordStrategy extends OAuthStrategy {\n  async getProfile(authResult: AuthenticationRequest) {\n    // This is the OAuth access token that can be used\n    // for Discord API requests as the Bearer token\n    const accessToken = authResult.access_token;\n    const userOptions: AxiosRequestConfig = {\n      method: 'GET',\n      headers: {'Authorization': `Bearer ${accessToken}`},\n      url: `https://discord.com/api/users/@me`,\n    };\n    const {data} = await axios(userOptions);\n    return data;\n  }\n\n  async getEntityData(profile: OAuthProfile) {\n    // `profile` is the data returned by getProfile\n    const baseData = await super.getEntityData(profile);\n\n    if (profile.avatar == null) {\n      profile.avatar = 'https://cdn.discordapp.com/embed/avatars/0.png'\n    } else {\n      const isGif = profile.avatar.startsWith('a_');\n      profile.avatar = `https://cdn.discordapp.com/avatars/${profile['id']}/${profile['avatar']}.${isGif ? 'gif' : 'png'}`\n    }\n\n    return {\n      ...baseData,\n      username: profile.username,\n      email: profile.email,\n      avatar: profile.avatar,\n    };\n  }\n}\n```\n\nIf you don't need the avatar then you can simply remove the lines of code.\nIf the user doesn't have an avatar then we will set it to Discord's default avatar.",
    "breadcrumb": "Discord",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/authentication/_discord.md",
    "heading": "Discord",
    "subHeadings": [
      "Application client and secret"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 575,
    "category": "cookbook",
    "tags": [
      "authentication",
      "authorization",
      "jwt",
      "oauth",
      "get",
      "remove",
      "application"
    ]
  },
  {
    "id": "v6-anonymous-0",
    "content": "# Anonymous authentication\nBreadcrumb: Anonymous authentication\n\n",
    "rawContent": "",
    "breadcrumb": "Anonymous authentication",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/authentication/anonymous.md",
    "heading": "Anonymous authentication",
    "subHeadings": [],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 0,
    "category": "cookbook",
    "tags": []
  },
  {
    "id": "v6-apiKey-0",
    "content": "# API Key Authentication\nBreadcrumb: API Key Authentication\n\n",
    "rawContent": "",
    "breadcrumb": "API Key Authentication",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/authentication/apiKey.md",
    "heading": "API Key Authentication",
    "subHeadings": [],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 0,
    "category": "cookbook",
    "tags": []
  },
  {
    "id": "v6-auth0-0",
    "content": "# Auth0\nBreadcrumb: Auth0\nCovers: Strategy\nTopics: params, authentication, jwt, oauth, get, application\n\n## Strategy\n\nTo use Auth0 in the chat application from the [Feathers guide](../../guides/) we have to do the same modifications as already shown [for the GitHub login in the authentication guide](../../guides/basics/authentication).\n\nIn `src/authentication.ts` like this:\n\n```ts\nimport { ServiceAddons, Params } from '@feathersjs/feathers';\nimport { AuthenticationService, JWTStrategy } from '@feathersjs/authentication';\nimport { LocalStrategy } from '@feathersjs/authentication-local';\nimport { oauth, OAuthStrategy, OAuthProfile } from '@feathersjs/authentication-oauth';\n\nimport { Application } from './declarations';\n\ndeclare module './declarations' {\n  interface ServiceTypes {\n    'authentication': AuthenticationService & ServiceAddons<any>;\n  }\n}\n\nclass Auth0Strategy extends OAuthStrategy {\n  async getEntityData(profile: OAuthProfile, existing: any, params: Params) {\n    const baseData = await super.getEntityData(profile, existing, params);\n\n    return {\n      ...baseData,\n      email: profile.email\n    };\n  }\n}\n\nexport default function(app: Application) {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('jwt', new JWTStrategy());\n  authentication.register('local', new LocalStrategy());\n  authentication.register('auth0', new Auth0Strategy());\n\n  app.use('/authentication', authentication);\n  app.configure(oauth());\n}\n```\n\nAdditionally, `auth0Id` needs to be included in the data in the users service class.",
    "rawContent": "## Strategy\n\nTo use Auth0 in the chat application from the [Feathers guide](../../guides/) we have to do the same modifications as already shown [for the GitHub login in the authentication guide](../../guides/basics/authentication).\n\nIn `src/authentication.ts` like this:\n\n```ts\nimport { ServiceAddons, Params } from '@feathersjs/feathers';\nimport { AuthenticationService, JWTStrategy } from '@feathersjs/authentication';\nimport { LocalStrategy } from '@feathersjs/authentication-local';\nimport { oauth, OAuthStrategy, OAuthProfile } from '@feathersjs/authentication-oauth';\n\nimport { Application } from './declarations';\n\ndeclare module './declarations' {\n  interface ServiceTypes {\n    'authentication': AuthenticationService & ServiceAddons<any>;\n  }\n}\n\nclass Auth0Strategy extends OAuthStrategy {\n  async getEntityData(profile: OAuthProfile, existing: any, params: Params) {\n    const baseData = await super.getEntityData(profile, existing, params);\n\n    return {\n      ...baseData,\n      email: profile.email\n    };\n  }\n}\n\nexport default function(app: Application) {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('jwt', new JWTStrategy());\n  authentication.register('local', new LocalStrategy());\n  authentication.register('auth0', new Auth0Strategy());\n\n  app.use('/authentication', authentication);\n  app.configure(oauth());\n}\n```\n\nAdditionally, `auth0Id` needs to be included in the data in the users service class.",
    "breadcrumb": "Auth0",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/authentication/auth0.md",
    "heading": "Auth0",
    "subHeadings": [
      "Strategy"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 366,
    "category": "cookbook",
    "tags": [
      "params",
      "authentication",
      "jwt",
      "oauth",
      "get",
      "application"
    ]
  },
  {
    "id": "v6-facebook-0",
    "content": "# Facebook\nBreadcrumb: Facebook\nCovers: Application client and secret | Getting profile data\nTopics: params, authentication, authorization, jwt, oauth, get, application\n\n## Application client and secret\n\nThe client id (App ID) and secret can be found in the Settings of the [Facebook app](https://developers.facebook.com/apps):\n\n## Getting profile data\n\nThe standard OAuth strategy only returns the default profile fields (`id` and `name`). To get other fields, like the email or profile picture, the [getProfile](../../api/authentication/oauth#getprofile-data-params) method of the [OAuth strategy needs to be customized](../../api/authentication/oauth#customization) to call the Graph API profile endpoint `https://graph.facebook.com/me` with an HTTP request library like [Axios](https://developers.facebook.com/tools/explorer/) requesting the additional fields.\n\n> __Pro tip:__ Facebook API requests can be tested via the [Graph API explorer](https://developers.facebook.com/tools/explorer/).\n\nThe following example allows to log in with Facebook in the [chat application from the guide](../../guides/index):\n\n```ts\nimport { Params } from '@feathersjs/feathers';\nimport { AuthenticationService, JWTStrategy, AuthenticationRequest } from '@feathersjs/authentication';\nimport { LocalStrategy } from '@feathersjs/authentication-local';\nimport { expressOauth, OAuthStrategy, OAuthProfile } from '@feathersjs/authentication-oauth';\nimport axios from 'axios';\nimport { Application } from './declarations';\n\ndeclare module './declarations' {\n  interface ServiceTypes {\n    'authentication': AuthenticationService & ServiceAddons<any>;\n  }\n}\n\nclass FacebookStrategy extends OAuthStrategy {\n  async getProfile (authResult: AuthenticationRequest, _params: Params) {\n    // This is the OAuth access token that can be used\n    // for Facebook API requests as the Bearer token\n    const accessToken = authResult.access_token;\n\n    const { data } = await axios.get('https://graph.facebook.com/me', {\n      headers: {\n        authorization: `Bearer ${accessToken}`\n      },\n      params: {\n        // There are\n        fields: 'id,name,email'\n      }\n    });\n\n    return data;\n  }\n\n  async getEntityData(profile: OAuthProfile, existing: any, params: Params) {\n    // `profile` is the data returned by getProfile\n    const baseData = await super.getEntityData(profile, existing, params);\n\n    return {\n      ...baseData,\n      email: profile.email\n    };\n  }\n}\n\nexport default function(app: Application) {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('jwt', new JWTStrategy());\n  authentication.register('local', new LocalStrategy());\n  authentication.register('facebook', new FacebookStrategy());\n\n  app.use('/authentication', authentication);\n  app.configure(expressOauth());\n}\n```\n\n> __Pro tip:__ [See all available Facebook user options here](https://developers.facebook.com/docs/graph-api/reference/user/).",
    "rawContent": "## Application client and secret\n\nThe client id (App ID) and secret can be found in the Settings of the [Facebook app](https://developers.facebook.com/apps):\n\n## Getting profile data\n\nThe standard OAuth strategy only returns the default profile fields (`id` and `name`). To get other fields, like the email or profile picture, the [getProfile](../../api/authentication/oauth#getprofile-data-params) method of the [OAuth strategy needs to be customized](../../api/authentication/oauth#customization) to call the Graph API profile endpoint `https://graph.facebook.com/me` with an HTTP request library like [Axios](https://developers.facebook.com/tools/explorer/) requesting the additional fields.\n\n> __Pro tip:__ Facebook API requests can be tested via the [Graph API explorer](https://developers.facebook.com/tools/explorer/).\n\nThe following example allows to log in with Facebook in the [chat application from the guide](../../guides/index):\n\n```ts\nimport { Params } from '@feathersjs/feathers';\nimport { AuthenticationService, JWTStrategy, AuthenticationRequest } from '@feathersjs/authentication';\nimport { LocalStrategy } from '@feathersjs/authentication-local';\nimport { expressOauth, OAuthStrategy, OAuthProfile } from '@feathersjs/authentication-oauth';\nimport axios from 'axios';\nimport { Application } from './declarations';\n\ndeclare module './declarations' {\n  interface ServiceTypes {\n    'authentication': AuthenticationService & ServiceAddons<any>;\n  }\n}\n\nclass FacebookStrategy extends OAuthStrategy {\n  async getProfile (authResult: AuthenticationRequest, _params: Params) {\n    // This is the OAuth access token that can be used\n    // for Facebook API requests as the Bearer token\n    const accessToken = authResult.access_token;\n\n    const { data } = await axios.get('https://graph.facebook.com/me', {\n      headers: {\n        authorization: `Bearer ${accessToken}`\n      },\n      params: {\n        // There are\n        fields: 'id,name,email'\n      }\n    });\n\n    return data;\n  }\n\n  async getEntityData(profile: OAuthProfile, existing: any, params: Params) {\n    // `profile` is the data returned by getProfile\n    const baseData = await super.getEntityData(profile, existing, params);\n\n    return {\n      ...baseData,\n      email: profile.email\n    };\n  }\n}\n\nexport default function(app: Application) {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('jwt', new JWTStrategy());\n  authentication.register('local', new LocalStrategy());\n  authentication.register('facebook', new FacebookStrategy());\n\n  app.use('/authentication', authentication);\n  app.configure(expressOauth());\n}\n```\n\n> __Pro tip:__ [See all available Facebook user options here](https://developers.facebook.com/docs/graph-api/reference/user/).",
    "breadcrumb": "Facebook",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/authentication/facebook.md",
    "heading": "Facebook",
    "subHeadings": [
      "Application client and secret",
      "Getting profile data"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 692,
    "category": "cookbook",
    "tags": [
      "params",
      "authentication",
      "authorization",
      "jwt",
      "oauth",
      "get",
      "application"
    ]
  },
  {
    "id": "v6-firebase-0",
    "content": "# Firebase\nBreadcrumb: Firebase\nCovers: Authentation Setup | Authentication Strategy | Building frontend | Create auth page | Initialize client w/Firebase auth\nTopics: hooks, params, provider, authentication, jwt, oauth, get, create, update, feathers client, socket.io, setup, application\n\n## Authentation Setup\n\nUpdate `config/default.json`:\n\n```json\n{\n  \"authentication\": {\n    \"oauth\": {}\n  },\n  \"firebase\": {\n    \"type\": \"THIS SHOULD BE YOUR SERVICE ACCOUNT\",\n    \"project_id\": \"GENERATED UNDER FIREBASE CONSOLE\",\n    \"...\": \"...\"\n  }\n}\n\n```\n> Note: Since Firebase can be used for more than just authentication, we'll store our service account in the root of our config. Otherwise, if preferred, you can store under `authentication.oauth`.\n\n## Authentication Strategy\n\nCreate a file under `src/firebase.js`:\n\n```js\nconst firebase = require('firebase-admin');\nconst { OAuthStrategy } = require('@feathersjs/authentication-oauth');\nconst { NotAuthenticated } = require('@feathersjs/errors');\n\nconst logger = require('./logger');\n\nfunction initialize(app){\n  const firebaseConfig = app.get('firebase');\n\n  // Initialize app\n  try {\n    firebase.initializeApp({\n      credential: firebase.credential.cert(firebaseConfig)\n    });\n  } catch (e) {\n    console.log('erorr initializing firebase', e);\n  }\n}\n\nclass FirebaseStrategy extends OAuthStrategy {\n\n  async authenticate(authentication, params){\n    logger.debug('firebase:strategy:authenticate');\n    return super.authenticate(authentication, params);\n  }\n\n  async getProfile(data, _params){\n    const firebase = require('firebase-admin');\n    let user;\n\n    try {\n      user = await firebase.auth().verifyIdToken(data.access_token);\n    } catch(e){\n      logger.error(e);\n      throw new NotAuthenticated();\n    }\n\n    logger.debug(`firebase:strategy:getProfile:successful ${user.user_id}`);\n\n    return {\n      email: user.email,\n      id: user.user_id\n    };\n  }\n\n  async getEntityData(profile) {\n    const baseData = await super.getEntityData(profile);\n\n    return {\n      ...baseData,\n      email: profile.email\n    };\n  }\n}\n\nmodule.exports = { initialize, FirebaseStrategy };\n```\n\nNow we can edit `src/authentication.js`\n\n```js\nconst { AuthenticationService, JWTStrategy } = require('@feathersjs/authentication');\nconst { expressOauth } = require('@feathersjs/authentication-oauth');\n\nconst { FirebaseStrategy } = require('./firebase');\n\nmodule.exports = app => {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('firebase', new FirebaseStrategy());\n\n  app.use('/authentication', authentication);\n  app.configure(expressOauth());\n};\n```\n\n## Building frontend\n\nTo save time, you can leverage the pre-built UI provided by [Firebase UI](https://firebase.google.com/docs/auth/web/firebaseui).\n\n### Create auth page\n\nFirst, create a `public/firebase_auth.html` file that initializes everything we'll need for our different auth components.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Firebase Authentication Example</title>\n  <!-- The core Firebase JS SDK is always required and must be listed first -->\n  <script src=\"https://www.gstatic.com/firebasejs/7.21.0/firebase-app.js\"></script>\n\n  <!-- TODO: Add SDKs for Firebase products that you want to use\n       https://firebase.google.com/docs/web/setup#available-libraries -->\n  <script src=\"https://www.gstatic.com/firebasejs/7.21.0/firebase-auth.js\"></script>\n\n  <!-- Firebase UI -->\n  <script src=\"https://www.gstatic.com/firebasejs/ui/4.6.1/firebase-ui-auth.js\"></script>\n  <link type=\"text/css\" rel=\"stylesheet\" href=\"https://www.gstatic.com/firebasejs/ui/4.6.1/firebase-ui-auth.css\" />\n\n</head>\n<body>\n  <!-- The surrounding HTML is left untouched by FirebaseUI.\n      Your app may use that space for branding, controls and other customizations.-->\n  <h1>Welcome to My Awesome App</h1>\n\n  <!-- Optionally show a preparing state, until the guest or member app is ready. Usually after authentication is determined -->\n  <div id=\"app-preparing\"></div>\n\n  <!-- App for guests to auth, etc. -->\n  <div id=\"app-guest\" style=\"display: none;\">\n    <div id=\"firebaseui-auth-container\"></div>\n    <div id=\"loader\">Loading...</div>\n  </div>\n\n  <!-- App for members only -->\n  <div id=\"app-member\" style=\"display: none;\"></div>\n\n  <!-- Custom -->\n  <script src=\"//unpkg.com/@feathersjs/client@^4.3.0/dist/feathers.js\"></script>\n  <script src=\"/socket.io/socket.io.js\"></script>\n  <script src=\"/client.js\"></script>\n</body>\n</html>\n```\n\n### Initialize client w/Firebase auth\n\nNow, let's make a `public/client.js` file where all of our JavaScript will live.\n\n> Be sure to update `firebaseConfig` with the one provided from your [Firebase Console](https://console.firebase.google.com/). Additionally, checkout [Firebase UI](https://firebase.google.com/docs/auth/web/firebaseui) docs for more information on customizing `ui.start`. This includes theming options, all providers supported by Firebase & more.\n\n```js\nlet client, ui;\n\ninit();\n\nfunction init(){\n  initializeFeathers();\n  initializeAuth();\n  initializeFirebase();\n}\n\nfunction initializeFeathers(){\n  // Establish a Socket.io connection\n  const socket = io();\n  // Initialize our Feathers client application through Socket.io\n  // with hooks and authentication.\n  client = feathers();\n\n  client.configure(feathers.socketio(socket));\n  // Use localStorage to store our login token\n  client.configure(feathers.authentication());\n}\n\n// Either re-authenticate existing session, or start Firebase UI\nasync function initializeAuth(){\n  try {\n    await client.reAuthenticate();\n    showMemberApp();\n  } catch(e){\n    // Error re-authenticating, so let's start Firebase UI\n    showGuestApp();\n  }\n\n  // No longer need to prepare anything\n  document.getElementById('app-preparing').style.display = 'none';\n}\n\nfunction initializeFirebase(){\n  // Your web app's Firebase configuration\n  // For Firebase JS SDK v7.20.0 and later, measurementId is optional\n  var firebaseConfig = {\n    // Copy this from your Firebase Console\n    // Under Project Settings -> Web App\n  };\n  // Initialize Firebase\n  firebase.initializeApp(firebaseConfig);\n\n  // Initialize the FirebaseUI Widget using Firebase.\n  ui = new firebaseui.auth.AuthUI(firebase.auth());\n}\n\nasync function showMemberApp(){\n  // Get user information\n  const { user } = await client.get('authentication');\n\n  // Hide Guest App\n  document.getElementById('app-guest').style.display = 'none';\n\n  // Show member app\n  document.getElementById('app-member').style.display = 'block';\n  document.getElementById('app-member').innerHTML = `Logged in as, ${user.email}. <a href=\"#\" id=\"logout\">Logout</a>`;\n\n}\n\nfunction showGuestApp(){\n  // Hide & clear member app\n  document.getElementById('app-member').style.display = 'none';\n  document.getElementById('app-member').innerHTML = '';\n\n  // Show Guest app\n  document.getElementById('app-guest').style.display = 'block';\n  startFirebaseUI();\n}\n\nfunction startFirebaseUI(){\n  ui.start('#firebaseui-auth-container', {\n    callbacks: {\n      signInSuccessWithAuthResult: function(authResult, redirectUrl) {\n        // User successfully signed in.\n        // Return type determines whether we continue the redirect automatically\n        // or whether we leave that to developer to handle.\n        firebase.auth().currentUser.getIdToken(/* forceRefresh */ true).then(async function(idToken) {\n          await client.authenticate({\n            strategy: 'firebase',\n            access_token: idToken,\n          });\n          showMemberApp();\n        });\n\n        return false;\n      },\n      uiShown: function() {\n        // The widget is rendered.\n        // Hide the loader.\n        document.getElementById('loader').style.display = 'none';\n      }\n    },\n    // Will use popup for IDP Providers sign-in flow instead of the default, redirect.\n    signInFlow: 'popup',\n    credentialHelper: firebaseui.auth.CredentialHelper.NONE, // disable accountchooter.com helper\n    signInOptions: [\n      firebase.auth.EmailAuthProvider.PROVIDER_ID,\n      firebase.auth.FacebookAuthProvider.PROVIDER_ID,\n      firebase.auth.TwitterAuthProvider.PROVIDER_ID,\n    ],\n    // Other config options...\n  });\n}\n\nconst addEventListener = (selector, event, handler) => {\n  document.addEventListener(event, async ev => {\n    if (ev.target.closest(selector)) {\n      handler(ev);\n    }\n  });\n};\n\n// \"Logout\" button click handler\naddEventListener('#logout', 'click', async () => {\n  await client.logout();\n\n  showGuestApp();\n});\n```\n\nNow you should be able to visit your Firebase auth at the\n\n```\nhttp://localhost:3030/firebase_auth.html\n```\n\npage locally and authenticate w/any Firebase Providers you've set up in your Firebase Project ðŸ”¥",
    "rawContent": "## Authentation Setup\n\nUpdate `config/default.json`:\n\n```json\n{\n  \"authentication\": {\n    \"oauth\": {}\n  },\n  \"firebase\": {\n    \"type\": \"THIS SHOULD BE YOUR SERVICE ACCOUNT\",\n    \"project_id\": \"GENERATED UNDER FIREBASE CONSOLE\",\n    \"...\": \"...\"\n  }\n}\n\n```\n> Note: Since Firebase can be used for more than just authentication, we'll store our service account in the root of our config. Otherwise, if preferred, you can store under `authentication.oauth`.\n\n## Authentication Strategy\n\nCreate a file under `src/firebase.js`:\n\n```js\nconst firebase = require('firebase-admin');\nconst { OAuthStrategy } = require('@feathersjs/authentication-oauth');\nconst { NotAuthenticated } = require('@feathersjs/errors');\n\nconst logger = require('./logger');\n\nfunction initialize(app){\n  const firebaseConfig = app.get('firebase');\n\n  // Initialize app\n  try {\n    firebase.initializeApp({\n      credential: firebase.credential.cert(firebaseConfig)\n    });\n  } catch (e) {\n    console.log('erorr initializing firebase', e);\n  }\n}\n\nclass FirebaseStrategy extends OAuthStrategy {\n\n  async authenticate(authentication, params){\n    logger.debug('firebase:strategy:authenticate');\n    return super.authenticate(authentication, params);\n  }\n\n  async getProfile(data, _params){\n    const firebase = require('firebase-admin');\n    let user;\n\n    try {\n      user = await firebase.auth().verifyIdToken(data.access_token);\n    } catch(e){\n      logger.error(e);\n      throw new NotAuthenticated();\n    }\n\n    logger.debug(`firebase:strategy:getProfile:successful ${user.user_id}`);\n\n    return {\n      email: user.email,\n      id: user.user_id\n    };\n  }\n\n  async getEntityData(profile) {\n    const baseData = await super.getEntityData(profile);\n\n    return {\n      ...baseData,\n      email: profile.email\n    };\n  }\n}\n\nmodule.exports = { initialize, FirebaseStrategy };\n```\n\nNow we can edit `src/authentication.js`\n\n```js\nconst { AuthenticationService, JWTStrategy } = require('@feathersjs/authentication');\nconst { expressOauth } = require('@feathersjs/authentication-oauth');\n\nconst { FirebaseStrategy } = require('./firebase');\n\nmodule.exports = app => {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('firebase', new FirebaseStrategy());\n\n  app.use('/authentication', authentication);\n  app.configure(expressOauth());\n};\n```\n\n## Building frontend\n\nTo save time, you can leverage the pre-built UI provided by [Firebase UI](https://firebase.google.com/docs/auth/web/firebaseui).\n\n### Create auth page\n\nFirst, create a `public/firebase_auth.html` file that initializes everything we'll need for our different auth components.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Firebase Authentication Example</title>\n  <!-- The core Firebase JS SDK is always required and must be listed first -->\n  <script src=\"https://www.gstatic.com/firebasejs/7.21.0/firebase-app.js\"></script>\n\n  <!-- TODO: Add SDKs for Firebase products that you want to use\n       https://firebase.google.com/docs/web/setup#available-libraries -->\n  <script src=\"https://www.gstatic.com/firebasejs/7.21.0/firebase-auth.js\"></script>\n\n  <!-- Firebase UI -->\n  <script src=\"https://www.gstatic.com/firebasejs/ui/4.6.1/firebase-ui-auth.js\"></script>\n  <link type=\"text/css\" rel=\"stylesheet\" href=\"https://www.gstatic.com/firebasejs/ui/4.6.1/firebase-ui-auth.css\" />\n\n</head>\n<body>\n  <!-- The surrounding HTML is left untouched by FirebaseUI.\n      Your app may use that space for branding, controls and other customizations.-->\n  <h1>Welcome to My Awesome App</h1>\n\n  <!-- Optionally show a preparing state, until the guest or member app is ready. Usually after authentication is determined -->\n  <div id=\"app-preparing\"></div>\n\n  <!-- App for guests to auth, etc. -->\n  <div id=\"app-guest\" style=\"display: none;\">\n    <div id=\"firebaseui-auth-container\"></div>\n    <div id=\"loader\">Loading...</div>\n  </div>\n\n  <!-- App for members only -->\n  <div id=\"app-member\" style=\"display: none;\"></div>\n\n  <!-- Custom -->\n  <script src=\"//unpkg.com/@feathersjs/client@^4.3.0/dist/feathers.js\"></script>\n  <script src=\"/socket.io/socket.io.js\"></script>\n  <script src=\"/client.js\"></script>\n</body>\n</html>\n```\n\n### Initialize client w/Firebase auth\n\nNow, let's make a `public/client.js` file where all of our JavaScript will live.\n\n> Be sure to update `firebaseConfig` with the one provided from your [Firebase Console](https://console.firebase.google.com/). Additionally, checkout [Firebase UI](https://firebase.google.com/docs/auth/web/firebaseui) docs for more information on customizing `ui.start`. This includes theming options, all providers supported by Firebase & more.\n\n```js\nlet client, ui;\n\ninit();\n\nfunction init(){\n  initializeFeathers();\n  initializeAuth();\n  initializeFirebase();\n}\n\nfunction initializeFeathers(){\n  // Establish a Socket.io connection\n  const socket = io();\n  // Initialize our Feathers client application through Socket.io\n  // with hooks and authentication.\n  client = feathers();\n\n  client.configure(feathers.socketio(socket));\n  // Use localStorage to store our login token\n  client.configure(feathers.authentication());\n}\n\n// Either re-authenticate existing session, or start Firebase UI\nasync function initializeAuth(){\n  try {\n    await client.reAuthenticate();\n    showMemberApp();\n  } catch(e){\n    // Error re-authenticating, so let's start Firebase UI\n    showGuestApp();\n  }\n\n  // No longer need to prepare anything\n  document.getElementById('app-preparing').style.display = 'none';\n}\n\nfunction initializeFirebase(){\n  // Your web app's Firebase configuration\n  // For Firebase JS SDK v7.20.0 and later, measurementId is optional\n  var firebaseConfig = {\n    // Copy this from your Firebase Console\n    // Under Project Settings -> Web App\n  };\n  // Initialize Firebase\n  firebase.initializeApp(firebaseConfig);\n\n  // Initialize the FirebaseUI Widget using Firebase.\n  ui = new firebaseui.auth.AuthUI(firebase.auth());\n}\n\nasync function showMemberApp(){\n  // Get user information\n  const { user } = await client.get('authentication');\n\n  // Hide Guest App\n  document.getElementById('app-guest').style.display = 'none';\n\n  // Show member app\n  document.getElementById('app-member').style.display = 'block';\n  document.getElementById('app-member').innerHTML = `Logged in as, ${user.email}. <a href=\"#\" id=\"logout\">Logout</a>`;\n\n}\n\nfunction showGuestApp(){\n  // Hide & clear member app\n  document.getElementById('app-member').style.display = 'none';\n  document.getElementById('app-member').innerHTML = '';\n\n  // Show Guest app\n  document.getElementById('app-guest').style.display = 'block';\n  startFirebaseUI();\n}\n\nfunction startFirebaseUI(){\n  ui.start('#firebaseui-auth-container', {\n    callbacks: {\n      signInSuccessWithAuthResult: function(authResult, redirectUrl) {\n        // User successfully signed in.\n        // Return type determines whether we continue the redirect automatically\n        // or whether we leave that to developer to handle.\n        firebase.auth().currentUser.getIdToken(/* forceRefresh */ true).then(async function(idToken) {\n          await client.authenticate({\n            strategy: 'firebase',\n            access_token: idToken,\n          });\n          showMemberApp();\n        });\n\n        return false;\n      },\n      uiShown: function() {\n        // The widget is rendered.\n        // Hide the loader.\n        document.getElementById('loader').style.display = 'none';\n      }\n    },\n    // Will use popup for IDP Providers sign-in flow instead of the default, redirect.\n    signInFlow: 'popup',\n    credentialHelper: firebaseui.auth.CredentialHelper.NONE, // disable accountchooter.com helper\n    signInOptions: [\n      firebase.auth.EmailAuthProvider.PROVIDER_ID,\n      firebase.auth.FacebookAuthProvider.PROVIDER_ID,\n      firebase.auth.TwitterAuthProvider.PROVIDER_ID,\n    ],\n    // Other config options...\n  });\n}\n\nconst addEventListener = (selector, event, handler) => {\n  document.addEventListener(event, async ev => {\n    if (ev.target.closest(selector)) {\n      handler(ev);\n    }\n  });\n};\n\n// \"Logout\" button click handler\naddEventListener('#logout', 'click', async () => {\n  await client.logout();\n\n  showGuestApp();\n});\n```\n\nNow you should be able to visit your Firebase auth at the\n\n```\nhttp://localhost:3030/firebase_auth.html\n```\n\npage locally and authenticate w/any Firebase Providers you've set up in your Firebase Project ðŸ”¥",
    "breadcrumb": "Firebase",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/authentication/firebase.md",
    "heading": "Firebase",
    "subHeadings": [
      "Authentation Setup",
      "Authentication Strategy",
      "Building frontend",
      "Create auth page",
      "Initialize client w/Firebase auth"
    ],
    "hasCode": true,
    "codeLanguages": [
      "json",
      "text",
      "js",
      "html"
    ],
    "tokens": 2126,
    "category": "cookbook",
    "tags": [
      "hooks",
      "params",
      "provider",
      "authentication",
      "jwt",
      "oauth",
      "get",
      "create",
      "update",
      "feathers client",
      "socket.io",
      "setup",
      "application"
    ]
  },
  {
    "id": "v6-google-0",
    "content": "# Google\nBreadcrumb: Google\nCovers: Application client and secret | Using the data returned from the Google App through a custom OAuth Strategy\nTopics: authentication, jwt, oauth, database, get, create, setup, application\n\n## Application client and secret\n\nThe client id (App ID) and secret can be acquired by creating a [OAuth client ID](https://console.developers.google.com/apis/credentials):\n1. Click on 'OAuth client ID'\n2. Select 'web application', fill in the information and click 'Create'\n\n**Important**: Fill in the callback url, in a default Feathers setup it will be /oauth/google/callback.\n\n3. Replace `<App ID>` and `<App Secret>` with the id and secret of the created OAuth client ID application\n\n```js\n{\n  \"authentication\": {\n    \"oauth\": {\n      \"google\": {\n        \"key\": \"<client-id>.apps.googleusercontent.com\",\n        \"secret\": \"<client-secret>\",\n        \"scope\": [\"openid\", \"email\"],\n        \"nonce\": true\n      }\n    }\n  }\n}\n```\n\nNote: Use the generated credentials of the OAuth client ID.\n\nNote: `<client-id>` will be replaced by a string similar to **481298021138-hv27glb811ocr7pdon5lsg8hh5a6pgjv**.apps.googleusercontent.com.\n\nNote: `<client-secret>` will be replaced by a string similar to **XkWl0witdP4ogeNIgyOi-CeS**.\n\n## Using the data returned from the Google App through a custom OAuth Strategy\n\nIn `src/authentication.js`:\n\n```js\nconst axios = require('axios');\nconst { OAuthStrategy } = require('@feathersjs/authentication-oauth');\n\nclass GoogleStrategy extends OAuthStrategy {\n  async getEntityData(profile) {\n\n    // this will set 'googleId'\n    const baseData = await super.getEntityData(profile);\n\n    // this will grab the picture and email address of the Google profile\n    return {\n      ...baseData,\n      profilePicture: profile.picture,\n      email: profile.email\n    };\n  }\n}\n\nmodule.exports = app => {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('jwt', new JWTStrategy());\n  authentication.register('local', new LocalStrategy());\n  authentication.register('google', new GoogleStrategy());\n\n  app.use('/authentication', authentication);\n  app.configure(expressOauth());\n};\n```\n**Important**: googleId, profilePicture and email are properties that should exist on the database model!",
    "rawContent": "## Application client and secret\n\nThe client id (App ID) and secret can be acquired by creating a [OAuth client ID](https://console.developers.google.com/apis/credentials):\n1. Click on 'OAuth client ID'\n2. Select 'web application', fill in the information and click 'Create'\n\n**Important**: Fill in the callback url, in a default Feathers setup it will be /oauth/google/callback.\n\n3. Replace `<App ID>` and `<App Secret>` with the id and secret of the created OAuth client ID application\n\n```js\n{\n  \"authentication\": {\n    \"oauth\": {\n      \"google\": {\n        \"key\": \"<client-id>.apps.googleusercontent.com\",\n        \"secret\": \"<client-secret>\",\n        \"scope\": [\"openid\", \"email\"],\n        \"nonce\": true\n      }\n    }\n  }\n}\n```\n\nNote: Use the generated credentials of the OAuth client ID.\n\nNote: `<client-id>` will be replaced by a string similar to **481298021138-hv27glb811ocr7pdon5lsg8hh5a6pgjv**.apps.googleusercontent.com.\n\nNote: `<client-secret>` will be replaced by a string similar to **XkWl0witdP4ogeNIgyOi-CeS**.\n\n## Using the data returned from the Google App through a custom OAuth Strategy\n\nIn `src/authentication.js`:\n\n```js\nconst axios = require('axios');\nconst { OAuthStrategy } = require('@feathersjs/authentication-oauth');\n\nclass GoogleStrategy extends OAuthStrategy {\n  async getEntityData(profile) {\n\n    // this will set 'googleId'\n    const baseData = await super.getEntityData(profile);\n\n    // this will grab the picture and email address of the Google profile\n    return {\n      ...baseData,\n      profilePicture: profile.picture,\n      email: profile.email\n    };\n  }\n}\n\nmodule.exports = app => {\n  const authentication = new AuthenticationService(app);\n\n  authentication.register('jwt', new JWTStrategy());\n  authentication.register('local', new LocalStrategy());\n  authentication.register('google', new GoogleStrategy());\n\n  app.use('/authentication', authentication);\n  app.configure(expressOauth());\n};\n```\n**Important**: googleId, profilePicture and email are properties that should exist on the database model!",
    "breadcrumb": "Google",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/authentication/google.md",
    "heading": "Google",
    "subHeadings": [
      "Application client and secret",
      "Using the data returned from the Google App through a custom OAuth Strategy"
    ],
    "hasCode": true,
    "codeLanguages": [
      "js",
      "text"
    ],
    "tokens": 512,
    "category": "cookbook",
    "tags": [
      "authentication",
      "jwt",
      "oauth",
      "database",
      "get",
      "create",
      "setup",
      "application"
    ]
  },
  {
    "id": "v6-revoke-jwt-0",
    "content": "# Revoking JWTs\nBreadcrumb: Revoking JWTs\nCovers: Basic example | Using Redis\nTopics: params, authentication, jwt, adapter, get, create, remove, application\n\n## Basic example\n\nThe following example shows the basic flow of how a JWT can be revoked by storing it in a plain object. In a normal application you would use something like the [Redis storage shown below](#using-redis).\n\n```js\nconst { AuthenticationService } = require('@feathersjs/authentication');\nconst { NotAuthenticated } = require('@feathersjs/errors');\n\nconst revokedTokens = {};\n\nclass RevokableAuthService extends AuthenticationService {\n  async revokeAccessToken (accessToken) {\n    // First make sure the access token is valid\n    const verified = await this.verifyAccessToken(accessToken);\n\n    revokedTokens[accessToken] = true;\n\n    return verified;\n  }\n\n  async verifyAccessToken(accessToken) {\n    // First check if the token has been revoked\n    if (revokedTokens[accessToken]) {\n      throw new NotAuthenticated('Token revoked');\n    }\n\n    return super.verifyAccessToken(accessToken);\n  }\n\n  async remove (id, params) {\n    const authResult = await super.remove(id, params);\n    const { accessToken } = authResult;\n\n    if (accessToken) {\n      // If there is an access token, revoke it\n      await this.revokeAccessToken(accessToken);\n    }\n\n    return authResult;\n  }\n}\n\napp.use('/authentication', new RevokableAuthService(app));\n```\n\n## Using Redis\n\n[Redis](https://redis.io/) is a great storage mechanism for revoked JWTs because it allows to remove keys after a certain time. A revoked JWT does not have to be stored forever and can be removed from storage after it has expired since it will no longer be valid anyway. The flow is the same as shown above but using the NodeJS Redis adapter instead:\n\n```\nnpm install redis\n```\n\n```js\nconst redis = require('redis');\n\nconst { AuthenticationService } = require('@feathersjs/authentication');\nconst { NotAuthenticated } = require('@feathersjs/errors');\n\nclass RedisAuthService extends AuthenticationService {\n  constructor (app, configKey) {\n    super(app, configKey);\n\n    const client = redis.createClient();\n\n    this.redis = {\n      client,\n      get: client.get.bind(client),\n      set: client.set.bind(client),\n      exists: client.exists.bind(client),\n      expireat: client.exists.bind(client)\n    }\n\n    (async () => {\n      await this.redis.client.connect();\n    })()\n  }\n\n  async revokeAccessToken (accessToken) {\n    // First make sure the access token is valid\n    const verified = await this.verifyAccessToken(accessToken);\n    // Calculate the remaining valid time for the token (in seconds)\n    const expiry = verified.exp - Math.floor(Date.now() / 1000);\n\n    // Add the revoked token to Redis and set expiration\n    await this.redis.set(accessToken, 1, { EX: expiry });\n\n    return verified;\n  }\n\n  async verifyAccessToken(accessToken) {\n    if (await this.redis.exists(accessToken)) {\n      throw new NotAuthenticated('Token revoked');\n    }\n\n    return super.verifyAccessToken(accessToken);\n  }\n\n  async remove (id, params) {\n    const authResult = await super.remove(id, params);\n    const { accessToken } = authResult;\n\n    if (accessToken) {\n      // If there is an access token, revoke it\n      await this.revokeAccessToken(accessToken);\n    }\n\n    return authResult;\n  }\n}\n\napp.use('/authentication', new RedisAuthService(app));\n```",
    "rawContent": "## Basic example\n\nThe following example shows the basic flow of how a JWT can be revoked by storing it in a plain object. In a normal application you would use something like the [Redis storage shown below](#using-redis).\n\n```js\nconst { AuthenticationService } = require('@feathersjs/authentication');\nconst { NotAuthenticated } = require('@feathersjs/errors');\n\nconst revokedTokens = {};\n\nclass RevokableAuthService extends AuthenticationService {\n  async revokeAccessToken (accessToken) {\n    // First make sure the access token is valid\n    const verified = await this.verifyAccessToken(accessToken);\n\n    revokedTokens[accessToken] = true;\n\n    return verified;\n  }\n\n  async verifyAccessToken(accessToken) {\n    // First check if the token has been revoked\n    if (revokedTokens[accessToken]) {\n      throw new NotAuthenticated('Token revoked');\n    }\n\n    return super.verifyAccessToken(accessToken);\n  }\n\n  async remove (id, params) {\n    const authResult = await super.remove(id, params);\n    const { accessToken } = authResult;\n\n    if (accessToken) {\n      // If there is an access token, revoke it\n      await this.revokeAccessToken(accessToken);\n    }\n\n    return authResult;\n  }\n}\n\napp.use('/authentication', new RevokableAuthService(app));\n```\n\n## Using Redis\n\n[Redis](https://redis.io/) is a great storage mechanism for revoked JWTs because it allows to remove keys after a certain time. A revoked JWT does not have to be stored forever and can be removed from storage after it has expired since it will no longer be valid anyway. The flow is the same as shown above but using the NodeJS Redis adapter instead:\n\n```\nnpm install redis\n```\n\n```js\nconst redis = require('redis');\n\nconst { AuthenticationService } = require('@feathersjs/authentication');\nconst { NotAuthenticated } = require('@feathersjs/errors');\n\nclass RedisAuthService extends AuthenticationService {\n  constructor (app, configKey) {\n    super(app, configKey);\n\n    const client = redis.createClient();\n\n    this.redis = {\n      client,\n      get: client.get.bind(client),\n      set: client.set.bind(client),\n      exists: client.exists.bind(client),\n      expireat: client.exists.bind(client)\n    }\n\n    (async () => {\n      await this.redis.client.connect();\n    })()\n  }\n\n  async revokeAccessToken (accessToken) {\n    // First make sure the access token is valid\n    const verified = await this.verifyAccessToken(accessToken);\n    // Calculate the remaining valid time for the token (in seconds)\n    const expiry = verified.exp - Math.floor(Date.now() / 1000);\n\n    // Add the revoked token to Redis and set expiration\n    await this.redis.set(accessToken, 1, { EX: expiry });\n\n    return verified;\n  }\n\n  async verifyAccessToken(accessToken) {\n    if (await this.redis.exists(accessToken)) {\n      throw new NotAuthenticated('Token revoked');\n    }\n\n    return super.verifyAccessToken(accessToken);\n  }\n\n  async remove (id, params) {\n    const authResult = await super.remove(id, params);\n    const { accessToken } = authResult;\n\n    if (accessToken) {\n      // If there is an access token, revoke it\n      await this.revokeAccessToken(accessToken);\n    }\n\n    return authResult;\n  }\n}\n\napp.use('/authentication', new RedisAuthService(app));\n```",
    "breadcrumb": "Revoking JWTs",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/authentication/revoke-jwt.md",
    "heading": "Revoking JWTs",
    "subHeadings": [
      "Basic example",
      "Using Redis"
    ],
    "hasCode": true,
    "codeLanguages": [
      "js",
      "text"
    ],
    "tokens": 808,
    "category": "cookbook",
    "tags": [
      "params",
      "authentication",
      "jwt",
      "adapter",
      "get",
      "create",
      "remove",
      "application"
    ]
  },
  {
    "id": "v6-stateless-0",
    "content": "# Stateless JWT\nBreadcrumb: Stateless JWT\nCovers: Configuration | Customizing the payload\nTopics: params, authentication, jwt, local strategy, get\n\n## Configuration\n\nStateless tokens can be issued by setting the `entity` option in the [JWT strategy authentication configuration](../../api/authentication/jwt#configuration) to `null` (in which case `service` option also won't be used):\n\n```json\n{\n  \"authentication\": {\n    \"secret\": \"CHANGE_ME\",\n    \"entity\": null,\n    \"authStrategies\": [ \"jwt\", \"local\" ],\n    \"jwtOptions\": {\n      \"header\": { \"typ\": \"access\" },\n      \"audience\": \"https://yourdomain.com\",\n      \"issuer\": \"feathers\",\n      \"algorithm\": \"HS256\",\n      \"expiresIn\": \"1d\"\n    }\n  }\n}\n```\n\n> __Note:__ When still using other built-in strategies (like the [local strategy](../../api/authentication/local)) with an entity, the option can be set for each strategy (e.g. `{ \"authentication\": { \"local\": { \"entity\": \"user\" } } }`).\n\n## Customizing the payload\n\nIn order for the token to contain information, the `getPayload` method needs to be customize by [extending the authentication service](../../api/authentication/service#customization):\n\n```js\nconst { AuthenticationService } = require('@feathersjs/authentication');\n\nclass MyAuthService extends AuthenticationService {\n  async getPayload(authResult, params) {\n    // Call original `getPayload` first\n    const payload = await super.getPayload(authResult, params);\n    const { user } = authResult;\n\n    if (user && user.permissions) {\n      payload.permissions = user.permissions;\n    }\n\n    return payload;\n  }\n}\n\napp.use('/authentication', new MyAuthService(app));\n```",
    "rawContent": "## Configuration\n\nStateless tokens can be issued by setting the `entity` option in the [JWT strategy authentication configuration](../../api/authentication/jwt#configuration) to `null` (in which case `service` option also won't be used):\n\n```json\n{\n  \"authentication\": {\n    \"secret\": \"CHANGE_ME\",\n    \"entity\": null,\n    \"authStrategies\": [ \"jwt\", \"local\" ],\n    \"jwtOptions\": {\n      \"header\": { \"typ\": \"access\" },\n      \"audience\": \"https://yourdomain.com\",\n      \"issuer\": \"feathers\",\n      \"algorithm\": \"HS256\",\n      \"expiresIn\": \"1d\"\n    }\n  }\n}\n```\n\n> __Note:__ When still using other built-in strategies (like the [local strategy](../../api/authentication/local)) with an entity, the option can be set for each strategy (e.g. `{ \"authentication\": { \"local\": { \"entity\": \"user\" } } }`).\n\n## Customizing the payload\n\nIn order for the token to contain information, the `getPayload` method needs to be customize by [extending the authentication service](../../api/authentication/service#customization):\n\n```js\nconst { AuthenticationService } = require('@feathersjs/authentication');\n\nclass MyAuthService extends AuthenticationService {\n  async getPayload(authResult, params) {\n    // Call original `getPayload` first\n    const payload = await super.getPayload(authResult, params);\n    const { user } = authResult;\n\n    if (user && user.permissions) {\n      payload.permissions = user.permissions;\n    }\n\n    return payload;\n  }\n}\n\napp.use('/authentication', new MyAuthService(app));\n```",
    "breadcrumb": "Stateless JWT",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/authentication/stateless.md",
    "heading": "Stateless JWT",
    "subHeadings": [
      "Configuration",
      "Customizing the payload"
    ],
    "hasCode": true,
    "codeLanguages": [
      "json",
      "text",
      "js"
    ],
    "tokens": 373,
    "category": "cookbook",
    "tags": [
      "params",
      "authentication",
      "jwt",
      "local strategy",
      "get"
    ]
  },
  {
    "id": "v6-docker-0",
    "content": "# Dockerize a Feathers application\nBreadcrumb: Dockerize a Feathers application\nCovers: Create an app | Dockerfile | Build the image | Start the container\nTopics: create\n\n## Create an app\n\n```sh\nmkdir feathers-app\ncd feathers-app/\nfeathers generate app\n```\n\n### Dockerfile\n\nAdd the following `Dockerfile` to the project directory:\n\n```\nFROM node:lts-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm install\n\nCOPY . .\n\nEXPOSE 3030\n\nCMD [\"npm\", \"run\", \"start\"]\n```\n\n## Build the image\n\n```sh\ndocker build -t my-feathers-image .\n```\n\n## Start the container\n\n```sh\ndocker run -d -p 3030:3030 --name my-feathers-container my-feathers-image\n```",
    "rawContent": "## Create an app\n\n```sh\nmkdir feathers-app\ncd feathers-app/\nfeathers generate app\n```\n\n### Dockerfile\n\nAdd the following `Dockerfile` to the project directory:\n\n```\nFROM node:lts-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm install\n\nCOPY . .\n\nEXPOSE 3030\n\nCMD [\"npm\", \"run\", \"start\"]\n```\n\n## Build the image\n\n```sh\ndocker build -t my-feathers-image .\n```\n\n## Start the container\n\n```sh\ndocker run -d -p 3030:3030 --name my-feathers-container my-feathers-image\n```",
    "breadcrumb": "Dockerize a Feathers application",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/deploy/docker.md",
    "heading": "Dockerize a Feathers application",
    "subHeadings": [
      "Create an app",
      "Dockerfile",
      "Build the image",
      "Start the container"
    ],
    "hasCode": true,
    "codeLanguages": [
      "sh",
      "text"
    ],
    "tokens": 120,
    "category": "cookbook",
    "tags": [
      "create"
    ]
  },
  {
    "id": "v6-file-uploading-0",
    "content": "# File uploads in FeathersJS\nBreadcrumb: File uploads in FeathersJS\nCovers: Our Goals | Basic upload with feathers-blob and feathers-client | DataURI upload problems | Feathers-blob with multipart support. | Further improvements\nTopics: hooks, services, context, params, authentication, authorization, validation, real-time, events, rest, get, create, feathers client, socket.io, middleware, setup\n\n## Our Goals\n\nWe want to implement an upload service to accomplish a few important things:\n\n1. It has to handle large files (+10MB).\n2. It needs to work with the app's authentication and authorization.\n3. The files need to be validated.\n4. At the moment there is no third party storage service involved, but this will change in the near future, so it has to be prepared.\n5. It has to show the upload progress.\n\nThe plan is to upload the files to a feathers service so we can take advantage of hooks for authentication, authorization and validation, and for service events.\n\nFortunately, there exists a file storage service: [feathers-blob](https://github.com/feathersjs/feathers-blob). With it we can meet our goals, but (spoiler alert) it isn't an ideal solution.  We discuss some of its problems below.\n\n## Basic upload with feathers-blob and feathers-client\n\nFor the sake of simplicity, we will be working over a very basic feathers server, with just the upload service.\n\nLets look at the server code:\n\n```javascript\n/* --- server.js --- */\n\nconst feathers = require('@feathersjs/feathers');\nconst express = require('@feathersjs/express');\nconst socketio = require('@feathersjs/socketio');\n\n// feathers-blob service\nconst blobService = require('feathers-blob');\n// Here we initialize a FileSystem storage,\n// but you can use feathers-blob with any other\n// storage service like AWS or Google Drive.\nconst fs = require('fs-blob-store');\nconst blobStorage = fs(__dirname + '/uploads');\n\n// Feathers app\nconst app = express(feathers());\n\n// Parse HTTP JSON bodies\napp.use(express.json());\n// Parse URL-encoded params\napp.use(express.urlencoded({ extended: true }));\n// Add REST API support\napp.configure(express.rest());\n// Configure Socket.io real-time APIs\napp.configure(socketio());\n\n// Upload Service\napp.use('/uploads', blobService({Model: blobStorage}));\n\n// Register a nicer error handler than the default Express one\napp.use(express.errorHandler());\n\n// Start the server\napp.listen(3030, function(){\n    console.log('Feathers app started at localhost:3030')\n});\n```\n\nLet's look at this implemented in the `@feathersjs/cli` generated server code:\n\n```javascript\n/* --- /src/services/uploads/uploads.service.js --- */\n\n// Initializes the `uploads` service on path `/uploads'\n\nconst createModel = require('../../models/uploads.model');\nconst hooks = require('./uploads.hooks');\nconst filters = require('./uploads.filters');\n\n// feathers-blob service\nconst blobService = require('feathers-blob');\n// Here we initialize a FileSystem storage,\n// but you can use feathers-blob with any other\n// storage service like AWS or Google Drive.\nconst fs = require('fs-blob-store');\n\n// File storage location. Folder must be created before upload.\n// Example: './uploads' will be located under feathers app top level.\nconst blobStorage = fs('./uploads');\n\nmodule.exports = function() {\n  const app = this;\n  const Model = createModel(app);\n  const paginate = app.get('paginate');\n\n  // Initialize our service with any options it requires\n  app.use('/uploads', blobService({ Model: blobStorage}));\n\n  // Get our initialized service so that we can register hooks and filters\n  const service = app.service('uploads');\n\n  service.hooks(hooks);\n\n  if (service.filter) {\n    service.filter(filters);\n  }\n};\n```\n\n`feathers-blob` works over abstract-blob-store, which is an abstract interface to various storage backends, such as filesystem, AWS, or Google Drive. It only accepts and retrieves files encoded as dataURI strings.\n\nJust like that we have our backend ready, go ahead and POST something to localhost:3030/uploads`, for example with postman:\n\n```json\n{\n    'uri': 'data:image/gif;base64,R0lGODlhEwATAPcAAP/+//7/////+////fvzYvryYvvzZ/fxg/zxWfvxW/zwXPrtW/vxXvfrXv3xYvrvYvntYvnvY/ruZPrwZPfsZPjsZfjtZvfsZvHmY/zxavftaPrvavjuafzxbfnua/jta/ftbP3yb/zzcPvwb/zzcfvxcfzxc/3zdf3zdv70efvwd/rwd/vwefftd/3yfPvxfP70f/zzfvnwffvzf/rxf/rxgPjvgPjvgfnwhPvzhvjvhv71jfz0kPrykvz0mv72nvblTPnnUPjoUPrpUvnnUfnpUvXlUfnpU/npVPnqVPfnU/3uVvvsWPfpVvnqWfrrXPLiW/nrX/vtYv7xavrta/Hlcvnuf/Pphvbsif3zk/zzlPzylfjuk/z0o/LqnvbhSPbhSfjiS/jlS/jjTPfhTfjlTubUU+/iiPPokfrvl/Dll/ftovLWPfHXPvHZP/PbQ/bcRuDJP/PaRvjgSffdSe3ddu7fge7fi+zkuO7NMvPTOt2/Nu7SO+3OO/PWQdnGbOneqeneqvDqyu3JMuvJMu7KNfHNON7GZdnEbejanObXnOW8JOa9KOvCLOnBK9+4Ku3FL9ayKuzEMcenK9e+XODOiePSkODOkOW3ItisI9yxL+a9NtGiHr+VH5h5JsSfNM2bGN6rMJt4JMOYL5h4JZl5Jph3Jpl4J5h5J5h3KJl4KZp5Ks+sUN7Gi96lLL+PKMmbMZt2Jpp3Jpt3KZl4K7qFFdyiKdufKsedRdm7feOpQN2QKMKENrpvJbFfIrNjJL1mLMBpLr9oLrFhK69bJFkpE1kpFYNeTqFEIlsoFbmlnlsmFFwpGFkoF/////7+/v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAANAALAAAAAATABMAAAj/AKEJHCgokKJKlhThGciQYSIva7r8SHPFzqGGAwPd4bKlh5YsPKy0qFLnT0NAaHTcsIHDho0aKkaAwGCGEkM1NmSkIjWLBosVJT6cOjUrzsBKPl54KmYsACoTMmk1WwaA1CRoeM7siJEqmTIAsjp40ICK2bEApfZcsoQlxwxRzgI8W8XhgoVYA+Kq6sMK0QEYKVCUkoVqQwQJFTwFEAAAFZ9PlFy4OEEiRIYJD55EodDA1ClTbPp0okRFxBQDBRgskAKhiRMlc+Sw4SNpFCIoBBwkUMBkCBIiY8qAgcPG0KBHrBTFQbCEV5EjQYQACfNFjp5CgxpxagVtUhIjwzaJYSHzhQ4cP3ryQHLEqJbASnu+6EIW6o2b2X0ISXK0CFSugazs0YYmwQhziyuE2PLLIv3h0hArkRhiCCzAENOLL7tgAoqDGLXSSSaPMLIIJpmAUst/GA3UCiuv1PIKLtw1FBAAOw=='\n}\n```\n\nThe service will respond with something like this:\n\n```json\n{\n  'id': '6454364d8facd7a88e627e4c4b11b032d2f83af8f7f9329ffc2b7a5c879dc838.gif',\n  'uri': 'the-same-uri-we-uploaded',\n  'size': 1156\n}\n```\n\nOr we can implement a very basic frontend with `feathers-client` and `jQuery`:\n\n```html\n<!doctype html>\n<html>\n    <head>\n        <title>Feathersjs File Upload</title>\n        <script   src='https://code.jquery.com/jquery-2.2.3.min.js'   integrity='sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo='   crossorigin='anonymous'></script>\n        <script type='text/javascript' src='//cdnjs.cloudflare.com/ajax/libs/core-js/2.1.4/core.min.js'></script>\n        <script type='text/javascript' src='//unpkg.com/feathers-client@^2.0.0/dist/feathers.js'></script>\n        <script type='text/javascript'>\n            // feathers client initialization\n            const rest = feathers.rest('http://localhost:3030');\n            const app = feathers()\n            .configure(feathers.hooks())\n            .configure(rest.jquery($));\n\n            // setup jQuery to watch the ajax progress\n            $.ajaxSetup({\n                xhr: function () {\n                    var xhr = new window.XMLHttpRequest();\n                    // upload progress\n                    xhr.addEventListener('progress', function (evt) {\n                        if (evt.lengthComputable) {\n                            var percentComplete = evt.loaded / evt.total;\n                            console.log('upload progress: ', Math.round(percentComplete * 100) + '%');\n                        }\n                    }, false);\n                    return xhr;\n                }\n            });\n\n            const uploadService = app.service('uploads');\n            const reader  = new FileReader();\n\n            // encode selected files\n            $(document).ready(function(){\n                $('input#file').change(function(){\n                    var file = this.files[0];\n                    // encode dataURI\n                    reader.readAsDataURL(file);\n                })\n            });\n\n            // when encoded, upload\n            reader.addEventListener('load', function () {\n                console.log('encoded file: ', reader.result);\n                var upload = uploadService\n                    .create({uri: reader.result})\n                    .then(function(response){\n                        // success\n                        alert('UPLOADED!! ');\n                        console.log('Server responded with: ', response);\n                    });\n            }, false);\n        </script>\n    </head>\n    <body>\n        <h1>Let's upload some files!</h1>\n        <input type='file' id='file'/>\n    </body>\n</html>\n\n```\n\nThis code watches for file selection, then encodes it and does an ajax post to upload it, watching the upload progress via the xhr object. Everything works as expected.\n\nEvery file we select gets uploaded and saved to the `./uploads` directory.\n\nWork done!, let's call it a day, shall we?\n\n... But hey, there is something that doesn't feel quite right ...right?\n\n### DataURI upload problems\n\nIt doesn't feel right because it is not. Let's imagine what would happen if we try to upload a large file, say 25MB or more: The entire file (plus some extra MB due to the encoding) has to be kept in memory for the entire upload process, this could look like nothing for a normal computer but for mobile devices it's a big deal.\n\nWe have a big RAM consumption problem. Not to mention we have to encode the file before sending it...\n\nThe solution would be to modify the service, adding support for splitting the dataURI into small chunks, then uploading one at a time, collecting and reassembling everything on the server. But hey, it's not that the same thing   browsers and web servers have been doing since maybe the very early days of the web?  Maybe since Netscape Navigator?\n\nWell, actually it is, and doing a `multipart/form-data` post is still the easiest way to upload a file.\n\n## Feathers-blob with multipart support.\n\nBack with the backend, in order to accept multipart uploads, we need a way to handle the `multipart/form-data` received by the web server. Given that Feathers behaves like Express, let's just use `multer` and a custom middleware to handle that.\n\n``` javascript\n/* --- server.js --- */\nconst multer = require('multer');\nconst multipartMiddleware = multer();\n\n// Upload Service with multipart support\napp.use('/uploads',\n\n    // multer parses the file named 'uri'.\n    // Without extra params the data is\n    // temporarely kept in memory\n    multipartMiddleware.single('uri'),\n\n    // another middleware, this time to\n    // transfer the received file to feathers\n    function(req,res,next){\n        req.feathers.file = req.file;\n        next();\n    },\n    blobService({Model: blobStorage})\n);\n```\n\nNotice we kept the file field name as *uri* just to maintain uniformity, as the service will always work with that name anyways, but you can change it if you prefer.\n\nFeathers-blob only understands files encoded as dataURI, so we need to convert them first. Let's make a Hook for that:\n\n```javascript\n/* --- server.js --- */\nconst dauria = require('dauria');\n\n// before-create Hook to get the file (if there is any)\n// and turn it into a datauri,\n// transparently getting feathers-blob to work\n// with multipart file uploads\napp.service('/uploads').before({\n    create: [\n        function(context) {\n            if (!context.data.uri && context.params.file){\n                const file = context.params.file;\n                const uri = dauria.getBase64DataURI(file.buffer, file.mimetype);\n                context.data = {uri: uri};\n            }\n        }\n    ]\n});\n```\n\n*Et voilÃ !*. Now we have a FeathersJS file storage service working, with support for traditional multipart uploads, and a variety of storage options to choose.\n\n**Simply awesome.**\n\n## Further improvements\n\nThe service always returns the dataURI back to us, which may not be necessary as we just uploaded the file. We also need to validate the file and check for authorization.\n\nAll those things can be easily done with more Hooks, and that's the benefit of keeping all inside FeathersJS services. I leave that to you.\n\nFor the frontend, there is a problem with the client: in order to show the upload progress it's stuck with only REST functionality and not real-time with socket.io.\n\nThe solution is to switch `feathers-client` from REST to `socket.io`, and just use wherever you like for uploading the files, that's an easy task now that we are able to do a traditional `form-multipart` upload.\n\nHere is an example using dropzone:\n\n```html\n<!doctype html>\n<html>\n    <head>\n        <title>Feathersjs File Upload</title>\n\n        <link rel='stylesheet' href='assets/dropzone.css'>\n        <script src='assets/dropzone.js'></script>\n\n        <script type='text/javascript' src='socket.io/socket.io.js'></script>\n        <script type='text/javascript' src='//cdnjs.cloudflare.com/ajax/libs/core-js/2.1.4/core.min.js'></script>\n        <script type='text/javascript' src='//unpkg.com/feathers-client@^2.0.0/dist/feathers.js'></script>\n        <script type='text/javascript'>\n            // feathers client initialization\n            var socket = io('http://localhost:3030');\n            const app = feathers()\n            .configure(feathers.hooks())\n            .configure(feathers.socketio(socket));\n            const uploadService = app.service('uploads');\n\n            // Now with Real-Time Support!\n            uploadService.on('created', function(file){\n                alert('Received file created event!', file);\n            });\n\n            // Let's use DropZone!\n            Dropzone.options.myAwesomeDropzone = {\n                paramName: 'uri',\n                uploadMultiple: false,\n                init: function(){\n                    this.on('uploadprogress', function(file, progress){\n                        console.log('progresss', progress);\n                    });\n                }\n            };\n        </script>\n    </head>\n    <body>\n        <h1>Let's upload some files!</h1>\n        <form action='/uploads'\n          class='dropzone'\n          id='my-awesome-dropzone'></form>\n    </body>\n</html>\n```\n\nAll the code is available via github here: https://github.com/CianCoders/feathers-example-fileupload\n\nHope you have learned something today, as I learned a lot writing this.\n\nCheers!",
    "rawContent": "## Our Goals\n\nWe want to implement an upload service to accomplish a few important things:\n\n1. It has to handle large files (+10MB).\n2. It needs to work with the app's authentication and authorization.\n3. The files need to be validated.\n4. At the moment there is no third party storage service involved, but this will change in the near future, so it has to be prepared.\n5. It has to show the upload progress.\n\nThe plan is to upload the files to a feathers service so we can take advantage of hooks for authentication, authorization and validation, and for service events.\n\nFortunately, there exists a file storage service: [feathers-blob](https://github.com/feathersjs/feathers-blob). With it we can meet our goals, but (spoiler alert) it isn't an ideal solution.  We discuss some of its problems below.\n\n## Basic upload with feathers-blob and feathers-client\n\nFor the sake of simplicity, we will be working over a very basic feathers server, with just the upload service.\n\nLets look at the server code:\n\n```javascript\n/* --- server.js --- */\n\nconst feathers = require('@feathersjs/feathers');\nconst express = require('@feathersjs/express');\nconst socketio = require('@feathersjs/socketio');\n\n// feathers-blob service\nconst blobService = require('feathers-blob');\n// Here we initialize a FileSystem storage,\n// but you can use feathers-blob with any other\n// storage service like AWS or Google Drive.\nconst fs = require('fs-blob-store');\nconst blobStorage = fs(__dirname + '/uploads');\n\n// Feathers app\nconst app = express(feathers());\n\n// Parse HTTP JSON bodies\napp.use(express.json());\n// Parse URL-encoded params\napp.use(express.urlencoded({ extended: true }));\n// Add REST API support\napp.configure(express.rest());\n// Configure Socket.io real-time APIs\napp.configure(socketio());\n\n// Upload Service\napp.use('/uploads', blobService({Model: blobStorage}));\n\n// Register a nicer error handler than the default Express one\napp.use(express.errorHandler());\n\n// Start the server\napp.listen(3030, function(){\n    console.log('Feathers app started at localhost:3030')\n});\n```\n\nLet's look at this implemented in the `@feathersjs/cli` generated server code:\n\n```javascript\n/* --- /src/services/uploads/uploads.service.js --- */\n\n// Initializes the `uploads` service on path `/uploads'\n\nconst createModel = require('../../models/uploads.model');\nconst hooks = require('./uploads.hooks');\nconst filters = require('./uploads.filters');\n\n// feathers-blob service\nconst blobService = require('feathers-blob');\n// Here we initialize a FileSystem storage,\n// but you can use feathers-blob with any other\n// storage service like AWS or Google Drive.\nconst fs = require('fs-blob-store');\n\n// File storage location. Folder must be created before upload.\n// Example: './uploads' will be located under feathers app top level.\nconst blobStorage = fs('./uploads');\n\nmodule.exports = function() {\n  const app = this;\n  const Model = createModel(app);\n  const paginate = app.get('paginate');\n\n  // Initialize our service with any options it requires\n  app.use('/uploads', blobService({ Model: blobStorage}));\n\n  // Get our initialized service so that we can register hooks and filters\n  const service = app.service('uploads');\n\n  service.hooks(hooks);\n\n  if (service.filter) {\n    service.filter(filters);\n  }\n};\n```\n\n`feathers-blob` works over abstract-blob-store, which is an abstract interface to various storage backends, such as filesystem, AWS, or Google Drive. It only accepts and retrieves files encoded as dataURI strings.\n\nJust like that we have our backend ready, go ahead and POST something to localhost:3030/uploads`, for example with postman:\n\n```json\n{\n    'uri': 'data:image/gif;base64,R0lGODlhEwATAPcAAP/+//7/////+////fvzYvryYvvzZ/fxg/zxWfvxW/zwXPrtW/vxXvfrXv3xYvrvYvntYvnvY/ruZPrwZPfsZPjsZfjtZvfsZvHmY/zxavftaPrvavjuafzxbfnua/jta/ftbP3yb/zzcPvwb/zzcfvxcfzxc/3zdf3zdv70efvwd/rwd/vwefftd/3yfPvxfP70f/zzfvnwffvzf/rxf/rxgPjvgPjvgfnwhPvzhvjvhv71jfz0kPrykvz0mv72nvblTPnnUPjoUPrpUvnnUfnpUvXlUfnpU/npVPnqVPfnU/3uVvvsWPfpVvnqWfrrXPLiW/nrX/vtYv7xavrta/Hlcvnuf/Pphvbsif3zk/zzlPzylfjuk/z0o/LqnvbhSPbhSfjiS/jlS/jjTPfhTfjlTubUU+/iiPPokfrvl/Dll/ftovLWPfHXPvHZP/PbQ/bcRuDJP/PaRvjgSffdSe3ddu7fge7fi+zkuO7NMvPTOt2/Nu7SO+3OO/PWQdnGbOneqeneqvDqyu3JMuvJMu7KNfHNON7GZdnEbejanObXnOW8JOa9KOvCLOnBK9+4Ku3FL9ayKuzEMcenK9e+XODOiePSkODOkOW3ItisI9yxL+a9NtGiHr+VH5h5JsSfNM2bGN6rMJt4JMOYL5h4JZl5Jph3Jpl4J5h5J5h3KJl4KZp5Ks+sUN7Gi96lLL+PKMmbMZt2Jpp3Jpt3KZl4K7qFFdyiKdufKsedRdm7feOpQN2QKMKENrpvJbFfIrNjJL1mLMBpLr9oLrFhK69bJFkpE1kpFYNeTqFEIlsoFbmlnlsmFFwpGFkoF/////7+/v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAANAALAAAAAATABMAAAj/AKEJHCgokKJKlhThGciQYSIva7r8SHPFzqGGAwPd4bKlh5YsPKy0qFLnT0NAaHTcsIHDho0aKkaAwGCGEkM1NmSkIjWLBosVJT6cOjUrzsBKPl54KmYsACoTMmk1WwaA1CRoeM7siJEqmTIAsjp40ICK2bEApfZcsoQlxwxRzgI8W8XhgoVYA+Kq6sMK0QEYKVCUkoVqQwQJFTwFEAAAFZ9PlFy4OEEiRIYJD55EodDA1ClTbPp0okRFxBQDBRgskAKhiRMlc+Sw4SNpFCIoBBwkUMBkCBIiY8qAgcPG0KBHrBTFQbCEV5EjQYQACfNFjp5CgxpxagVtUhIjwzaJYSHzhQ4cP3ryQHLEqJbASnu+6EIW6o2b2X0ISXK0CFSugazs0YYmwQhziyuE2PLLIv3h0hArkRhiCCzAENOLL7tgAoqDGLXSSSaPMLIIJpmAUst/GA3UCiuv1PIKLtw1FBAAOw=='\n}\n```\n\nThe service will respond with something like this:\n\n```json\n{\n  'id': '6454364d8facd7a88e627e4c4b11b032d2f83af8f7f9329ffc2b7a5c879dc838.gif',\n  'uri': 'the-same-uri-we-uploaded',\n  'size': 1156\n}\n```\n\nOr we can implement a very basic frontend with `feathers-client` and `jQuery`:\n\n```html\n<!doctype html>\n<html>\n    <head>\n        <title>Feathersjs File Upload</title>\n        <script   src='https://code.jquery.com/jquery-2.2.3.min.js'   integrity='sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo='   crossorigin='anonymous'></script>\n        <script type='text/javascript' src='//cdnjs.cloudflare.com/ajax/libs/core-js/2.1.4/core.min.js'></script>\n        <script type='text/javascript' src='//unpkg.com/feathers-client@^2.0.0/dist/feathers.js'></script>\n        <script type='text/javascript'>\n            // feathers client initialization\n            const rest = feathers.rest('http://localhost:3030');\n            const app = feathers()\n            .configure(feathers.hooks())\n            .configure(rest.jquery($));\n\n            // setup jQuery to watch the ajax progress\n            $.ajaxSetup({\n                xhr: function () {\n                    var xhr = new window.XMLHttpRequest();\n                    // upload progress\n                    xhr.addEventListener('progress', function (evt) {\n                        if (evt.lengthComputable) {\n                            var percentComplete = evt.loaded / evt.total;\n                            console.log('upload progress: ', Math.round(percentComplete * 100) + '%');\n                        }\n                    }, false);\n                    return xhr;\n                }\n            });\n\n            const uploadService = app.service('uploads');\n            const reader  = new FileReader();\n\n            // encode selected files\n            $(document).ready(function(){\n                $('input#file').change(function(){\n                    var file = this.files[0];\n                    // encode dataURI\n                    reader.readAsDataURL(file);\n                })\n            });\n\n            // when encoded, upload\n            reader.addEventListener('load', function () {\n                console.log('encoded file: ', reader.result);\n                var upload = uploadService\n                    .create({uri: reader.result})\n                    .then(function(response){\n                        // success\n                        alert('UPLOADED!! ');\n                        console.log('Server responded with: ', response);\n                    });\n            }, false);\n        </script>\n    </head>\n    <body>\n        <h1>Let's upload some files!</h1>\n        <input type='file' id='file'/>\n    </body>\n</html>\n\n```\n\nThis code watches for file selection, then encodes it and does an ajax post to upload it, watching the upload progress via the xhr object. Everything works as expected.\n\nEvery file we select gets uploaded and saved to the `./uploads` directory.\n\nWork done!, let's call it a day, shall we?\n\n... But hey, there is something that doesn't feel quite right ...right?\n\n### DataURI upload problems\n\nIt doesn't feel right because it is not. Let's imagine what would happen if we try to upload a large file, say 25MB or more: The entire file (plus some extra MB due to the encoding) has to be kept in memory for the entire upload process, this could look like nothing for a normal computer but for mobile devices it's a big deal.\n\nWe have a big RAM consumption problem. Not to mention we have to encode the file before sending it...\n\nThe solution would be to modify the service, adding support for splitting the dataURI into small chunks, then uploading one at a time, collecting and reassembling everything on the server. But hey, it's not that the same thing   browsers and web servers have been doing since maybe the very early days of the web?  Maybe since Netscape Navigator?\n\nWell, actually it is, and doing a `multipart/form-data` post is still the easiest way to upload a file.\n\n## Feathers-blob with multipart support.\n\nBack with the backend, in order to accept multipart uploads, we need a way to handle the `multipart/form-data` received by the web server. Given that Feathers behaves like Express, let's just use `multer` and a custom middleware to handle that.\n\n``` javascript\n/* --- server.js --- */\nconst multer = require('multer');\nconst multipartMiddleware = multer();\n\n// Upload Service with multipart support\napp.use('/uploads',\n\n    // multer parses the file named 'uri'.\n    // Without extra params the data is\n    // temporarely kept in memory\n    multipartMiddleware.single('uri'),\n\n    // another middleware, this time to\n    // transfer the received file to feathers\n    function(req,res,next){\n        req.feathers.file = req.file;\n        next();\n    },\n    blobService({Model: blobStorage})\n);\n```\n\nNotice we kept the file field name as *uri* just to maintain uniformity, as the service will always work with that name anyways, but you can change it if you prefer.\n\nFeathers-blob only understands files encoded as dataURI, so we need to convert them first. Let's make a Hook for that:\n\n```javascript\n/* --- server.js --- */\nconst dauria = require('dauria');\n\n// before-create Hook to get the file (if there is any)\n// and turn it into a datauri,\n// transparently getting feathers-blob to work\n// with multipart file uploads\napp.service('/uploads').before({\n    create: [\n        function(context) {\n            if (!context.data.uri && context.params.file){\n                const file = context.params.file;\n                const uri = dauria.getBase64DataURI(file.buffer, file.mimetype);\n                context.data = {uri: uri};\n            }\n        }\n    ]\n});\n```\n\n*Et voilÃ !*. Now we have a FeathersJS file storage service working, with support for traditional multipart uploads, and a variety of storage options to choose.\n\n**Simply awesome.**\n\n## Further improvements\n\nThe service always returns the dataURI back to us, which may not be necessary as we just uploaded the file. We also need to validate the file and check for authorization.\n\nAll those things can be easily done with more Hooks, and that's the benefit of keeping all inside FeathersJS services. I leave that to you.\n\nFor the frontend, there is a problem with the client: in order to show the upload progress it's stuck with only REST functionality and not real-time with socket.io.\n\nThe solution is to switch `feathers-client` from REST to `socket.io`, and just use wherever you like for uploading the files, that's an easy task now that we are able to do a traditional `form-multipart` upload.\n\nHere is an example using dropzone:\n\n```html\n<!doctype html>\n<html>\n    <head>\n        <title>Feathersjs File Upload</title>\n\n        <link rel='stylesheet' href='assets/dropzone.css'>\n        <script src='assets/dropzone.js'></script>\n\n        <script type='text/javascript' src='socket.io/socket.io.js'></script>\n        <script type='text/javascript' src='//cdnjs.cloudflare.com/ajax/libs/core-js/2.1.4/core.min.js'></script>\n        <script type='text/javascript' src='//unpkg.com/feathers-client@^2.0.0/dist/feathers.js'></script>\n        <script type='text/javascript'>\n            // feathers client initialization\n            var socket = io('http://localhost:3030');\n            const app = feathers()\n            .configure(feathers.hooks())\n            .configure(feathers.socketio(socket));\n            const uploadService = app.service('uploads');\n\n            // Now with Real-Time Support!\n            uploadService.on('created', function(file){\n                alert('Received file created event!', file);\n            });\n\n            // Let's use DropZone!\n            Dropzone.options.myAwesomeDropzone = {\n                paramName: 'uri',\n                uploadMultiple: false,\n                init: function(){\n                    this.on('uploadprogress', function(file, progress){\n                        console.log('progresss', progress);\n                    });\n                }\n            };\n        </script>\n    </head>\n    <body>\n        <h1>Let's upload some files!</h1>\n        <form action='/uploads'\n          class='dropzone'\n          id='my-awesome-dropzone'></form>\n    </body>\n</html>\n```\n\nAll the code is available via github here: https://github.com/CianCoders/feathers-example-fileupload\n\nHope you have learned something today, as I learned a lot writing this.\n\nCheers!",
    "breadcrumb": "File uploads in FeathersJS",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/express/file-uploading.md",
    "heading": "File uploads in FeathersJS",
    "subHeadings": [
      "Our Goals",
      "Basic upload with feathers-blob and feathers-client",
      "DataURI upload problems",
      "Feathers-blob with multipart support.",
      "Further improvements"
    ],
    "hasCode": true,
    "codeLanguages": [
      "javascript",
      "text",
      "json",
      "html"
    ],
    "tokens": 3413,
    "category": "cookbook",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "authentication",
      "authorization",
      "validation",
      "real-time",
      "events",
      "rest",
      "get",
      "create",
      "feathers client",
      "socket.io",
      "middleware",
      "setup"
    ]
  },
  {
    "id": "v6-view-engine-0",
    "content": "# Server Side Rendering\nBreadcrumb: Server Side Rendering\nCovers: Rendering views from services | Using authentication\nTopics: hooks, services, context, params, provider, authentication, authorization, jwt, adapter, events, rest, find, get, create, update, remove, middleware\n\n## Rendering views from services\n\nYou probably already know that when you register a Feathers service, Feathers creates RESTful endpoints for that service automatically. Well, really those are just Express routes, so you can define your own as well.\n\n> **ProTip:** Your own defined REST endpoints won't work with hooks and won't emit socket events. If you find you need that functionality it's probably better for you to turn your endpoints into a minimal Feathers service.\n\nLet's say you want to render a list of messages from most recent to oldest using the [Pug](https://pugjs.org/) template engine.\n\n```js\n// You've set up your main Feathers app already\n\n// Register your view engine\napp.set('view engine', 'pug');\n\n// Register your message service\napp.use('/api/messages', memory());\n\n// Inside your main Feathers app\napp.get('/messages', function(req, res, next){\n  // You namespace your feathers service routes so that\n  // don't get route conflicts and have nice URLs.\n  app.service('api/messages')\n    .find({ query: {$sort: { updatedAt: -1 } } })\n    .then(result => res.render('message-list', result.data))\n    .catch(next);\n});\n```\n\nSimple right? We've now rendered a list of messages using the `/views/message-list.pug` view template. All your hooks will get triggered just like they would normally so you can use hooks to pre-filter your data and keep your template rendering routes super tight. See [Using Template Engines with Express](https://expressjs.com/en/guide/using-template-engines.html) for more information.\n\n> **ProTip:** If you call a Feathers service \"internally\" (ie. not over sockets or REST) you won't have a `context.params.provider` attribute. This allows you to have hooks only execute when services are called externally vs. from your own code.\n\n## Using authentication\n\nFeathers is by default stateless and does not use any sessions. You already can protect Express endpoints with the [express.authenticate](../../api/express#express-authenticate) middleware, however this will only work when passing the `Authorization` header (usually with a JWT) which a normal browser request does not support.\n\nIn order to render authenticated pages, [express-session](https://www.npmjs.com/package/express-session) can be used to add the authentication information to the (browser) session:\n\n> npm i express-session --save\n\nNow you can add the following to `src/middleware/index.js|ts`:\n\n```js\nconst session = require('express-session');\nconst { authenticate } = require('@feathersjs/express');\n\n// This sets `req.authentication` from the information added to the session\nconst setSessionAuthentication = (req, res, next) => {\n  req.authentication = req.session.authentication;\n  next();\n};\n\nmodule.exports = function (app) {\n  // Initialize Express-session - might have to be configured\n  // with a persisten storage adapter (like Redis)\n  app.use(session({\n    secret: 'session-secret',\n    saveUninitialized: false,\n    resave: true\n  }));\n\n  // An endpoint that you can POST to with `email` and `password` that\n  // will then perform a local user authentication\n  // e.g <form action=\"/login\" method=\"post\"></form>\n  app.post('/login', async (req, res, next) => {\n    try {\n      const { email, password } = req.body;\n      // Run normal local authentication through our service\n      const { accessToken } = await app.service('authentication').create({\n        strategy: 'local',\n        email,\n        password\n      });\n\n      // Register the JWT authentication information on the session\n      req.session.authentication = {\n        strategy: 'jwt',\n        accessToken\n      };\n\n      // Redirect to an authenticated page\n      res.redirect('/hello');\n    } catch (error) {\n      next(error);\n    }\n  });\n\n  // Remove the authentication information from the session to log out\n  app.get('logout', (req, res) => {\n    delete req.session.authentication;\n    res.end('You are now logged out');\n  });\n\n  // Renders an authenticated page or an 401 error page\n  // Always needs `setSessionAuthentication, authenticate('jwt')` middleware first\n  app.get('/hello', setSessionAuthentication, authenticate('jwt'), (req, res) => {\n    res.end(`Authenticated page with user ${req.user.email}`);\n  });\n};\n```",
    "rawContent": "## Rendering views from services\n\nYou probably already know that when you register a Feathers service, Feathers creates RESTful endpoints for that service automatically. Well, really those are just Express routes, so you can define your own as well.\n\n> **ProTip:** Your own defined REST endpoints won't work with hooks and won't emit socket events. If you find you need that functionality it's probably better for you to turn your endpoints into a minimal Feathers service.\n\nLet's say you want to render a list of messages from most recent to oldest using the [Pug](https://pugjs.org/) template engine.\n\n```js\n// You've set up your main Feathers app already\n\n// Register your view engine\napp.set('view engine', 'pug');\n\n// Register your message service\napp.use('/api/messages', memory());\n\n// Inside your main Feathers app\napp.get('/messages', function(req, res, next){\n  // You namespace your feathers service routes so that\n  // don't get route conflicts and have nice URLs.\n  app.service('api/messages')\n    .find({ query: {$sort: { updatedAt: -1 } } })\n    .then(result => res.render('message-list', result.data))\n    .catch(next);\n});\n```\n\nSimple right? We've now rendered a list of messages using the `/views/message-list.pug` view template. All your hooks will get triggered just like they would normally so you can use hooks to pre-filter your data and keep your template rendering routes super tight. See [Using Template Engines with Express](https://expressjs.com/en/guide/using-template-engines.html) for more information.\n\n> **ProTip:** If you call a Feathers service \"internally\" (ie. not over sockets or REST) you won't have a `context.params.provider` attribute. This allows you to have hooks only execute when services are called externally vs. from your own code.\n\n## Using authentication\n\nFeathers is by default stateless and does not use any sessions. You already can protect Express endpoints with the [express.authenticate](../../api/express#express-authenticate) middleware, however this will only work when passing the `Authorization` header (usually with a JWT) which a normal browser request does not support.\n\nIn order to render authenticated pages, [express-session](https://www.npmjs.com/package/express-session) can be used to add the authentication information to the (browser) session:\n\n> npm i express-session --save\n\nNow you can add the following to `src/middleware/index.js|ts`:\n\n```js\nconst session = require('express-session');\nconst { authenticate } = require('@feathersjs/express');\n\n// This sets `req.authentication` from the information added to the session\nconst setSessionAuthentication = (req, res, next) => {\n  req.authentication = req.session.authentication;\n  next();\n};\n\nmodule.exports = function (app) {\n  // Initialize Express-session - might have to be configured\n  // with a persisten storage adapter (like Redis)\n  app.use(session({\n    secret: 'session-secret',\n    saveUninitialized: false,\n    resave: true\n  }));\n\n  // An endpoint that you can POST to with `email` and `password` that\n  // will then perform a local user authentication\n  // e.g <form action=\"/login\" method=\"post\"></form>\n  app.post('/login', async (req, res, next) => {\n    try {\n      const { email, password } = req.body;\n      // Run normal local authentication through our service\n      const { accessToken } = await app.service('authentication').create({\n        strategy: 'local',\n        email,\n        password\n      });\n\n      // Register the JWT authentication information on the session\n      req.session.authentication = {\n        strategy: 'jwt',\n        accessToken\n      };\n\n      // Redirect to an authenticated page\n      res.redirect('/hello');\n    } catch (error) {\n      next(error);\n    }\n  });\n\n  // Remove the authentication information from the session to log out\n  app.get('logout', (req, res) => {\n    delete req.session.authentication;\n    res.end('You are now logged out');\n  });\n\n  // Renders an authenticated page or an 401 error page\n  // Always needs `setSessionAuthentication, authenticate('jwt')` middleware first\n  app.get('/hello', setSessionAuthentication, authenticate('jwt'), (req, res) => {\n    res.end(`Authenticated page with user ${req.user.email}`);\n  });\n};\n```",
    "breadcrumb": "Server Side Rendering",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/express/view-engine.md",
    "heading": "Server Side Rendering",
    "subHeadings": [
      "Rendering views from services",
      "Using authentication"
    ],
    "hasCode": true,
    "codeLanguages": [
      "js",
      "text"
    ],
    "tokens": 1058,
    "category": "cookbook",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "provider",
      "authentication",
      "authorization",
      "jwt",
      "adapter",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "remove",
      "middleware"
    ]
  },
  {
    "id": "v6-client-test-0",
    "content": "# Client/server testing\nBreadcrumb: Client/server testing\n\n",
    "rawContent": "",
    "breadcrumb": "Client/server testing",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/general/client-test.md",
    "heading": "Client/server testing",
    "subHeadings": [],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 0,
    "category": "cookbook",
    "tags": []
  },
  {
    "id": "v6-scaling-0",
    "content": "# Scaling\nBreadcrumb: Scaling\nCovers: Horizontal Scaling | Cluster configuration | Multiple instances\nTopics: provider, events, get, create, update, patch, remove, feathers client, socket.io, application\n\n## Horizontal Scaling\n\nScaling horizontally refers to either:\n\n- setting up a [cluster](https://nodejs.org/api/cluster.html), or\n- adding more machines to support your application\n\nTo achieve high availability, varying combinations of both strategies may be used.\n\n## Cluster configuration\n\n[Cluster](https://nodejs.org/api/cluster.html) support is built into core NodeJS. Since NodeJS is single threaded, clustering allows you to easily distribute application requests among multiple child processes (and multiple threads). Clustering is a good choice when running feathers in a multi-core environment.\n\nBelow is an example of adding clustering to feathers with the `feathers-socketio` provider. By default, websocket connections begin via a handshake of multiple HTTP requests and are upgraded to the websocket protocol. However, when clustering is enabled, the same worker will not process all HTTP requests for a handshake, leading to HTTP 400 errors. To ensure a successful handshake, force a single worker to process the handshake by disabling the http transport and exclusively using the `websocket` transport.\n\n```js\nimport cluster from 'cluster';\nimport feathers from '@feathersjs/feathers';\nimport socketio from '@feathersjs/socketio';\n\nconst CLUSTER_COUNT = 4;\n\nif (cluster.isMaster) {\n  for (let i = 0; i < CLUSTER_COUNT; i++) {\n    cluster.fork();\n  }\n} else {\n  const app = feathers();\n  // ensure the same worker handles websocket connections\n  app.configure(socketio({\n    transports: ['websocket']\n  }));\n  app.listen(4000);\n}\n```\n\nIn your feathers client code, limit the socket.io-client to the `websocket` transport and disable `upgrade`.\n\n```js\nimport feathers from '@feathersjs/client';\nimport socketio from '@feathersjs/socketio-client';\nimport io from 'socket.io-client';\n\nconst app = feathers()\n  .configure(socketio(\n    io('http://api.feathersjs.com', {\n      transports: ['websocket'],\n      upgrade: false\n    })\n  ));\n```\n\n## Multiple instances\n\nWhen running multiple instances of your Feathers application (e.g. on several Heroku Dynos), service events (created, updated, patched, removed and any custom defined events) do not get propagated to other instances for such cases you may want to use: https://github.com/feathersjs-ecosystem/feathers-sync\n\nWhich will use a messaging mechanism to propagate all events to all application instances like redis or RabbitMQ",
    "rawContent": "## Horizontal Scaling\n\nScaling horizontally refers to either:\n\n- setting up a [cluster](https://nodejs.org/api/cluster.html), or\n- adding more machines to support your application\n\nTo achieve high availability, varying combinations of both strategies may be used.\n\n## Cluster configuration\n\n[Cluster](https://nodejs.org/api/cluster.html) support is built into core NodeJS. Since NodeJS is single threaded, clustering allows you to easily distribute application requests among multiple child processes (and multiple threads). Clustering is a good choice when running feathers in a multi-core environment.\n\nBelow is an example of adding clustering to feathers with the `feathers-socketio` provider. By default, websocket connections begin via a handshake of multiple HTTP requests and are upgraded to the websocket protocol. However, when clustering is enabled, the same worker will not process all HTTP requests for a handshake, leading to HTTP 400 errors. To ensure a successful handshake, force a single worker to process the handshake by disabling the http transport and exclusively using the `websocket` transport.\n\n```js\nimport cluster from 'cluster';\nimport feathers from '@feathersjs/feathers';\nimport socketio from '@feathersjs/socketio';\n\nconst CLUSTER_COUNT = 4;\n\nif (cluster.isMaster) {\n  for (let i = 0; i < CLUSTER_COUNT; i++) {\n    cluster.fork();\n  }\n} else {\n  const app = feathers();\n  // ensure the same worker handles websocket connections\n  app.configure(socketio({\n    transports: ['websocket']\n  }));\n  app.listen(4000);\n}\n```\n\nIn your feathers client code, limit the socket.io-client to the `websocket` transport and disable `upgrade`.\n\n```js\nimport feathers from '@feathersjs/client';\nimport socketio from '@feathersjs/socketio-client';\nimport io from 'socket.io-client';\n\nconst app = feathers()\n  .configure(socketio(\n    io('http://api.feathersjs.com', {\n      transports: ['websocket'],\n      upgrade: false\n    })\n  ));\n```\n\n## Multiple instances\n\nWhen running multiple instances of your Feathers application (e.g. on several Heroku Dynos), service events (created, updated, patched, removed and any custom defined events) do not get propagated to other instances for such cases you may want to use: https://github.com/feathersjs-ecosystem/feathers-sync\n\nWhich will use a messaging mechanism to propagate all events to all application instances like redis or RabbitMQ",
    "breadcrumb": "Scaling",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/general/scaling.md",
    "heading": "Scaling",
    "subHeadings": [
      "Horizontal Scaling",
      "Cluster configuration",
      "Multiple instances"
    ],
    "hasCode": true,
    "codeLanguages": [
      "js",
      "text"
    ],
    "tokens": 599,
    "category": "cookbook",
    "tags": [
      "provider",
      "events",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "feathers client",
      "socket.io",
      "application"
    ]
  },
  {
    "id": "v6-index-0",
    "content": "# The Feathers cookbook\nBreadcrumb: The Feathers cookbook\n\n",
    "rawContent": "",
    "breadcrumb": "The Feathers cookbook",
    "version": "v6",
    "sourceFile": "docs/v6_docs/cookbook/index.md",
    "heading": "The Feathers cookbook",
    "subHeadings": [],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 0,
    "category": "cookbook",
    "tags": []
  },
  {
    "id": "v6-index-0",
    "content": "# index\nBreadcrumb: index\n\n",
    "rawContent": "",
    "breadcrumb": "index",
    "version": "v6",
    "sourceFile": "docs/v6_docs/ecosystem/index.md",
    "heading": "index",
    "subHeadings": [],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 0,
    "category": "ecosystem",
    "tags": []
  },
  {
    "id": "v6-authentication-0",
    "content": "# Authentication\nBreadcrumb: Authentication\nCovers: Generating authentication | What's next?\nTopics: services, authentication, setup\n\n## Generating authentication\n\nTo initialize a standard authentication setup we can run\n\n```\nnpx feathers generate authentication\n```\n\nFor the first prompt, let's select GitHub in addition to _Email + Password_ by navigating to it with the arrow down key and then pressing space. All other questions can be answered with the default by pressing enter:\n\n## What's next?\n\nBy running this command we set up a `users` endpoint to register and store users and an `authentication` endpoint to log them in. It also generated everything necessary for a log in via GitHub. \n\nIf you're not familiar with how the authentication process works, don't worry. We'll cover that in the [Logging In](./login) chapter of this guide but first let's look at Feathers [core concepts of services](./services) that our new `users` endpoint already uses.",
    "rawContent": "## Generating authentication\n\nTo initialize a standard authentication setup we can run\n\n```\nnpx feathers generate authentication\n```\n\nFor the first prompt, let's select GitHub in addition to _Email + Password_ by navigating to it with the arrow down key and then pressing space. All other questions can be answered with the default by pressing enter:\n\n## What's next?\n\nBy running this command we set up a `users` endpoint to register and store users and an `authentication` endpoint to log them in. It also generated everything necessary for a log in via GitHub. \n\nIf you're not familiar with how the authentication process works, don't worry. We'll cover that in the [Logging In](./login) chapter of this guide but first let's look at Feathers [core concepts of services](./services) that our new `users` endpoint already uses.",
    "breadcrumb": "Authentication",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/basics/authentication.md",
    "heading": "Authentication",
    "subHeadings": [
      "Generating authentication",
      "What's next?"
    ],
    "hasCode": true,
    "codeLanguages": [
      "text"
    ],
    "tokens": 207,
    "category": "guides",
    "tags": [
      "services",
      "authentication",
      "setup"
    ]
  },
  {
    "id": "v6-generator-0",
    "content": "# Creating an app\nBreadcrumb: Creating an app\nCovers: Generating the application | Running the server and tests | What's next?\nTopics: authentication, database, mongodb, rest, get, create, application\n\n## Generating the application\n\nYou can create a new Feathers application by running `npm create feathers <name>`. To create a new Feathers application called `feathers-chat` we can run:\n\n```sh\nnpm create feathers@latest feathers-chat\n```\n\nIf you never ran the command before you might be asked to confirm the package installation by pressing enter. The `@latest` in the command makes sure that the most recent released version of the CLI is used.\n\n<BlockQuote type=\"warning\">\nSince the generated application is using modern features like ES modules, the Feathers CLI requires __Node 16 or newer__.\n</BlockQuote>\n\nFirst, choose if you want to use JavaScript or TypeScript. When presented with the project name, just hit enter, or enter a name (no spaces). Next, write a short description for your application. Confirm the next questions with the default selection by pressing Enter. If you choose a database other than __SQLite__, make sure it is reachable at the connection string. For following this guide using MongoDB, change the database selection in the dropdown below.\n\n<DatabaseSelect />\n<hr />\n\nOnce you confirm the last prompt, the final selection should look similar to this:\n\n\n<BlockQuote type=\"note\">\n`SQLite` creates an SQL database in a file so we don't need to have a database server running.\n</BlockQuote>\n\nSweet! We generated our first Feathers application in a new folder called `feathers-chat` so we need to go there.\n\n```sh\ncd feathers-chat\n```\n\n<BlockQuote type=\"tip\">\nMost generated files have a page in the [CLI guide](../cli/index) which contains more information about the file and what it does.\n</BlockQuote>\n\n## Running the server and tests\n\nThe server can be started by running\n\n```sh\nnpm run compile\nnpm run migrate\nnpm start\n```\n\nAfter that, you will see the Feathers logo at\n\n```\nhttp://localhost:3030\n```\n\n<BlockQuote type=\"warning\">\nYou can exit the running process by pressing **CTRL + C**\n</BlockQuote>\n\nThe app also comes with a set of basic tests which can be run with\n\n```sh\nnpm test\n```\n\nThere is also a handy development command that restarts the server automatically whenever we make a code change:\n\n```sh\nnpm run dev\n```\n\n<BlockQuote type=\"warning\">\nKeep this command running throughout the rest of this guide so it will reload all our changes automatically.\n</BlockQuote>\n\n## What's next?\n\nIn this chapter, we've created a new Feathers application. To learn more about the generated files and what you can do with the CLI, have a look at the [CLI guide](../cli/index) after finishing the Getting Started guide. In [the next chapter](./authentication) we will set up user authentication.",
    "rawContent": "## Generating the application\n\nYou can create a new Feathers application by running `npm create feathers <name>`. To create a new Feathers application called `feathers-chat` we can run:\n\n```sh\nnpm create feathers@latest feathers-chat\n```\n\nIf you never ran the command before you might be asked to confirm the package installation by pressing enter. The `@latest` in the command makes sure that the most recent released version of the CLI is used.\n\n<BlockQuote type=\"warning\">\nSince the generated application is using modern features like ES modules, the Feathers CLI requires __Node 16 or newer__.\n</BlockQuote>\n\nFirst, choose if you want to use JavaScript or TypeScript. When presented with the project name, just hit enter, or enter a name (no spaces). Next, write a short description for your application. Confirm the next questions with the default selection by pressing Enter. If you choose a database other than __SQLite__, make sure it is reachable at the connection string. For following this guide using MongoDB, change the database selection in the dropdown below.\n\n<DatabaseSelect />\n<hr />\n\nOnce you confirm the last prompt, the final selection should look similar to this:\n\n\n<BlockQuote type=\"note\">\n`SQLite` creates an SQL database in a file so we don't need to have a database server running.\n</BlockQuote>\n\nSweet! We generated our first Feathers application in a new folder called `feathers-chat` so we need to go there.\n\n```sh\ncd feathers-chat\n```\n\n<BlockQuote type=\"tip\">\nMost generated files have a page in the [CLI guide](../cli/index) which contains more information about the file and what it does.\n</BlockQuote>\n\n## Running the server and tests\n\nThe server can be started by running\n\n```sh\nnpm run compile\nnpm run migrate\nnpm start\n```\n\nAfter that, you will see the Feathers logo at\n\n```\nhttp://localhost:3030\n```\n\n<BlockQuote type=\"warning\">\nYou can exit the running process by pressing **CTRL + C**\n</BlockQuote>\n\nThe app also comes with a set of basic tests which can be run with\n\n```sh\nnpm test\n```\n\nThere is also a handy development command that restarts the server automatically whenever we make a code change:\n\n```sh\nnpm run dev\n```\n\n<BlockQuote type=\"warning\">\nKeep this command running throughout the rest of this guide so it will reload all our changes automatically.\n</BlockQuote>\n\n## What's next?\n\nIn this chapter, we've created a new Feathers application. To learn more about the generated files and what you can do with the CLI, have a look at the [CLI guide](../cli/index) after finishing the Getting Started guide. In [the next chapter](./authentication) we will set up user authentication.",
    "breadcrumb": "Creating an app",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/basics/generator.md",
    "heading": "Creating an app",
    "subHeadings": [
      "Generating the application",
      "Running the server and tests",
      "What's next?"
    ],
    "hasCode": true,
    "codeLanguages": [
      "sh",
      "text"
    ],
    "tokens": 658,
    "category": "guides",
    "tags": [
      "authentication",
      "database",
      "mongodb",
      "rest",
      "get",
      "create",
      "application"
    ]
  },
  {
    "id": "v6-hooks-0",
    "content": "# Hooks\nBreadcrumb: Hooks\nCovers: Generating a hook | Hook functions | Hook context | Registering hooks | What's next?\nTopics: hooks, services, context, params, provider, authentication, jwt, schema, resolver, events, rest, find, get, create, update, patch, remove, hook context, hook functions, middleware, application\n\n## Generating a hook\n\nLet's generate a hook that logs the total runtime of a service method to the console.\n\n```sh\nnpx feathers generate hook\n```\n\nWe call our hook `log-runtime` and confirm the type with enter to make it an `around` hook.\n\n\nNow update `src/hooks/log-runtime.ts` as follows:\n\n```ts{2,5-10}\nimport type { HookContext, NextFunction } from '../declarations'\nimport { logger } from '../logger'\n\nexport const logRuntime = async (context: HookContext, next: NextFunction) => {\n  const startTime = Date.now()\n  // Run everything else (other hooks and service call)\n  await next()\n\n  const duration = Date.now() - startTime\n  logger.info(`Calling ${context.method} on ${context.path} took ${duration}ms`)\n}\n\n```\n\nIn this hook, we store the start time and then run all other hooks and the service method by calling `await next()`. After that we can calculate the duration in milliseconds by subtracting the start time from the current time and log the information using the application [logger](../cli/logger).\n\n## Hook functions\n\nA hook function is an `async` function that takes the [hook `context`](#hook-context) and a `next` function as the parameter. If the hook should only run on **error**, **before** or **after** the service method, it does not need a `next` function. However since we need to do both, get the start time before and the end time after, we created an `around` hook.\n\nHooks run in the order they are registered and if a hook function throws an error, all remaining hooks (and the service call if it didn't run yet) will be skipped and the error will be returned.\n\n## Hook context\n\nThe hook `context` is an object which contains information about the service method call. It has read-only and writable properties.\n\nRead-only properties are:\n\n- `context.app` - The Feathers application object. This commonly used to call other services\n- `context.service` - The service object this hook is currently running on\n- `context.path` - The path (name) of the service\n- `context.method` - The name of the service method being called\n- `context.type` - The hook type (around, before, etc)\n\nWriteable properties are:\n\n- `context.params` - The service method call `params`. For external calls, `params` usually contains:\n  - `context.params.query` - The query filter (e.g. from the REST query string) for the service call\n  - `context.params.provider` - The name of the transport the call has been made through. Usually `\"rest\"` or `\"socketio\"`. Will be `undefined` for internal calls.\n  - `context.params.user` - _If authenticated_, the data of the user making the service method call.\n- `context.id` - The `id` of the record if the service method call is a `get`, `remove`, `update` or `patch`\n- `context.data` - The `data` sent by the user in a `create`, `update` and `patch` and custom service method call\n- `context.error` - The error that was thrown (in `error` hooks)\n- `context.result` - The result of the service method call (available after calling `await next()` or in `after` hooks)\n\n<BlockQuote type=\"tip\">\nFor more information about the hook context see the [hooks API documentation](../../api/hooks).\n</BlockQuote>\n\n## Registering hooks\n\nIn a Feathers application, hooks are being registered in the [&lt;servicename&gt;](../cli/service) file. The hook registration object is an object with `{ around, before, after, error }` and a list of hooks per method like `{ all: [], find: [], create: [] }`.\n\nTo log the runtime of our `messages` service calls we can update `src/services/messages/messages.ts` like this:\n\n```ts{20,38}\n// For more information about this file see https://dove.feathersjs.com/guides/cli/service.html\nimport { authenticate } from '@feathersjs/authentication'\n\nimport { hooks as schemaHooks } from '@feathersjs/schema'\n\nimport {\n  messageDataValidator,\n  messagePatchValidator,\n  messageQueryValidator,\n  messageResolver,\n  messageExternalResolver,\n  messageDataResolver,\n  messagePatchResolver,\n  messageQueryResolver\n} from './messages.schema'\n\nimport type { Application } from '../../declarations'\nimport { MessageService, getOptions } from './messages.class'\nimport { messagePath, messageMethods } from './messages.shared'\nimport { logRuntime } from '../../hooks/log-runtime'\n\nexport * from './messages.class'\nexport * from './messages.schema'\n\n// A configure function that registers the service and its hooks via `app.configure`\nexport const message = (app: Application) => {\n  // Register our service on the Feathers application\n  app.use(messagePath, new MessageService(getOptions(app)), {\n    // A list of all methods this service exposes externally\n    methods: messageMethods,\n    // You can add additional custom events to be sent to clients here\n    events: []\n  })\n  // Initialize hooks\n  app.service(messagePath).hooks({\n    around: {\n      all: [\n        logRuntime,\n        authenticate('jwt'),\n        schemaHooks.resolveExternal(messageExternalResolver),\n        schemaHooks.resolveResult(messageResolver)\n      ]\n    },\n    before: {\n      all: [schemaHooks.validateQuery(messageQueryValidator), schemaHooks.resolveQuery(messageQueryResolver)],\n      find: [],\n      get: [],\n      create: [schemaHooks.validateData(messageDataValidator), schemaHooks.resolveData(messageDataResolver)],\n      patch: [schemaHooks.validateData(messagePatchValidator), schemaHooks.resolveData(messagePatchResolver)],\n      remove: []\n    },\n    after: {\n      all: []\n    },\n    error: {\n      all: []\n    }\n  })\n}\n\n// Add this service to the service type index\ndeclare module '../../declarations' {\n  interface ServiceTypes {\n    [messagePath]: MessageService\n  }\n}\n```\n\nNow every time our messages service is accessed successfully, the name, method and runtime will be logged.\n\n<BlockQuote type=\"tip\">\n`all` is a special keyword which means those hooks will run before the method specific hooks. Method specific hooks can be registered based on their name, e.g. to only log the runtime for `find` and `get`:\n\n```ts\napp.service('messages').hooks({\n  around: {\n    all: [authenticate('jwt')],\n    find: [logRuntime],\n    get: [logRuntime]\n  }\n  // ...\n})\n```\n</BlockQuote>\n\n## What's next?\n\nIn this chapter we learned how Feathers hooks can be used as middleware for service method calls without having to change our service. Here we just logged the runtime of a service method to the console but you can imagine that hooks can be useful for many other things like more advanced logging, sending notifications or checking user permissions.\n\nYou may also have noticed above that there are already some hooks like `schemaHooks.validateQuery` or `schemaHooks.resolveResult` registered on our service. This brings us to the next chapter on how to define our data model with [schemas and resolvers](./schemas).",
    "rawContent": "## Generating a hook\n\nLet's generate a hook that logs the total runtime of a service method to the console.\n\n```sh\nnpx feathers generate hook\n```\n\nWe call our hook `log-runtime` and confirm the type with enter to make it an `around` hook.\n\n\nNow update `src/hooks/log-runtime.ts` as follows:\n\n```ts{2,5-10}\nimport type { HookContext, NextFunction } from '../declarations'\nimport { logger } from '../logger'\n\nexport const logRuntime = async (context: HookContext, next: NextFunction) => {\n  const startTime = Date.now()\n  // Run everything else (other hooks and service call)\n  await next()\n\n  const duration = Date.now() - startTime\n  logger.info(`Calling ${context.method} on ${context.path} took ${duration}ms`)\n}\n\n```\n\nIn this hook, we store the start time and then run all other hooks and the service method by calling `await next()`. After that we can calculate the duration in milliseconds by subtracting the start time from the current time and log the information using the application [logger](../cli/logger).\n\n## Hook functions\n\nA hook function is an `async` function that takes the [hook `context`](#hook-context) and a `next` function as the parameter. If the hook should only run on **error**, **before** or **after** the service method, it does not need a `next` function. However since we need to do both, get the start time before and the end time after, we created an `around` hook.\n\nHooks run in the order they are registered and if a hook function throws an error, all remaining hooks (and the service call if it didn't run yet) will be skipped and the error will be returned.\n\n## Hook context\n\nThe hook `context` is an object which contains information about the service method call. It has read-only and writable properties.\n\nRead-only properties are:\n\n- `context.app` - The Feathers application object. This commonly used to call other services\n- `context.service` - The service object this hook is currently running on\n- `context.path` - The path (name) of the service\n- `context.method` - The name of the service method being called\n- `context.type` - The hook type (around, before, etc)\n\nWriteable properties are:\n\n- `context.params` - The service method call `params`. For external calls, `params` usually contains:\n  - `context.params.query` - The query filter (e.g. from the REST query string) for the service call\n  - `context.params.provider` - The name of the transport the call has been made through. Usually `\"rest\"` or `\"socketio\"`. Will be `undefined` for internal calls.\n  - `context.params.user` - _If authenticated_, the data of the user making the service method call.\n- `context.id` - The `id` of the record if the service method call is a `get`, `remove`, `update` or `patch`\n- `context.data` - The `data` sent by the user in a `create`, `update` and `patch` and custom service method call\n- `context.error` - The error that was thrown (in `error` hooks)\n- `context.result` - The result of the service method call (available after calling `await next()` or in `after` hooks)\n\n<BlockQuote type=\"tip\">\nFor more information about the hook context see the [hooks API documentation](../../api/hooks).\n</BlockQuote>\n\n## Registering hooks\n\nIn a Feathers application, hooks are being registered in the [&lt;servicename&gt;](../cli/service) file. The hook registration object is an object with `{ around, before, after, error }` and a list of hooks per method like `{ all: [], find: [], create: [] }`.\n\nTo log the runtime of our `messages` service calls we can update `src/services/messages/messages.ts` like this:\n\n```ts{20,38}\n// For more information about this file see https://dove.feathersjs.com/guides/cli/service.html\nimport { authenticate } from '@feathersjs/authentication'\n\nimport { hooks as schemaHooks } from '@feathersjs/schema'\n\nimport {\n  messageDataValidator,\n  messagePatchValidator,\n  messageQueryValidator,\n  messageResolver,\n  messageExternalResolver,\n  messageDataResolver,\n  messagePatchResolver,\n  messageQueryResolver\n} from './messages.schema'\n\nimport type { Application } from '../../declarations'\nimport { MessageService, getOptions } from './messages.class'\nimport { messagePath, messageMethods } from './messages.shared'\nimport { logRuntime } from '../../hooks/log-runtime'\n\nexport * from './messages.class'\nexport * from './messages.schema'\n\n// A configure function that registers the service and its hooks via `app.configure`\nexport const message = (app: Application) => {\n  // Register our service on the Feathers application\n  app.use(messagePath, new MessageService(getOptions(app)), {\n    // A list of all methods this service exposes externally\n    methods: messageMethods,\n    // You can add additional custom events to be sent to clients here\n    events: []\n  })\n  // Initialize hooks\n  app.service(messagePath).hooks({\n    around: {\n      all: [\n        logRuntime,\n        authenticate('jwt'),\n        schemaHooks.resolveExternal(messageExternalResolver),\n        schemaHooks.resolveResult(messageResolver)\n      ]\n    },\n    before: {\n      all: [schemaHooks.validateQuery(messageQueryValidator), schemaHooks.resolveQuery(messageQueryResolver)],\n      find: [],\n      get: [],\n      create: [schemaHooks.validateData(messageDataValidator), schemaHooks.resolveData(messageDataResolver)],\n      patch: [schemaHooks.validateData(messagePatchValidator), schemaHooks.resolveData(messagePatchResolver)],\n      remove: []\n    },\n    after: {\n      all: []\n    },\n    error: {\n      all: []\n    }\n  })\n}\n\n// Add this service to the service type index\ndeclare module '../../declarations' {\n  interface ServiceTypes {\n    [messagePath]: MessageService\n  }\n}\n```\n\nNow every time our messages service is accessed successfully, the name, method and runtime will be logged.\n\n<BlockQuote type=\"tip\">\n`all` is a special keyword which means those hooks will run before the method specific hooks. Method specific hooks can be registered based on their name, e.g. to only log the runtime for `find` and `get`:\n\n```ts\napp.service('messages').hooks({\n  around: {\n    all: [authenticate('jwt')],\n    find: [logRuntime],\n    get: [logRuntime]\n  }\n  // ...\n})\n```\n</BlockQuote>\n\n## What's next?\n\nIn this chapter we learned how Feathers hooks can be used as middleware for service method calls without having to change our service. Here we just logged the runtime of a service method to the console but you can imagine that hooks can be useful for many other things like more advanced logging, sending notifications or checking user permissions.\n\nYou may also have noticed above that there are already some hooks like `schemaHooks.validateQuery` or `schemaHooks.resolveResult` registered on our service. This brings us to the next chapter on how to define our data model with [schemas and resolvers](./schemas).",
    "breadcrumb": "Hooks",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/basics/hooks.md",
    "heading": "Hooks",
    "subHeadings": [
      "Generating a hook",
      "Hook functions",
      "Hook context",
      "Registering hooks",
      "What's next?"
    ],
    "hasCode": true,
    "codeLanguages": [
      "sh",
      "text",
      "ts"
    ],
    "tokens": 1690,
    "category": "guides",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "provider",
      "authentication",
      "jwt",
      "schema",
      "resolver",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "hook context",
      "hook functions",
      "middleware",
      "application"
    ]
  },
  {
    "id": "v6-login-0",
    "content": "# Logging in\nBreadcrumb: Logging in\nCovers: Registering a user | Logging in | Login with GitHub | What's next?\nTopics: services, params, provider, authentication, authorization, jwt, oauth, database, websockets, rest, find, get, create, update, socket.io, application\n\n## Registering a user\n\nThe HTTP REST API can be used directly to register a new user. We can do this by sending a POST request to `http://localhost:3030/users` with JSON data like this as the body:\n\n```js\n// POST /users\n{\n  \"email\": \"hello@feathersjs.com\",\n  \"password\": \"supersecret\"\n}\n```\n\nTry it:\n\n```sh\ncurl 'http://localhost:3030/users/' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"email\": \"hello@feathersjs.com\", \"password\": \"supersecret\" }'\n```\n\n[![Run in Postman](https://run.pstmn.io/button.svg)](https://app.getpostman.com/run-collection/6bcea48aac6c7494c2ad)\n\n<BlockQuote type=\"note\">\nFor SQL databases, creating a user with the same email address will only work once, then fail since it already exists. With the default database selection, you can reset your database by removing the `feathers-chat.sqlite` file and running `npm run migrate` to initialise it again.\n</BlockQuote>\n\nThis will return something like this:\n\n```json\n{\n  \"id\": 123,\n  \"email\": \"hello@feathersjs.com\",\n  \"avatar\": \"https://s.gravatar.com/avatar/ffe2a09df37d7c646e974a2d2b8d3e03?s=60\"\n}\n```\n\nWhich means our user has been created successfully.\n\n<BlockQuote type=\"note\">\nThe password has been hashed and stored securely in the database but will never be included in an external response.\n</BlockQuote>\n\n## Logging in\n\nBy default, Feathers uses [JSON Web Tokens](https://jwt.io/) for authentication. It is an access token that is issued by the Feathers server for a limited time (one day by default) and needs to be sent with every API request that requires authentication. Usually a token is issued for a specific user. Let's see if we can issue a JWT for the user that we just created.\n\n<BlockQuote type=\"tip\">\nIf you are wondering why Feathers is using JWT for authentication, have a look at [this FAQ](../../help/faq#why-are-you-using-jwt-for-sessions).\n</BlockQuote>\n\nTokens can be created by sending a POST request to the `/authentication` endpoint (which is the same as calling the `create` method on the `authentication` service set up in `src/authentication`) and passing the authentication strategy you want to use along with any other relevant data. To get a JWT for an existing user through a username (email) and password login, we can use the built-in `local` authentication strategy with a request like this:\n\n```js\n// POST /authentication\n{\n  \"strategy\": \"local\",\n  \"email\": \"hello@feathersjs.com\",\n  \"password\": \"supersecret\"\n}\n```\n\nTry it:\n\n```sh\ncurl 'http://localhost:3030/authentication/' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"strategy\": \"local\", \"email\": \"hello@feathersjs.com\", \"password\": \"supersecret\" }'\n```\n\n[![Run in Postman](https://run.pstmn.io/button.svg)](https://app.getpostman.com/run-collection/6bcea48aac6c7494c2ad)\n\nThis will return something like this:\n\n```json\n{\n  \"accessToken\": \"<JWT for this user>\",\n  \"authentication\": {\n    \"strategy\": \"local\"\n  },\n  \"user\": {\n    \"id\": 123,\n    \"email\": \"hello@feathersjs.com\",\n    \"avatar\": \"https://s.gravatar.com/avatar/ffe2a09df37d7c646e974a2d2b8d3e03?s=60\"\n  }\n}\n```\n\nThe `accessToken` can now be used for other REST requests that require authentication by sending the `Authorization: Bearer <accessToken>` HTTP header. For example to create a new message:\n\n```sh\ncurl 'http://localhost:3030/messages/' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer <accessToken>' \\\n  --data-binary '{ \"text\": \"Hello from the console\" }'\n```\n\n<BlockQuote type=\"tip\">\nMake sure to replace the `<accessToken>` in the above request. For more information about the direct usage of the REST API see the [REST client API](../../api/client/rest) and for websockets the [Socket.io client API](../../api/client/socketio).\n</BlockQuote>\n\nThat's pretty neat, but emails and passwords are boring, let's spice things up a bit.\n\n## Login with GitHub\n\nOAuth is an open authentication standard supported by almost every major social platform and what gets us the log in with Facebook, Google, GitHub etc. buttons. From the Feathers perspective, the authentication flow with OAuth is pretty similar. Instead of authenticating with the `local` strategy by sending a username and password, Feathers directs the user to authorize the application with the login provider. If it is successful, Feathers authentication finds or creates the user in the `users` service with the information it got back from the provider and then issues a token for them.\n\nTo allow login with GitHub, we first have to [create a new OAuth application on GitHub](https://github.com/settings/applications/new). You can put anything in the name, homepage and description fields. The callback URL **must** be set to\n\n```sh\nhttp://localhost:3030/oauth/github/callback\n```\n\n\n<BlockQuote type=\"note\">\nYou can find your existing applications in the [GitHub OAuth apps developer settings](https://github.com/settings/developers).\n</BlockQuote>\n\nOnce you've clicked \"Register application\", we need to update our Feathers app configuration with the client id and secret copied from the GitHub application settings.\n\nFind the `authentication` section in `config/default.json` replace the `<Client ID>` and `<Client Secret>` in the `github` section with the proper values:\n\n```js\n{\n  \"authentication\": {\n    \"oauth\": {\n      \"github\": {\n        \"key\": \"<Client ID>\",\n        \"secret\": \"<Client Secret>\"\n      }\n    },\n    // Other authentication configuration is here\n    // ...\n  }\n}\n```\n\n<BlockQuote type=\"note\">\nIn a production environment you would set those values as [custom environment variables](../cli/custom-environment-variables).\n</BlockQuote>\n\nThis tells the OAuth strategy to redirect back to our index page after a successful login and already makes a basic login with GitHub possible. Because of the changes we made in the `users` service in the [services chapter](./services) we do need a small customization though. Instead of only adding `githubId` to a new user when they log in with GitHub we also include their email and the avatar image from the profile we get back. We can do this by extending the standard OAuth strategy and registering it as a GitHub specific one and overwriting the `getEntityData` method:\n\nUpdate `src/authentication.ts` as follows:\n\n```ts{1,5,14-26,33}\nimport type { Params } from '@feathersjs/feathers'\nimport { AuthenticationService, JWTStrategy } from '@feathersjs/authentication'\nimport { LocalStrategy } from '@feathersjs/authentication-local'\nimport { oauth, OAuthStrategy } from '@feathersjs/authentication-oauth'\nimport type { OAuthProfile } from '@feathersjs/authentication-oauth'\nimport type { Application } from './declarations'\n\ndeclare module './declarations' {\n  interface ServiceTypes {\n    authentication: AuthenticationService\n  }\n}\n\nclass GitHubStrategy extends OAuthStrategy {\n  async getEntityData(profile: OAuthProfile, existing: any, params: Params) {\n    const baseData = await super.getEntityData(profile, existing, params)\n\n    return {\n      ...baseData,\n      // The GitHub profile image\n      avatar: profile.avatar_url,\n      // The user email address (if available)\n      email: profile.email || profile.login\n    }\n  }\n}\n\nexport const authentication = (app: Application) => {\n  const authentication = new AuthenticationService(app)\n\n  authentication.register('jwt', new JWTStrategy())\n  authentication.register('local', new LocalStrategy())\n  authentication.register('github', new GitHubStrategy())\n\n  app.use('authentication', authentication)\n  app.configure(oauth())\n}\n```\n\n<BlockQuote type=\"note\">\nFor more information about the OAuth flow and strategy see the [OAuth API documentation](../../api/authentication/oauth).\n</BlockQuote>\n\nTo log in with GitHub, visit\n\n```\nhttp://localhost:3030/oauth/github\n```\n\nIt will redirect to GitHub and ask to authorize our application. If everything went well, we get redirected to our homepage with the Feathers logo with the token information in the location hash. This will be used by the Feathers authentication client to authenticate our user.\n\n## What's next?\n\nSweet! We now have an API that can register new users with email/password and GitHub. This means we have everything we need for a frontend for our chat application. See the [JavaScript frontend guide](../frontend/javascript) on how to create a plain JavaScript chat application.",
    "rawContent": "## Registering a user\n\nThe HTTP REST API can be used directly to register a new user. We can do this by sending a POST request to `http://localhost:3030/users` with JSON data like this as the body:\n\n```js\n// POST /users\n{\n  \"email\": \"hello@feathersjs.com\",\n  \"password\": \"supersecret\"\n}\n```\n\nTry it:\n\n```sh\ncurl 'http://localhost:3030/users/' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"email\": \"hello@feathersjs.com\", \"password\": \"supersecret\" }'\n```\n\n[![Run in Postman](https://run.pstmn.io/button.svg)](https://app.getpostman.com/run-collection/6bcea48aac6c7494c2ad)\n\n<BlockQuote type=\"note\">\nFor SQL databases, creating a user with the same email address will only work once, then fail since it already exists. With the default database selection, you can reset your database by removing the `feathers-chat.sqlite` file and running `npm run migrate` to initialise it again.\n</BlockQuote>\n\nThis will return something like this:\n\n```json\n{\n  \"id\": 123,\n  \"email\": \"hello@feathersjs.com\",\n  \"avatar\": \"https://s.gravatar.com/avatar/ffe2a09df37d7c646e974a2d2b8d3e03?s=60\"\n}\n```\n\nWhich means our user has been created successfully.\n\n<BlockQuote type=\"note\">\nThe password has been hashed and stored securely in the database but will never be included in an external response.\n</BlockQuote>\n\n## Logging in\n\nBy default, Feathers uses [JSON Web Tokens](https://jwt.io/) for authentication. It is an access token that is issued by the Feathers server for a limited time (one day by default) and needs to be sent with every API request that requires authentication. Usually a token is issued for a specific user. Let's see if we can issue a JWT for the user that we just created.\n\n<BlockQuote type=\"tip\">\nIf you are wondering why Feathers is using JWT for authentication, have a look at [this FAQ](../../help/faq#why-are-you-using-jwt-for-sessions).\n</BlockQuote>\n\nTokens can be created by sending a POST request to the `/authentication` endpoint (which is the same as calling the `create` method on the `authentication` service set up in `src/authentication`) and passing the authentication strategy you want to use along with any other relevant data. To get a JWT for an existing user through a username (email) and password login, we can use the built-in `local` authentication strategy with a request like this:\n\n```js\n// POST /authentication\n{\n  \"strategy\": \"local\",\n  \"email\": \"hello@feathersjs.com\",\n  \"password\": \"supersecret\"\n}\n```\n\nTry it:\n\n```sh\ncurl 'http://localhost:3030/authentication/' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"strategy\": \"local\", \"email\": \"hello@feathersjs.com\", \"password\": \"supersecret\" }'\n```\n\n[![Run in Postman](https://run.pstmn.io/button.svg)](https://app.getpostman.com/run-collection/6bcea48aac6c7494c2ad)\n\nThis will return something like this:\n\n```json\n{\n  \"accessToken\": \"<JWT for this user>\",\n  \"authentication\": {\n    \"strategy\": \"local\"\n  },\n  \"user\": {\n    \"id\": 123,\n    \"email\": \"hello@feathersjs.com\",\n    \"avatar\": \"https://s.gravatar.com/avatar/ffe2a09df37d7c646e974a2d2b8d3e03?s=60\"\n  }\n}\n```\n\nThe `accessToken` can now be used for other REST requests that require authentication by sending the `Authorization: Bearer <accessToken>` HTTP header. For example to create a new message:\n\n```sh\ncurl 'http://localhost:3030/messages/' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer <accessToken>' \\\n  --data-binary '{ \"text\": \"Hello from the console\" }'\n```\n\n<BlockQuote type=\"tip\">\nMake sure to replace the `<accessToken>` in the above request. For more information about the direct usage of the REST API see the [REST client API](../../api/client/rest) and for websockets the [Socket.io client API](../../api/client/socketio).\n</BlockQuote>\n\nThat's pretty neat, but emails and passwords are boring, let's spice things up a bit.\n\n## Login with GitHub\n\nOAuth is an open authentication standard supported by almost every major social platform and what gets us the log in with Facebook, Google, GitHub etc. buttons. From the Feathers perspective, the authentication flow with OAuth is pretty similar. Instead of authenticating with the `local` strategy by sending a username and password, Feathers directs the user to authorize the application with the login provider. If it is successful, Feathers authentication finds or creates the user in the `users` service with the information it got back from the provider and then issues a token for them.\n\nTo allow login with GitHub, we first have to [create a new OAuth application on GitHub](https://github.com/settings/applications/new). You can put anything in the name, homepage and description fields. The callback URL **must** be set to\n\n```sh\nhttp://localhost:3030/oauth/github/callback\n```\n\n\n<BlockQuote type=\"note\">\nYou can find your existing applications in the [GitHub OAuth apps developer settings](https://github.com/settings/developers).\n</BlockQuote>\n\nOnce you've clicked \"Register application\", we need to update our Feathers app configuration with the client id and secret copied from the GitHub application settings.\n\nFind the `authentication` section in `config/default.json` replace the `<Client ID>` and `<Client Secret>` in the `github` section with the proper values:\n\n```js\n{\n  \"authentication\": {\n    \"oauth\": {\n      \"github\": {\n        \"key\": \"<Client ID>\",\n        \"secret\": \"<Client Secret>\"\n      }\n    },\n    // Other authentication configuration is here\n    // ...\n  }\n}\n```\n\n<BlockQuote type=\"note\">\nIn a production environment you would set those values as [custom environment variables](../cli/custom-environment-variables).\n</BlockQuote>\n\nThis tells the OAuth strategy to redirect back to our index page after a successful login and already makes a basic login with GitHub possible. Because of the changes we made in the `users` service in the [services chapter](./services) we do need a small customization though. Instead of only adding `githubId` to a new user when they log in with GitHub we also include their email and the avatar image from the profile we get back. We can do this by extending the standard OAuth strategy and registering it as a GitHub specific one and overwriting the `getEntityData` method:\n\nUpdate `src/authentication.ts` as follows:\n\n```ts{1,5,14-26,33}\nimport type { Params } from '@feathersjs/feathers'\nimport { AuthenticationService, JWTStrategy } from '@feathersjs/authentication'\nimport { LocalStrategy } from '@feathersjs/authentication-local'\nimport { oauth, OAuthStrategy } from '@feathersjs/authentication-oauth'\nimport type { OAuthProfile } from '@feathersjs/authentication-oauth'\nimport type { Application } from './declarations'\n\ndeclare module './declarations' {\n  interface ServiceTypes {\n    authentication: AuthenticationService\n  }\n}\n\nclass GitHubStrategy extends OAuthStrategy {\n  async getEntityData(profile: OAuthProfile, existing: any, params: Params) {\n    const baseData = await super.getEntityData(profile, existing, params)\n\n    return {\n      ...baseData,\n      // The GitHub profile image\n      avatar: profile.avatar_url,\n      // The user email address (if available)\n      email: profile.email || profile.login\n    }\n  }\n}\n\nexport const authentication = (app: Application) => {\n  const authentication = new AuthenticationService(app)\n\n  authentication.register('jwt', new JWTStrategy())\n  authentication.register('local', new LocalStrategy())\n  authentication.register('github', new GitHubStrategy())\n\n  app.use('authentication', authentication)\n  app.configure(oauth())\n}\n```\n\n<BlockQuote type=\"note\">\nFor more information about the OAuth flow and strategy see the [OAuth API documentation](../../api/authentication/oauth).\n</BlockQuote>\n\nTo log in with GitHub, visit\n\n```\nhttp://localhost:3030/oauth/github\n```\n\nIt will redirect to GitHub and ask to authorize our application. If everything went well, we get redirected to our homepage with the Feathers logo with the token information in the location hash. This will be used by the Feathers authentication client to authenticate our user.\n\n## What's next?\n\nSweet! We now have an API that can register new users with email/password and GitHub. This means we have everything we need for a frontend for our chat application. See the [JavaScript frontend guide](../frontend/javascript) on how to create a plain JavaScript chat application.",
    "breadcrumb": "Logging in",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/basics/login.md",
    "heading": "Logging in",
    "subHeadings": [
      "Registering a user",
      "Logging in",
      "Login with GitHub",
      "What's next?"
    ],
    "hasCode": true,
    "codeLanguages": [
      "js",
      "text",
      "sh",
      "json",
      "ts"
    ],
    "tokens": 2082,
    "category": "guides",
    "tags": [
      "services",
      "params",
      "provider",
      "authentication",
      "authorization",
      "jwt",
      "oauth",
      "database",
      "websockets",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "socket.io",
      "application"
    ]
  },
  {
    "id": "v6-schemas-0",
    "content": "# Schemas and resolvers\nBreadcrumb: Schemas and resolvers\nCovers: Feathers schemas | Adding a user avatar | Handling messages | Creating a migration | What's next?\nTopics: services, context, params, authentication, schema, resolver, typebox, database, knex, find, get, create, update, patch, remove, migrations, application\n\n## Feathers schemas\n\nWhile schemas and resolvers can be used outside of a Feathers application, you will usually encounter them in a Feathers context where they come in four kinds:\n\n- **Result** schemas and resolvers that define the data that is being returned. This is also where associated data would be fetched\n- **Data** schemas and resolvers handle the data from a `create`, `update`, `patch`, or custom service method and can be used to add/replace things like default or calculated values (e.g. the `createdAt` or `updatedAt` date) before saving it to the database\n- **Query** schemas and resolvers validate and convert the query string and can also be used for additional limitations like only allowing a user to see and modify their own data\n- **External** resolvers return a safe version of the data (by e.g. hiding a users password) that can be sent to external clients\n\nWhile it may initially look like a bit more code, schema driven development is a great way to have the data models and how data is modified in a single place.\n\n## Adding a user avatar\n\nLet's extend our existing users schema to add an `avatar` property so that our users can have a profile image.\n\nFirst we need to update the `src/services/users/users.schema.ts` file with the schema property for the avatar and a resolver property that sets a default avatar using the [Gravatar](https://en.gravatar.com/) based on the email address:\n\n```ts{2,17-18,34,44-54,68,82-86}\n// For more information about this file see https://dove.feathersjs.com/guides/cli/service.schemas.html\nimport crypto from 'crypto'\nimport { resolve } from '@feathersjs/schema'\nimport { Type, getValidator, querySyntax } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\nimport { passwordHash } from '@feathersjs/authentication-local'\n\nimport type { HookContext } from '../../declarations'\nimport { dataValidator, queryValidator } from '../../validators'\n\n// Main data model schema\nexport const userSchema = Type.Object(\n  {\n    id: Type.Number(),\n    email: Type.String(),\n    password: Type.Optional(Type.String()),\n    githubId: Type.Optional(Type.Number()),\n    avatar: Type.Optional(Type.String())\n  },\n  { $id: 'User', additionalProperties: false }\n)\nexport type User = Static<typeof userSchema>\nexport const userValidator = getValidator(userSchema, dataValidator)\nexport const userResolver = resolve<User, HookContext>({})\n\nexport const userExternalResolver = resolve<User, HookContext>({\n  // The password should never be visible externally\n  password: async () => undefined\n})\n\n// Schema for creating new users\nexport const userDataSchema = Type.Pick(\n  userSchema,\n  ['email', 'password', 'githubId', 'avatar'],\n  {\n    $id: 'UserData',\n    additionalProperties: false\n  }\n)\nexport type UserData = Static<typeof userDataSchema>\nexport const userDataValidator = getValidator(userDataSchema, dataValidator)\nexport const userDataResolver = resolve<User, HookContext>({\n  password: passwordHash({ strategy: 'local' }),\n  avatar: async (value, user) => {\n    // If the user passed an avatar image, use it\n    if (value !== undefined) {\n      return value\n    }\n\n    // Gravatar uses MD5 hashes from an email address to get the image\n    const hash = crypto.createHash('md5').update(user.email.toLowerCase()).digest('hex')\n    // Return the full avatar URL\n    return `https://s.gravatar.com/avatar/${hash}?s=60`\n  }\n})\n\n// Schema for updating existing users\nexport const userPatchSchema = Type.Partial(userSchema, {\n  $id: 'UserPatch'\n})\nexport type UserPatch = Static<typeof userPatchSchema>\nexport const userPatchValidator = getValidator(userPatchSchema, dataValidator)\nexport const userPatchResolver = resolve<User, HookContext>({\n  password: passwordHash({ strategy: 'local' })\n})\n\n// Schema for allowed query properties\nexport const userQueryProperties = Type.Pick(userSchema, ['id', 'email', 'githubId'])\nexport const userQuerySchema = Type.Intersect(\n  [\n    querySyntax(userQueryProperties),\n    // Add additional query properties here\n    Type.Object({}, { additionalProperties: false })\n  ],\n  { additionalProperties: false }\n)\nexport type UserQuery = Static<typeof userQuerySchema>\nexport const userQueryValidator = getValidator(userQuerySchema, queryValidator)\nexport const userQueryResolver = resolve<UserQuery, HookContext>({\n  // If there is a user (e.g. with authentication), they are only allowed to see their own data\n  id: async (value, user, context) => {\n    // We want to be able to get a list of all users but\n    // only let a user modify their own data otherwise\n    if (context.params.user && context.method !== 'find') {\n      return context.params.user.id\n    }\n\n    return value\n  }\n})\n```\n\nWhat happened here?\n\n- We are adding an optional `avatar` field to our user object. This is where we store a user image to show in the chat.\n- The `userDataSchema` is updated to include the `avatar` so that a new user can be created with a custom avatar\n- In the `userDataResolver`, if an `avatar` is not set, we set a default image using the [Gravatar avatar](https://en.gravatar.com/) for the email address\n- The `userQueryResolver` for the user id property allows for a user to `find` all other users but only change (`patch`, `remove`) their own data\n\n## Handling messages\n\nNext we can look at the messages service schema. We want to include the date when the message was created as `createdAt` and the id of the user who sent it as `userId`. When we get a message back, we also want to populate the `user` with the user data from `userId` so that we can show their avatar and email.\n\nUpdate the `src/services/messages/messages.schema.ts` file like this:\n\n```ts{2,8,15-17,24-27,39-45,58-61,74-82}\n// For more information about this file see https://dove.feathersjs.com/guides/cli/service.schemas.html\nimport { resolve, virtual } from '@feathersjs/schema'\nimport { Type, getValidator, querySyntax } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\n\nimport type { HookContext } from '../../declarations'\nimport { dataValidator, queryValidator } from '../../validators'\nimport { userSchema } from '../users/users.schema'\n\n// Main data model schema\nexport const messageSchema = Type.Object(\n  {\n    id: Type.Number(),\n    text: Type.String(),\n    createdAt: Type.Number(),\n    userId: Type.Number(),\n    user: Type.Ref(userSchema)\n  },\n  { $id: 'Message', additionalProperties: false }\n)\nexport type Message = Static<typeof messageSchema>\nexport const messageValidator = getValidator(messageSchema, dataValidator)\nexport const messageResolver = resolve<Message, HookContext>({\n  user: virtual(async (message, context) => {\n    // Associate the user that sent the message\n    return context.app.service('users').get(message.userId)\n  })\n})\n\nexport const messageExternalResolver = resolve<Message, HookContext>({})\n\n// Schema for creating new entries\nexport const messageDataSchema = Type.Pick(messageSchema, ['text'], {\n  $id: 'MessageData'\n})\nexport type MessageData = Static<typeof messageDataSchema>\nexport const messageDataValidator = getValidator(messageDataSchema, dataValidator)\nexport const messageDataResolver = resolve<Message, HookContext>({\n  userId: async (_value, _message, context) => {\n    // Associate the record with the id of the authenticated user\n    return context.params.user.id\n  },\n  createdAt: async () => {\n    return Date.now()\n  }\n})\n\n// Schema for updating existing entries\nexport const messagePatchSchema = Type.Partial(messageSchema, {\n  $id: 'MessagePatch'\n})\nexport type MessagePatch = Static<typeof messagePatchSchema>\nexport const messagePatchValidator = getValidator(messagePatchSchema, dataValidator)\nexport const messagePatchResolver = resolve<Message, HookContext>({})\n\n// Schema for allowed query properties\nexport const messageQueryProperties = Type.Pick(messageSchema,[\n  'id',\n  'text',\n  'createdAt',\n  'userId'\n])\nexport const messageQuerySchema = Type.Intersect(\n  [\n    querySyntax(messageQueryProperties),\n    // Add additional query properties here\n    Type.Object({}, { additionalProperties: false })\n  ],\n  { additionalProperties: false }\n)\nexport type MessageQuery = Static<typeof messageQuerySchema>\nexport const messageQueryValidator = getValidator(messageQuerySchema, queryValidator)\nexport const messageQueryResolver = resolve<MessageQuery, HookContext>({\n  userId: async (value, user, context) => {\n    // We want to be able to find all messages but\n    // only let a user modify their own messages otherwise\n    if (context.params.user && context.method !== 'find') {\n      return context.params.user.id\n    }\n\n    return value\n  }\n})\n```\n\n<BlockQuote type=\"note\">\nThe `virtual()` in the `messageResolver` `user` property is a [virtual property](../../api/schema/resolvers#virtual-property-resolvers) and indicates that the value does not come from the messages database table.\n</BlockQuote>\n\n## Creating a migration\n\nNow that our schemas and resolvers have everything we need, we also have to update the database with those changes. For SQL databases this is done with migrations. Migrations are a best practice for SQL databases to roll out and undo changes to the data model. Every change we make in a schema will need its corresponding migration step.\n\nInitially, every database service will automatically add a migration that creates a table for it with an `id` and `text` property. Our users service also already added a migration to add the email and password fields for logging in. The migration for the changes we made in this chapter needs to\n\n- Add the `avatar` string field to the `users` table\n- Add the `createdAt` number field to the `messages` table\n- Add the `userId` number field to the `messages` table and reference it with the `id` in the `users` table\n\nTo create a new migration with the name `chat` run\n\n```\nnpm run migrate:make -- chat\n```\n\nYou should see something like\n\n```\nCreated Migration: /path/to/feathers-chat/migrations/20220622012334_chat.(ts|js)\n```\n\nOpen that file and update it as follows\n\n```ts{4-11,15-22}\nimport type { Knex } from 'knex'\n\nexport async function up(knex: Knex): Promise<void> {\n  await knex.schema.alterTable('users', (table) => {\n    table.string('avatar')\n  })\n\n  await knex.schema.alterTable('messages', (table) => {\n    table.bigint('createdAt')\n    table.bigint('userId').references('id').inTable('users')\n  })\n}\n\nexport async function down(knex: Knex): Promise<void> {\n  await knex.schema.alterTable('users', (table) => {\n    table.dropColumn('avatar')\n  })\n\n  await knex.schema.alterTable('messages', (table) => {\n    table.dropColumn('createdAt')\n    table.dropColumn('userId')\n  })\n}\n```\n\nWe can run the migrations on the current database with\n\n```\nnpm run migrate\n```\n\n## What's next?\n\nIn this chapter we learned about schemas and implemented all the things we need for our chat application. In the next chapter we will learn about [authentication](./authentication) and add a \"Login with GitHub\" button.",
    "rawContent": "## Feathers schemas\n\nWhile schemas and resolvers can be used outside of a Feathers application, you will usually encounter them in a Feathers context where they come in four kinds:\n\n- **Result** schemas and resolvers that define the data that is being returned. This is also where associated data would be fetched\n- **Data** schemas and resolvers handle the data from a `create`, `update`, `patch`, or custom service method and can be used to add/replace things like default or calculated values (e.g. the `createdAt` or `updatedAt` date) before saving it to the database\n- **Query** schemas and resolvers validate and convert the query string and can also be used for additional limitations like only allowing a user to see and modify their own data\n- **External** resolvers return a safe version of the data (by e.g. hiding a users password) that can be sent to external clients\n\nWhile it may initially look like a bit more code, schema driven development is a great way to have the data models and how data is modified in a single place.\n\n## Adding a user avatar\n\nLet's extend our existing users schema to add an `avatar` property so that our users can have a profile image.\n\nFirst we need to update the `src/services/users/users.schema.ts` file with the schema property for the avatar and a resolver property that sets a default avatar using the [Gravatar](https://en.gravatar.com/) based on the email address:\n\n```ts{2,17-18,34,44-54,68,82-86}\n// For more information about this file see https://dove.feathersjs.com/guides/cli/service.schemas.html\nimport crypto from 'crypto'\nimport { resolve } from '@feathersjs/schema'\nimport { Type, getValidator, querySyntax } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\nimport { passwordHash } from '@feathersjs/authentication-local'\n\nimport type { HookContext } from '../../declarations'\nimport { dataValidator, queryValidator } from '../../validators'\n\n// Main data model schema\nexport const userSchema = Type.Object(\n  {\n    id: Type.Number(),\n    email: Type.String(),\n    password: Type.Optional(Type.String()),\n    githubId: Type.Optional(Type.Number()),\n    avatar: Type.Optional(Type.String())\n  },\n  { $id: 'User', additionalProperties: false }\n)\nexport type User = Static<typeof userSchema>\nexport const userValidator = getValidator(userSchema, dataValidator)\nexport const userResolver = resolve<User, HookContext>({})\n\nexport const userExternalResolver = resolve<User, HookContext>({\n  // The password should never be visible externally\n  password: async () => undefined\n})\n\n// Schema for creating new users\nexport const userDataSchema = Type.Pick(\n  userSchema,\n  ['email', 'password', 'githubId', 'avatar'],\n  {\n    $id: 'UserData',\n    additionalProperties: false\n  }\n)\nexport type UserData = Static<typeof userDataSchema>\nexport const userDataValidator = getValidator(userDataSchema, dataValidator)\nexport const userDataResolver = resolve<User, HookContext>({\n  password: passwordHash({ strategy: 'local' }),\n  avatar: async (value, user) => {\n    // If the user passed an avatar image, use it\n    if (value !== undefined) {\n      return value\n    }\n\n    // Gravatar uses MD5 hashes from an email address to get the image\n    const hash = crypto.createHash('md5').update(user.email.toLowerCase()).digest('hex')\n    // Return the full avatar URL\n    return `https://s.gravatar.com/avatar/${hash}?s=60`\n  }\n})\n\n// Schema for updating existing users\nexport const userPatchSchema = Type.Partial(userSchema, {\n  $id: 'UserPatch'\n})\nexport type UserPatch = Static<typeof userPatchSchema>\nexport const userPatchValidator = getValidator(userPatchSchema, dataValidator)\nexport const userPatchResolver = resolve<User, HookContext>({\n  password: passwordHash({ strategy: 'local' })\n})\n\n// Schema for allowed query properties\nexport const userQueryProperties = Type.Pick(userSchema, ['id', 'email', 'githubId'])\nexport const userQuerySchema = Type.Intersect(\n  [\n    querySyntax(userQueryProperties),\n    // Add additional query properties here\n    Type.Object({}, { additionalProperties: false })\n  ],\n  { additionalProperties: false }\n)\nexport type UserQuery = Static<typeof userQuerySchema>\nexport const userQueryValidator = getValidator(userQuerySchema, queryValidator)\nexport const userQueryResolver = resolve<UserQuery, HookContext>({\n  // If there is a user (e.g. with authentication), they are only allowed to see their own data\n  id: async (value, user, context) => {\n    // We want to be able to get a list of all users but\n    // only let a user modify their own data otherwise\n    if (context.params.user && context.method !== 'find') {\n      return context.params.user.id\n    }\n\n    return value\n  }\n})\n```\n\nWhat happened here?\n\n- We are adding an optional `avatar` field to our user object. This is where we store a user image to show in the chat.\n- The `userDataSchema` is updated to include the `avatar` so that a new user can be created with a custom avatar\n- In the `userDataResolver`, if an `avatar` is not set, we set a default image using the [Gravatar avatar](https://en.gravatar.com/) for the email address\n- The `userQueryResolver` for the user id property allows for a user to `find` all other users but only change (`patch`, `remove`) their own data\n\n## Handling messages\n\nNext we can look at the messages service schema. We want to include the date when the message was created as `createdAt` and the id of the user who sent it as `userId`. When we get a message back, we also want to populate the `user` with the user data from `userId` so that we can show their avatar and email.\n\nUpdate the `src/services/messages/messages.schema.ts` file like this:\n\n```ts{2,8,15-17,24-27,39-45,58-61,74-82}\n// For more information about this file see https://dove.feathersjs.com/guides/cli/service.schemas.html\nimport { resolve, virtual } from '@feathersjs/schema'\nimport { Type, getValidator, querySyntax } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\n\nimport type { HookContext } from '../../declarations'\nimport { dataValidator, queryValidator } from '../../validators'\nimport { userSchema } from '../users/users.schema'\n\n// Main data model schema\nexport const messageSchema = Type.Object(\n  {\n    id: Type.Number(),\n    text: Type.String(),\n    createdAt: Type.Number(),\n    userId: Type.Number(),\n    user: Type.Ref(userSchema)\n  },\n  { $id: 'Message', additionalProperties: false }\n)\nexport type Message = Static<typeof messageSchema>\nexport const messageValidator = getValidator(messageSchema, dataValidator)\nexport const messageResolver = resolve<Message, HookContext>({\n  user: virtual(async (message, context) => {\n    // Associate the user that sent the message\n    return context.app.service('users').get(message.userId)\n  })\n})\n\nexport const messageExternalResolver = resolve<Message, HookContext>({})\n\n// Schema for creating new entries\nexport const messageDataSchema = Type.Pick(messageSchema, ['text'], {\n  $id: 'MessageData'\n})\nexport type MessageData = Static<typeof messageDataSchema>\nexport const messageDataValidator = getValidator(messageDataSchema, dataValidator)\nexport const messageDataResolver = resolve<Message, HookContext>({\n  userId: async (_value, _message, context) => {\n    // Associate the record with the id of the authenticated user\n    return context.params.user.id\n  },\n  createdAt: async () => {\n    return Date.now()\n  }\n})\n\n// Schema for updating existing entries\nexport const messagePatchSchema = Type.Partial(messageSchema, {\n  $id: 'MessagePatch'\n})\nexport type MessagePatch = Static<typeof messagePatchSchema>\nexport const messagePatchValidator = getValidator(messagePatchSchema, dataValidator)\nexport const messagePatchResolver = resolve<Message, HookContext>({})\n\n// Schema for allowed query properties\nexport const messageQueryProperties = Type.Pick(messageSchema,[\n  'id',\n  'text',\n  'createdAt',\n  'userId'\n])\nexport const messageQuerySchema = Type.Intersect(\n  [\n    querySyntax(messageQueryProperties),\n    // Add additional query properties here\n    Type.Object({}, { additionalProperties: false })\n  ],\n  { additionalProperties: false }\n)\nexport type MessageQuery = Static<typeof messageQuerySchema>\nexport const messageQueryValidator = getValidator(messageQuerySchema, queryValidator)\nexport const messageQueryResolver = resolve<MessageQuery, HookContext>({\n  userId: async (value, user, context) => {\n    // We want to be able to find all messages but\n    // only let a user modify their own messages otherwise\n    if (context.params.user && context.method !== 'find') {\n      return context.params.user.id\n    }\n\n    return value\n  }\n})\n```\n\n<BlockQuote type=\"note\">\nThe `virtual()` in the `messageResolver` `user` property is a [virtual property](../../api/schema/resolvers#virtual-property-resolvers) and indicates that the value does not come from the messages database table.\n</BlockQuote>\n\n## Creating a migration\n\nNow that our schemas and resolvers have everything we need, we also have to update the database with those changes. For SQL databases this is done with migrations. Migrations are a best practice for SQL databases to roll out and undo changes to the data model. Every change we make in a schema will need its corresponding migration step.\n\nInitially, every database service will automatically add a migration that creates a table for it with an `id` and `text` property. Our users service also already added a migration to add the email and password fields for logging in. The migration for the changes we made in this chapter needs to\n\n- Add the `avatar` string field to the `users` table\n- Add the `createdAt` number field to the `messages` table\n- Add the `userId` number field to the `messages` table and reference it with the `id` in the `users` table\n\nTo create a new migration with the name `chat` run\n\n```\nnpm run migrate:make -- chat\n```\n\nYou should see something like\n\n```\nCreated Migration: /path/to/feathers-chat/migrations/20220622012334_chat.(ts|js)\n```\n\nOpen that file and update it as follows\n\n```ts{4-11,15-22}\nimport type { Knex } from 'knex'\n\nexport async function up(knex: Knex): Promise<void> {\n  await knex.schema.alterTable('users', (table) => {\n    table.string('avatar')\n  })\n\n  await knex.schema.alterTable('messages', (table) => {\n    table.bigint('createdAt')\n    table.bigint('userId').references('id').inTable('users')\n  })\n}\n\nexport async function down(knex: Knex): Promise<void> {\n  await knex.schema.alterTable('users', (table) => {\n    table.dropColumn('avatar')\n  })\n\n  await knex.schema.alterTable('messages', (table) => {\n    table.dropColumn('createdAt')\n    table.dropColumn('userId')\n  })\n}\n```\n\nWe can run the migrations on the current database with\n\n```\nnpm run migrate\n```\n\n## What's next?\n\nIn this chapter we learned about schemas and implemented all the things we need for our chat application. In the next chapter we will learn about [authentication](./authentication) and add a \"Login with GitHub\" button.",
    "breadcrumb": "Schemas and resolvers",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/basics/schemas.md",
    "heading": "Schemas and resolvers",
    "subHeadings": [
      "Feathers schemas",
      "Adding a user avatar",
      "Handling messages",
      "Creating a migration",
      "What's next?"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 2739,
    "category": "guides",
    "tags": [
      "services",
      "context",
      "params",
      "authentication",
      "schema",
      "resolver",
      "typebox",
      "database",
      "knex",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "migrations",
      "application"
    ]
  },
  {
    "id": "v6-services-0",
    "content": "# Services\nBreadcrumb: Services\nCovers: Feathers services | Service methods | Service events | Database adapters | Generating a service | What's next?\nTopics: hooks, services, params, authentication, database, adapter, mongodb, postgresql, knex, pagination, real-time, websockets, events, rest, find, get, create, update, patch, remove, custom methods, middleware, setup, teardown, application\n\n## Feathers services\n\nIn Feathers, a service is an object or instance of a class that implements certain methods. Services provide a way for Feathers to interact with different kinds of data sources in a uniform, protocol-independent way.\n\nFor example, you could use services to read and/or write data to one of the supported databases, interact with the file system, call a third-party API/service (such as MailGun for sending emails, Stripe for processing payments, or OpenWeatherMap for returning weather information), or even read and/or write to a completely different type of database.\n\nA standardized interface allows us to interact with the Database/API/Gnomes inside in a uniform manner across any transport protocol, be it REST, websockets, internally within the application, or Carrier Pigeon ðŸ•Šï¸\n\nOnce you write a service method, which usually does not do anything Feathers-specific, you can automatically use it as a REST endpoint or call it through a websocket. Feathers takes care of all the necessary boilerplate, so you can focus on writing the service method itself.\n\n### Service methods\n\nService methods are [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) methods that a service can implement. Feathers offers a set of general methods that a service can implement, these are:\n\n- `find` - Find all data (potentially matching a query)\n- `get` - Get a single data entry by its unique identifier\n- `create` - Create new data\n- `update` - Update an existing data entry by completely replacing it\n- `patch` - Update one or more data entries by merging with the new data\n- `remove` - Remove one or more existing data entries\n- `setup` - Called when the application is started\n- `teardown` - Called when the application is shut down\n\nBelow is an example of Feathers service interface as a class and basic registration on a Feathers application via [app.use(name, service[, options])](../../api/application#use-path-service):\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Application, Id, NullableId, Params } from '@feathersjs/feathers'\n\nclass MyService {\n  async find(params: Params) {}\n  async get(id: Id, params: Params) {}\n  async create(data: any, params: Params) {}\n  async update(id: NullableId, data: any, params: Params) {}\n  async patch(id: NullableId, data: any, params: Params) {}\n  async remove(id: NullableId, params: Params) {}\n  async setup(path: string, app: Application) {}\n  async teardown(path: string, app: Application) {}\n}\n\nconst app = feathers<{ myservice: MyService }>()\n\napp.use('myservice', new MyService())\n```\n\nThe parameters for service methods are:\n\n- `id` - The unique identifier for the data\n- `data` - The data sent by the user (for `create`, `update`, `patch` and custom methods)\n- `params` - Additional parameters, for example the authenticated user or the query\n\nFor `setup` and `teardown` (which are only called once on application startup and shutdown) we have\n\n- `path` - The path the service is registered on\n- `app` - The [Feathers application](./../../api/application)\n\nUsually those methods can be used for most API functionality but it is also possible to add your own [custom service methods](../../api/services#custom-methods).\n\n<BlockQuote type=\"note\">\nA service does not have to implement all those methods but must have at least one. For more information about services, service methods, and parameters see the [Service API documentation](../../api/services).\n</BlockQuote>\n\nWhen used as a REST API, incoming requests get mapped automatically to their corresponding service method like this:\n\n| Service method                              | HTTP method | Path                  |\n| ------------------------------------------- | ----------- | --------------------- |\n| `service.find({ query: {} })`               | GET         | /messages             |\n| `service.find({ query: { unread: true } })` | GET         | /messages?unread=true |\n| `service.get(123)`                          | GET         | /messages/123         |\n| `service.create(body)`                      | POST        | /messages             |\n| `service.update(123, body)`                 | PUT         | /messages/123         |\n| `service.patch(123, body)`                  | PATCH       | /messages/123         |\n| `service.remove(123)`                       | DELETE      | /messages/123         |\n\n### Service events\n\nA registered service will automatically become a [NodeJS EventEmitter](https://nodejs.org/api/events.html) that sends events with the new data when a service method that modifies data (`create`, `update`, `patch` and `remove`) returns. Events can be listened to with `app.service('messages').on('eventName', data => {})`. Here is a list of the service methods and their corresponding events:\n\n| Service method     | Service event           |\n| ------------------ | ----------------------- |\n| `service.create()` | `service.on('created')` |\n| `service.update()` | `service.on('updated')` |\n| `service.patch()`  | `service.on('patched')` |\n| `service.remove()` | `service.on('removed')` |\n\nThis is how Feathers does real-time.\n\n```js\napp.service('myservice').on('created', (data) => {\n  console.log('Got created event', data)\n})\n```\n\n## Database adapters\n\nNow that we have all those service methods, we could go ahead and implement any kind of custom logic using any backend, similar to what we did in the [quick start guide](./starting). Very often, this means creating, reading, updating and removing data from a database.\n\nWriting all that code yourself for every service is pretty repetitive and cumbersome, which is why Feathers has a collection of pre-built services for different databases. They offer most of the basic functionality and can always be customized to your needs. Feathers database adapters support a common [usage API](../../api/databases/common), pagination and [querying syntax](../../api/databases/querying) for many popular databases. The following database adapters are maintained as part of Feathers core:\n\n- [SQL](../../api/databases/knex) for databases like PostgreSQL, SQLite, MySQL, MariaDB, MSSQL\n- [MongoDB](../../api/databases/mongodb) for MongoDB\n- [Memory](../../api/databases/memory) for in-memory data\n\n<BlockQuote type=\"tip\">\nThere are also many other community maintained database integrations which you can explore on the [ecosystem page](/ecosystem/?cat=Database&sort=downloads). Since they are not part of Feathers core, they are outside the scope of these guides.\n</BlockQuote>\n\nIf you went with the default selection, we will use **SQLite** which writes the database to a file and does not require any additional setup. The user service that was created when we [generated authentication](./authentication) is already using it.\n\n## Generating a service\n\nIn our new `feathers-chat` application, we can create database backed services with the following command:\n\n```sh\nnpx feathers generate service\n```\n\nThe name for our service is `message` (this is used for variable names etc.) and for the path we use `messages`. Anything else we can confirm with the default:\n\n\nThis is it, we now have a database backed messages service with authentication enabled.\n\n## What's next?\n\nIn this chapter we learned about services as a Feathers core concept for abstracting data operations. We also saw how a service sends events which we will use later to create real-time applications. After that, we generated a messages service. Next, we will [look at Feathers hooks](./hooks) as a way to create middleware for services.",
    "rawContent": "## Feathers services\n\nIn Feathers, a service is an object or instance of a class that implements certain methods. Services provide a way for Feathers to interact with different kinds of data sources in a uniform, protocol-independent way.\n\nFor example, you could use services to read and/or write data to one of the supported databases, interact with the file system, call a third-party API/service (such as MailGun for sending emails, Stripe for processing payments, or OpenWeatherMap for returning weather information), or even read and/or write to a completely different type of database.\n\nA standardized interface allows us to interact with the Database/API/Gnomes inside in a uniform manner across any transport protocol, be it REST, websockets, internally within the application, or Carrier Pigeon ðŸ•Šï¸\n\nOnce you write a service method, which usually does not do anything Feathers-specific, you can automatically use it as a REST endpoint or call it through a websocket. Feathers takes care of all the necessary boilerplate, so you can focus on writing the service method itself.\n\n### Service methods\n\nService methods are [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) methods that a service can implement. Feathers offers a set of general methods that a service can implement, these are:\n\n- `find` - Find all data (potentially matching a query)\n- `get` - Get a single data entry by its unique identifier\n- `create` - Create new data\n- `update` - Update an existing data entry by completely replacing it\n- `patch` - Update one or more data entries by merging with the new data\n- `remove` - Remove one or more existing data entries\n- `setup` - Called when the application is started\n- `teardown` - Called when the application is shut down\n\nBelow is an example of Feathers service interface as a class and basic registration on a Feathers application via [app.use(name, service[, options])](../../api/application#use-path-service):\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Application, Id, NullableId, Params } from '@feathersjs/feathers'\n\nclass MyService {\n  async find(params: Params) {}\n  async get(id: Id, params: Params) {}\n  async create(data: any, params: Params) {}\n  async update(id: NullableId, data: any, params: Params) {}\n  async patch(id: NullableId, data: any, params: Params) {}\n  async remove(id: NullableId, params: Params) {}\n  async setup(path: string, app: Application) {}\n  async teardown(path: string, app: Application) {}\n}\n\nconst app = feathers<{ myservice: MyService }>()\n\napp.use('myservice', new MyService())\n```\n\nThe parameters for service methods are:\n\n- `id` - The unique identifier for the data\n- `data` - The data sent by the user (for `create`, `update`, `patch` and custom methods)\n- `params` - Additional parameters, for example the authenticated user or the query\n\nFor `setup` and `teardown` (which are only called once on application startup and shutdown) we have\n\n- `path` - The path the service is registered on\n- `app` - The [Feathers application](./../../api/application)\n\nUsually those methods can be used for most API functionality but it is also possible to add your own [custom service methods](../../api/services#custom-methods).\n\n<BlockQuote type=\"note\">\nA service does not have to implement all those methods but must have at least one. For more information about services, service methods, and parameters see the [Service API documentation](../../api/services).\n</BlockQuote>\n\nWhen used as a REST API, incoming requests get mapped automatically to their corresponding service method like this:\n\n| Service method                              | HTTP method | Path                  |\n| ------------------------------------------- | ----------- | --------------------- |\n| `service.find({ query: {} })`               | GET         | /messages             |\n| `service.find({ query: { unread: true } })` | GET         | /messages?unread=true |\n| `service.get(123)`                          | GET         | /messages/123         |\n| `service.create(body)`                      | POST        | /messages             |\n| `service.update(123, body)`                 | PUT         | /messages/123         |\n| `service.patch(123, body)`                  | PATCH       | /messages/123         |\n| `service.remove(123)`                       | DELETE      | /messages/123         |\n\n### Service events\n\nA registered service will automatically become a [NodeJS EventEmitter](https://nodejs.org/api/events.html) that sends events with the new data when a service method that modifies data (`create`, `update`, `patch` and `remove`) returns. Events can be listened to with `app.service('messages').on('eventName', data => {})`. Here is a list of the service methods and their corresponding events:\n\n| Service method     | Service event           |\n| ------------------ | ----------------------- |\n| `service.create()` | `service.on('created')` |\n| `service.update()` | `service.on('updated')` |\n| `service.patch()`  | `service.on('patched')` |\n| `service.remove()` | `service.on('removed')` |\n\nThis is how Feathers does real-time.\n\n```js\napp.service('myservice').on('created', (data) => {\n  console.log('Got created event', data)\n})\n```\n\n## Database adapters\n\nNow that we have all those service methods, we could go ahead and implement any kind of custom logic using any backend, similar to what we did in the [quick start guide](./starting). Very often, this means creating, reading, updating and removing data from a database.\n\nWriting all that code yourself for every service is pretty repetitive and cumbersome, which is why Feathers has a collection of pre-built services for different databases. They offer most of the basic functionality and can always be customized to your needs. Feathers database adapters support a common [usage API](../../api/databases/common), pagination and [querying syntax](../../api/databases/querying) for many popular databases. The following database adapters are maintained as part of Feathers core:\n\n- [SQL](../../api/databases/knex) for databases like PostgreSQL, SQLite, MySQL, MariaDB, MSSQL\n- [MongoDB](../../api/databases/mongodb) for MongoDB\n- [Memory](../../api/databases/memory) for in-memory data\n\n<BlockQuote type=\"tip\">\nThere are also many other community maintained database integrations which you can explore on the [ecosystem page](/ecosystem/?cat=Database&sort=downloads). Since they are not part of Feathers core, they are outside the scope of these guides.\n</BlockQuote>\n\nIf you went with the default selection, we will use **SQLite** which writes the database to a file and does not require any additional setup. The user service that was created when we [generated authentication](./authentication) is already using it.\n\n## Generating a service\n\nIn our new `feathers-chat` application, we can create database backed services with the following command:\n\n```sh\nnpx feathers generate service\n```\n\nThe name for our service is `message` (this is used for variable names etc.) and for the path we use `messages`. Anything else we can confirm with the default:\n\n\nThis is it, we now have a database backed messages service with authentication enabled.\n\n## What's next?\n\nIn this chapter we learned about services as a Feathers core concept for abstracting data operations. We also saw how a service sends events which we will use later to create real-time applications. After that, we generated a messages service. Next, we will [look at Feathers hooks](./hooks) as a way to create middleware for services.",
    "breadcrumb": "Services",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/basics/services.md",
    "heading": "Services",
    "subHeadings": [
      "Feathers services",
      "Service methods",
      "Service events",
      "Database adapters",
      "Generating a service",
      "What's next?"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text",
      "js",
      "sh"
    ],
    "tokens": 1886,
    "category": "guides",
    "tags": [
      "hooks",
      "services",
      "params",
      "authentication",
      "database",
      "adapter",
      "mongodb",
      "postgresql",
      "knex",
      "pagination",
      "real-time",
      "websockets",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "custom methods",
      "middleware",
      "setup",
      "teardown",
      "application"
    ]
  },
  {
    "id": "v6-starting-0",
    "content": "# Quick start\nBreadcrumb: Quick start\nCovers: Installing Feathers | Our first app | An API Server | In the browser | What's next?\nTopics: services, authentication, database, real-time, channels, events, rest, find, get, create, update, patch, remove, socket.io, setup, application\n\n## Installing Feathers\n\nFeathers can be installed like any other Node module by installing the [@feathersjs/feathers](https://www.npmjs.com/package/@feathersjs/feathers) package through [npm](https://www.npmjs.com). The same package can also be used with module loaders like Vite, Webpack, and in React Native.\n\n```sh\nnpm install @feathersjs/feathers --save\n```\n\n<BlockQuote type=\"note\">\nAll Feathers core modules are in the `@feathersjs` namespace.\n</BlockQuote>\n\n## Our first app\n\nNow we can create a Feathers application with a simple `messages` service that allows us to create new messages and find all existing ones.\n\nCreate a file called `app.ts` with the following content:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\n\n// This is the interface for the message data\ninterface Message {\n  id?: number\n  text: string\n}\n\n// A messages service that allows us to create new\n// and return all existing messages\nclass MessageService {\n  messages: Message[] = []\n\n  async find() {\n    // Just return all our messages\n    return this.messages\n  }\n\n  async create(data: Pick<Message, 'text'>) {\n    // The new message is the data text with a unique identifier added\n    // using the messages length since it changes whenever we add one\n    const message: Message = {\n      id: this.messages.length,\n      text: data.text\n    }\n\n    // Add new message to the list\n    this.messages.push(message)\n\n    return message\n  }\n}\n\n// This tells TypeScript what services we are registering\ntype ServiceTypes = {\n  messages: MessageService\n}\n\nconst app = feathers<ServiceTypes>()\n\n// Register the message service on the Feathers application\napp.use('messages', new MessageService())\n\n// Log every time a new message has been created\napp.service('messages').on('created', (message: Message) => {\n  console.log('A new message has been created', message)\n})\n\n// A function that creates messages and then logs\n// all existing messages on the service\nconst main = async () => {\n  // Create a new message on our message service\n  await app.service('messages').create({\n    text: 'Hello Feathers'\n  })\n\n  // And another one\n  await app.service('messages').create({\n    text: 'Hello again'\n  })\n\n  // Find all existing messages\n  const messages = await app.service('messages').find()\n\n  console.log('All messages', messages)\n}\n\nmain()\n```\n\nWe can run it with\n\n```sh\nnpx ts-node app.ts\n```\n\n[Try it out live >](https://stackblitz.com/edit/node-mupbmh?embed=1&file=app.ts&view=editor)\n\nWe will see something like this in the terminal:\n\n```sh\nA new message has been created { id: 0, text: 'Hello Feathers' }\nA new message has been created { id: 1, text: 'Hello again' }\nAll messages [ { id: 0, text: 'Hello Feathers' },\n  { id: 1, text: 'Hello again' } ]\n```\n\nHere we implemented only `find` and `create`, but a service can also have a few other methods, specifically `get`, `update`, `patch` and `remove`. We will learn more about service methods and events throughout this guide, but this sums up some of the most important concepts upon which Feathers is built.\n\n## An API Server\n\nSo far we've created a Feathers application, a message service, and are listening to events. However, this is only a simple NodeJS script that prints some output and then exits. What we really want is to host it as an API server. This is where Feathers transports come in.\n\nA transport takes a service like the one we created above and turns it into a server that other clients can talk to, like a website or mobile application.\n\nIn the following example we will take our existing service and use:\n\n- `@feathersjs/koa` which uses [KoaJS](https://koajs.com/) to automatically turn our services into a REST API\n- `@feathersjs/socketio` which uses Socket.io to do the same as a WebSocket, real-time API (as we will see in a bit this is where the `created` event we saw above comes in handy).\n\nRun:\n\n```sh\nnpm install @feathersjs/socketio @feathersjs/koa --save\n```\n\nThen update `app.ts` with the following content:\n\n```ts{2-4,42-55,58-65}\nimport { feathers } from '@feathersjs/feathers'\nimport { koa, rest, bodyParser, errorHandler, serveStatic } from '@feathersjs/koa'\nimport socketio from '@feathersjs/socketio'\n\n// This is the interface for the message data\ninterface Message {\n  id?: number\n  text: string\n}\n\n// A messages service that allows us to create new\n// and return all existing messages\nclass MessageService {\n  messages: Message[] = []\n\n  async find() {\n    // Just return all our messages\n    return this.messages\n  }\n\n  async create(data: Pick<Message, 'text'>) {\n    // The new message is the data text with a unique identifier added\n    // using the messages length since it changes whenever we add one\n    const message: Message = {\n      id: this.messages.length,\n      text: data.text\n    }\n\n    // Add new message to the list\n    this.messages.push(message)\n\n    return message\n  }\n}\n\n// This tells TypeScript what services we are registering\ntype ServiceTypes = {\n  messages: MessageService\n}\n\n// Creates an KoaJS compatible Feathers application\nconst app = koa<ServiceTypes>(feathers())\n\n// Use the current folder for static file hosting\napp.use(serveStatic('.'))\n// Register the error handle\napp.use(errorHandler())\n// Parse JSON request bodies\napp.use(bodyParser())\n\n// Register REST service handler\napp.configure(rest())\n// Configure Socket.io real-time APIs\napp.configure(socketio())\n// Register our messages service\napp.use('messages', new MessageService())\n\n// Add any new real-time connection to the `everybody` channel\napp.on('connection', (connection) => app.channel('everybody').join(connection))\n// Publish all events to the `everybody` channel\napp.publish((_data) => app.channel('everybody'))\n\n// Start the server\napp\n  .listen(3030)\n  .then(() => console.log('Feathers server listening on localhost:3030'))\n\n// For good measure let's create a message\n// So our API doesn't look so empty\napp.service('messages').create({\n  text: 'Hello world from the server'\n})\n```\n\n[Try it out live >](https://stackblitz.com/edit/node-zfinli?embed=1&file=app.ts)\n\nWe can start the server with\n\n```sh\nnpx ts-node app.ts\n```\n\n<BlockQuote type=\"note\">\nThe server will stay running until you stop it by pressing **Control + C** in the terminal.\n</BlockQuote>\n\nAnd in the browser visit\n\n```\nhttp://localhost:3030/messages\n```\n\nto see an array with the one message we created on the server.\n\n<BlockQuote type=\"note\">\nThe built-in [JSON viewer in Firefox](https://developer.mozilla.org/en-US/docs/Tools/JSON_viewer) or a browser plugin like [JSON viewer for Chrome](https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh) makes it nicer to view JSON responses in the browser.\n</BlockQuote>\n\nThis is the basic setup of a Feathers API server.\n\n- The `app.use` calls probably look familiar if you have used something like Koa or Express before.\n- `app.configure` calls set up the Feathers transport to host the API.\n- `app.on('connection')` and `app.publish` are used to set up event channels, which send real-time events to the proper clients (everybody that is connected to our server in this case). You can learn [more about the channels API](../../api/channels) after finishing this guide.\n\n## In the browser\n\nNow we can look at one of the really cool features of Feathers: **It works the same in a web browser!** This means that we could take [our first app example](#our-first-app) from above and run it just the same in a website. Since we already have a server running, however, let's go a step further and create a Feathers app that talks to our `messages` service on the server using a real-time Socket.io connection.\n\nIn the same folder, add the following `index.html` page:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Feathers Example</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/daisyui@2.46.1/dist/full.css\" rel=\"stylesheet\" type=\"text/css\" />\n    <link\n      href=\"https://cdn.jsdelivr.net/npm/tailwindcss@2.2/dist/tailwind.min.css\"\n      rel=\"stylesheet\"\n      type=\"text/css\"\n    />\n    <link rel=\"stylesheet\" href=\"https://feathersjs.com/feathers-chat.css\" />\n  </head>\n  <body data-theme=\"dracula\">\n    <main id=\"main\" class=\"p-8\">\n      <h1 class=\"font-medium leading-tight text-5xl mt-0 mb-2\">Welcome to Feathers</h1>\n\n      <div class=\"form-control w-full py-2\">\n        <form class=\"input-group overflow-hidden\" onsubmit=\"sendMessage(event)\">\n          <input name=\"message\" id=\"message-text\" type=\"text\" class=\"input input-bordered w-full\" />\n          <button type=\"submit\" class=\"btn\">Send</button>\n        </form>\n      </div>\n      <h2 class=\"pt-1 pb-2 text-lg\">Messages</h2>\n    </main>\n\n    <script src=\"//unpkg.com/@feathersjs/client@^5.0.0/dist/feathers.js\"></script>\n    <script src=\"/socket.io/socket.io.js\"></script>\n    <script type=\"text/javascript\">\n      // Set up socket.io\n      const socket = io('http://localhost:3030')\n      // Initialize a Feathers app\n      const app = feathers()\n\n      // Register socket.io to talk to our server\n      app.configure(feathers.socketio(socket))\n\n      // Form submission handler that sends a new message\n      async function sendMessage(event) {\n        const messageInput = document.getElementById('message-text')\n\n        event.preventDefault()\n\n        // Create a new message with the input field value\n        await app.service('messages').create({\n          text: messageInput.value\n        })\n\n        messageInput.value = ''\n      }\n\n      // Renders a single message on the page\n      function addMessage(message) {\n        document.getElementById('main').innerHTML += `<div class=\"chat chat-start\">\n          <div class=\"chat-bubble\">${message.text}</div>\n        </div>`\n      }\n\n      const main = async () => {\n        // Find all existing messages\n        const messages = await app.service('messages').find()\n\n        // Add existing messages to the list\n        messages.forEach(addMessage)\n\n        // Add any newly created message to the list in real-time\n        app.service('messages').on('created', addMessage)\n      }\n\n      main()\n    </script>\n  </body>\n</html>\n```\n\n[Try it out live >](https://stackblitz.com/edit/node-m7cjfd?embed=1&file=index.html)\n\nNow in the browser if you go to\n\n```\nhttp://localhost:3030\n```\n\nyou will see a simple website that allows creating new messages. It is possible to open the page in two tabs and see new messages show up on either side in real-time. You can verify that the messages got created by visiting\n\n```\nhttp://localhost:3030/messages\n```\n\nYou'll see the JSON response including all current messages.\n\n## What's next?\n\nIn this chapter we created our first Feathers application and a service that allows creating new messages, storing them in memory, and retrieving them. We then hosted that service as a REST and real-time API server and used Feathers in the browser to connect to that server and create a website that can send new messages and show all existing messages in real-time.\n\nEven though we are using just NodeJS and Feathers from scratch without any additional tools, we didn't write a lot of code. In the [next chapter](./generator) we will look at the Feathers CLI which can create a similar Feathers application with a recommended file structure, models, database connections, authentication and more.",
    "rawContent": "## Installing Feathers\n\nFeathers can be installed like any other Node module by installing the [@feathersjs/feathers](https://www.npmjs.com/package/@feathersjs/feathers) package through [npm](https://www.npmjs.com). The same package can also be used with module loaders like Vite, Webpack, and in React Native.\n\n```sh\nnpm install @feathersjs/feathers --save\n```\n\n<BlockQuote type=\"note\">\nAll Feathers core modules are in the `@feathersjs` namespace.\n</BlockQuote>\n\n## Our first app\n\nNow we can create a Feathers application with a simple `messages` service that allows us to create new messages and find all existing ones.\n\nCreate a file called `app.ts` with the following content:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\n\n// This is the interface for the message data\ninterface Message {\n  id?: number\n  text: string\n}\n\n// A messages service that allows us to create new\n// and return all existing messages\nclass MessageService {\n  messages: Message[] = []\n\n  async find() {\n    // Just return all our messages\n    return this.messages\n  }\n\n  async create(data: Pick<Message, 'text'>) {\n    // The new message is the data text with a unique identifier added\n    // using the messages length since it changes whenever we add one\n    const message: Message = {\n      id: this.messages.length,\n      text: data.text\n    }\n\n    // Add new message to the list\n    this.messages.push(message)\n\n    return message\n  }\n}\n\n// This tells TypeScript what services we are registering\ntype ServiceTypes = {\n  messages: MessageService\n}\n\nconst app = feathers<ServiceTypes>()\n\n// Register the message service on the Feathers application\napp.use('messages', new MessageService())\n\n// Log every time a new message has been created\napp.service('messages').on('created', (message: Message) => {\n  console.log('A new message has been created', message)\n})\n\n// A function that creates messages and then logs\n// all existing messages on the service\nconst main = async () => {\n  // Create a new message on our message service\n  await app.service('messages').create({\n    text: 'Hello Feathers'\n  })\n\n  // And another one\n  await app.service('messages').create({\n    text: 'Hello again'\n  })\n\n  // Find all existing messages\n  const messages = await app.service('messages').find()\n\n  console.log('All messages', messages)\n}\n\nmain()\n```\n\nWe can run it with\n\n```sh\nnpx ts-node app.ts\n```\n\n[Try it out live >](https://stackblitz.com/edit/node-mupbmh?embed=1&file=app.ts&view=editor)\n\nWe will see something like this in the terminal:\n\n```sh\nA new message has been created { id: 0, text: 'Hello Feathers' }\nA new message has been created { id: 1, text: 'Hello again' }\nAll messages [ { id: 0, text: 'Hello Feathers' },\n  { id: 1, text: 'Hello again' } ]\n```\n\nHere we implemented only `find` and `create`, but a service can also have a few other methods, specifically `get`, `update`, `patch` and `remove`. We will learn more about service methods and events throughout this guide, but this sums up some of the most important concepts upon which Feathers is built.\n\n## An API Server\n\nSo far we've created a Feathers application, a message service, and are listening to events. However, this is only a simple NodeJS script that prints some output and then exits. What we really want is to host it as an API server. This is where Feathers transports come in.\n\nA transport takes a service like the one we created above and turns it into a server that other clients can talk to, like a website or mobile application.\n\nIn the following example we will take our existing service and use:\n\n- `@feathersjs/koa` which uses [KoaJS](https://koajs.com/) to automatically turn our services into a REST API\n- `@feathersjs/socketio` which uses Socket.io to do the same as a WebSocket, real-time API (as we will see in a bit this is where the `created` event we saw above comes in handy).\n\nRun:\n\n```sh\nnpm install @feathersjs/socketio @feathersjs/koa --save\n```\n\nThen update `app.ts` with the following content:\n\n```ts{2-4,42-55,58-65}\nimport { feathers } from '@feathersjs/feathers'\nimport { koa, rest, bodyParser, errorHandler, serveStatic } from '@feathersjs/koa'\nimport socketio from '@feathersjs/socketio'\n\n// This is the interface for the message data\ninterface Message {\n  id?: number\n  text: string\n}\n\n// A messages service that allows us to create new\n// and return all existing messages\nclass MessageService {\n  messages: Message[] = []\n\n  async find() {\n    // Just return all our messages\n    return this.messages\n  }\n\n  async create(data: Pick<Message, 'text'>) {\n    // The new message is the data text with a unique identifier added\n    // using the messages length since it changes whenever we add one\n    const message: Message = {\n      id: this.messages.length,\n      text: data.text\n    }\n\n    // Add new message to the list\n    this.messages.push(message)\n\n    return message\n  }\n}\n\n// This tells TypeScript what services we are registering\ntype ServiceTypes = {\n  messages: MessageService\n}\n\n// Creates an KoaJS compatible Feathers application\nconst app = koa<ServiceTypes>(feathers())\n\n// Use the current folder for static file hosting\napp.use(serveStatic('.'))\n// Register the error handle\napp.use(errorHandler())\n// Parse JSON request bodies\napp.use(bodyParser())\n\n// Register REST service handler\napp.configure(rest())\n// Configure Socket.io real-time APIs\napp.configure(socketio())\n// Register our messages service\napp.use('messages', new MessageService())\n\n// Add any new real-time connection to the `everybody` channel\napp.on('connection', (connection) => app.channel('everybody').join(connection))\n// Publish all events to the `everybody` channel\napp.publish((_data) => app.channel('everybody'))\n\n// Start the server\napp\n  .listen(3030)\n  .then(() => console.log('Feathers server listening on localhost:3030'))\n\n// For good measure let's create a message\n// So our API doesn't look so empty\napp.service('messages').create({\n  text: 'Hello world from the server'\n})\n```\n\n[Try it out live >](https://stackblitz.com/edit/node-zfinli?embed=1&file=app.ts)\n\nWe can start the server with\n\n```sh\nnpx ts-node app.ts\n```\n\n<BlockQuote type=\"note\">\nThe server will stay running until you stop it by pressing **Control + C** in the terminal.\n</BlockQuote>\n\nAnd in the browser visit\n\n```\nhttp://localhost:3030/messages\n```\n\nto see an array with the one message we created on the server.\n\n<BlockQuote type=\"note\">\nThe built-in [JSON viewer in Firefox](https://developer.mozilla.org/en-US/docs/Tools/JSON_viewer) or a browser plugin like [JSON viewer for Chrome](https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh) makes it nicer to view JSON responses in the browser.\n</BlockQuote>\n\nThis is the basic setup of a Feathers API server.\n\n- The `app.use` calls probably look familiar if you have used something like Koa or Express before.\n- `app.configure` calls set up the Feathers transport to host the API.\n- `app.on('connection')` and `app.publish` are used to set up event channels, which send real-time events to the proper clients (everybody that is connected to our server in this case). You can learn [more about the channels API](../../api/channels) after finishing this guide.\n\n## In the browser\n\nNow we can look at one of the really cool features of Feathers: **It works the same in a web browser!** This means that we could take [our first app example](#our-first-app) from above and run it just the same in a website. Since we already have a server running, however, let's go a step further and create a Feathers app that talks to our `messages` service on the server using a real-time Socket.io connection.\n\nIn the same folder, add the following `index.html` page:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Feathers Example</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/daisyui@2.46.1/dist/full.css\" rel=\"stylesheet\" type=\"text/css\" />\n    <link\n      href=\"https://cdn.jsdelivr.net/npm/tailwindcss@2.2/dist/tailwind.min.css\"\n      rel=\"stylesheet\"\n      type=\"text/css\"\n    />\n    <link rel=\"stylesheet\" href=\"https://feathersjs.com/feathers-chat.css\" />\n  </head>\n  <body data-theme=\"dracula\">\n    <main id=\"main\" class=\"p-8\">\n      <h1 class=\"font-medium leading-tight text-5xl mt-0 mb-2\">Welcome to Feathers</h1>\n\n      <div class=\"form-control w-full py-2\">\n        <form class=\"input-group overflow-hidden\" onsubmit=\"sendMessage(event)\">\n          <input name=\"message\" id=\"message-text\" type=\"text\" class=\"input input-bordered w-full\" />\n          <button type=\"submit\" class=\"btn\">Send</button>\n        </form>\n      </div>\n      <h2 class=\"pt-1 pb-2 text-lg\">Messages</h2>\n    </main>\n\n    <script src=\"//unpkg.com/@feathersjs/client@^5.0.0/dist/feathers.js\"></script>\n    <script src=\"/socket.io/socket.io.js\"></script>\n    <script type=\"text/javascript\">\n      // Set up socket.io\n      const socket = io('http://localhost:3030')\n      // Initialize a Feathers app\n      const app = feathers()\n\n      // Register socket.io to talk to our server\n      app.configure(feathers.socketio(socket))\n\n      // Form submission handler that sends a new message\n      async function sendMessage(event) {\n        const messageInput = document.getElementById('message-text')\n\n        event.preventDefault()\n\n        // Create a new message with the input field value\n        await app.service('messages').create({\n          text: messageInput.value\n        })\n\n        messageInput.value = ''\n      }\n\n      // Renders a single message on the page\n      function addMessage(message) {\n        document.getElementById('main').innerHTML += `<div class=\"chat chat-start\">\n          <div class=\"chat-bubble\">${message.text}</div>\n        </div>`\n      }\n\n      const main = async () => {\n        // Find all existing messages\n        const messages = await app.service('messages').find()\n\n        // Add existing messages to the list\n        messages.forEach(addMessage)\n\n        // Add any newly created message to the list in real-time\n        app.service('messages').on('created', addMessage)\n      }\n\n      main()\n    </script>\n  </body>\n</html>\n```\n\n[Try it out live >](https://stackblitz.com/edit/node-m7cjfd?embed=1&file=index.html)\n\nNow in the browser if you go to\n\n```\nhttp://localhost:3030\n```\n\nyou will see a simple website that allows creating new messages. It is possible to open the page in two tabs and see new messages show up on either side in real-time. You can verify that the messages got created by visiting\n\n```\nhttp://localhost:3030/messages\n```\n\nYou'll see the JSON response including all current messages.\n\n## What's next?\n\nIn this chapter we created our first Feathers application and a service that allows creating new messages, storing them in memory, and retrieving them. We then hosted that service as a REST and real-time API server and used Feathers in the browser to connect to that server and create a website that can send new messages and show all existing messages in real-time.\n\nEven though we are using just NodeJS and Feathers from scratch without any additional tools, we didn't write a lot of code. In the [next chapter](./generator) we will look at the Feathers CLI which can create a similar Feathers application with a recommended file structure, models, database connections, authentication and more.",
    "breadcrumb": "Quick start",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/basics/starting.md",
    "heading": "Quick start",
    "subHeadings": [
      "Installing Feathers",
      "Our first app",
      "An API Server",
      "In the browser",
      "What's next?"
    ],
    "hasCode": true,
    "codeLanguages": [
      "sh",
      "text",
      "ts",
      "html"
    ],
    "tokens": 2832,
    "category": "guides",
    "tags": [
      "services",
      "authentication",
      "database",
      "real-time",
      "channels",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "socket.io",
      "setup",
      "application"
    ]
  },
  {
    "id": "v6-testing-0",
    "content": "# Writing tests\nBreadcrumb: Writing tests\nCovers: Test database setup | Testing services | Code coverage | What's next?\nTopics: hooks, services, params, provider, authentication, database, real-time, rest, get, create, update, remove, setup, application\n\n## Test database setup\n\nWhen testing database functionality, we want to make sure that the tests use a different database. We can achieve this by updating the test environment configuration in `config/test.json` with the following content:\n\n```json\n{\n  \"nedb\": \"../test/data\"\n}\n```\n\nThis will set up the NeDB database to use `test/data` as the base directory instead of `data/` when the `NODE_ENV` environment variable is set to `test`. The same thing can be done with connection strings for other databases.\n\n<BlockQuote type=\"warning\">\nWhen using Git for version control, the `data/` and `test/data` folders should be added to `.gitignore`.\n</BlockQuote>\n\nWe also want to make sure that the database is cleaned up before every test run. To make that possible across platforms, first run:\n\n```sh\nnpm install shx --save-dev\n```\n\nNow we can update the `scripts` section of our `package.json` to the following:\n\n```json\n  \"scripts\": {\n    \"test\": \"npm run compile && npm run mocha\",\n    \"dev\": \"ts-node-dev --no-notify src/\",\n    \"start\": \"npm run compile && node lib/\",\n    \"clean\": \"shx rm -rf test/data/\",\n    \"mocha\": \"npm run clean && NODE_ENV=test ts-mocha \\\"test/**/*.ts\\\" --recursive --exit\",\n    \"compile\": \"shx rm -rf lib/ && tsc\"\n  },\n```\n\nOn Windows the `mocha` command should look like this:\n\n```sh\nnpm run clean & SET NODE_ENV=test& mocha test/ --recursive --exit\n```\n\nThis will make sure that the `test/data` folder is removed before every test run and `NODE_ENV` is set properly.\n\n## Testing services\n\nTo test the `messages` and `users` services (with all hooks wired up), we could use any REST API testing tool to make requests and verify that they return correct responses.\n\nThere is a much faster, easier and complete approach. Since everything on top of our own hooks and services is already provided (and tested) by Feathers, we can require the [application](../../api/application) object and use the [service methods](../../api/services) directly. We \"fake\" authentication by setting `params.user` manually.\n\nBy default, the generator creates a service test file that only tests that the service exists.\n\nE.g. like this in `test/services/users.test.ts`:\n\n```ts\nimport assert from 'assert';\nimport app from '../../src/app';\n\ndescribe('\\'users\\' service', () => {\n  it('registered the service', () => {\n    const service = app.service('users');\n\n    assert.ok(service, 'Registered the service');\n  });\n});\n```\n\nWe can then add similar tests that use the service. In this case we are:\n1. verifying that users can be created, the default profile image gets set and the password is encrypted\n2. ensuring that the password does not get sent to external requests\n\nReplace `test/services/users.test.ts` with the following:\n\n```ts\nimport assert from 'assert';\nimport app from '../../src/app';\n\ndescribe('\\'users\\' service', () => {\n  it('registered the service', () => {\n    const service = app.service('users');\n\n    assert.ok(service, 'Registered the service');\n  });\n\n  it('creates a user, encrypts password and adds gravatar', async () => {\n    const user = await app.service('users').create({\n      email: 'test@example.com',\n      password: 'secret'\n    });\n\n    // Verify Gravatar has been set as we'd expect\n    assert.equal(user.avatar, 'https://s.gravatar.com/avatar/55502f40dc8b7c769880b10874abc9d0?s=60');\n    // Makes sure the password got encrypted\n    assert.ok(user.password !== 'secret');\n  });\n\n  it('removes password for external requests', async () => {\n    // Setting `provider` indicates an external request\n    const params = { provider: 'rest' };\n\n    const user = await app.service('users').create({\n      email: 'test2@example.com',\n      password: 'secret'\n    }, params);\n\n    // Make sure password has been removed\n    assert.ok(!user.password);\n  });\n});\n```\n\nWe take a similar approach for the messages service test by creating a test-specific user from the `users` service, then pass it as `params.user` when creating a new message and validates that message's content:\n\nUpdate `test/services/messages.test.ts` as follows:\n\n```ts\nimport assert from 'assert';\nimport app from '../../src/app';\n\ndescribe('\\'messages\\' service', () => {\n  it('registered the service', () => {\n    const service = app.service('messages');\n\n    assert.ok(service, 'Registered the service');\n  });\n\n  it('creates and processes message, adds user information', async () => {\n    // Create a new user we can use for testing\n    const user = await app.service('users').create({\n      email: 'messagetest@example.com',\n      password: 'supersecret'\n    });\n\n    // The messages service call params (with the user we just created)\n    const params = { user };\n    const message = await app.service('messages').create({\n      text: 'a test',\n      additional: 'should be removed'\n    }, params);\n\n    assert.equal(message.text, 'a test');\n    // `userId` should be set to passed users it\n    assert.equal(message.userId, user._id);\n    // Additional property has been removed\n    assert.ok(!message.additional);\n    // `user` has been populated\n    assert.deepEqual(message.user, user);\n  });\n});\n```\n\nRun `npm test` one more time, to verify that all tests are passing.\n\n## Code coverage\n\nCode coverage is a great way to get some insights into how much of our code is actually executed during the tests. Using [Istanbul](https://github.com/gotwarlost/istanbul) we can add it easily:\n\n```sh\nnpm install nyc --save-dev\n```\n\nFor TypeScript we also have to install the TypeScript reporter:\n\n```sh\nnpm install @istanbuljs/nyc-config-typescript --save-dev\n```\n\nAdd the following `.nycrc` file:\n\n```json\n{\n  \"extends\": \"@istanbuljs/nyc-config-typescript\",\n  \"include\": [\n    \"src/**/*.ts\",\n    \"src/**/*.tsx\"\n  ]\n}\n```\n\nAnd then update the `scripts` section of our `package.json` to:\n\n```json\n  \"scripts\": {\n    \"test\": \"npm run compile && npm run coverage\",\n    \"dev\": \"ts-node-dev --no-notify src/\",\n    \"start\": \"npm run compile && node lib/\",\n    \"clean\": \"shx rm -rf test/data/\",\n    \"coverage\": \"nyc npm run mocha\",\n    \"mocha\": \"npm run clean && NODE_ENV=test ts-mocha \\\"test/**/*.ts\\\" --recursive --exit\",\n    \"compile\": \"shx rm -rf lib/ && tsc\"\n  },\n```\n\nOn Windows, the `coverage` command looks like this:\n\n```sh\nnpm run clean & SET NODE_ENV=test& nyc mocha\n```\n\nNow run:\n\n```sh\nnpm test\n```\n\nThis will print out some additional coverage information.\n\n<BlockQuote type=\"warning\">\nWhen using Git for version control, the `.nyc_output/` folder should be added to `.gitignore`.\n</BlockQuote>\n\n## What's next?\n\nThatâ€™s it! Our chat guide is completed! We now have a fully-tested REST and real-time API, with a plain JavaScript frontend including login and signup. Follow up in the [Feathers API documentation](../../api/) for more details about using Feathers, or start building your own first Feathers application!",
    "rawContent": "## Test database setup\n\nWhen testing database functionality, we want to make sure that the tests use a different database. We can achieve this by updating the test environment configuration in `config/test.json` with the following content:\n\n```json\n{\n  \"nedb\": \"../test/data\"\n}\n```\n\nThis will set up the NeDB database to use `test/data` as the base directory instead of `data/` when the `NODE_ENV` environment variable is set to `test`. The same thing can be done with connection strings for other databases.\n\n<BlockQuote type=\"warning\">\nWhen using Git for version control, the `data/` and `test/data` folders should be added to `.gitignore`.\n</BlockQuote>\n\nWe also want to make sure that the database is cleaned up before every test run. To make that possible across platforms, first run:\n\n```sh\nnpm install shx --save-dev\n```\n\nNow we can update the `scripts` section of our `package.json` to the following:\n\n```json\n  \"scripts\": {\n    \"test\": \"npm run compile && npm run mocha\",\n    \"dev\": \"ts-node-dev --no-notify src/\",\n    \"start\": \"npm run compile && node lib/\",\n    \"clean\": \"shx rm -rf test/data/\",\n    \"mocha\": \"npm run clean && NODE_ENV=test ts-mocha \\\"test/**/*.ts\\\" --recursive --exit\",\n    \"compile\": \"shx rm -rf lib/ && tsc\"\n  },\n```\n\nOn Windows the `mocha` command should look like this:\n\n```sh\nnpm run clean & SET NODE_ENV=test& mocha test/ --recursive --exit\n```\n\nThis will make sure that the `test/data` folder is removed before every test run and `NODE_ENV` is set properly.\n\n## Testing services\n\nTo test the `messages` and `users` services (with all hooks wired up), we could use any REST API testing tool to make requests and verify that they return correct responses.\n\nThere is a much faster, easier and complete approach. Since everything on top of our own hooks and services is already provided (and tested) by Feathers, we can require the [application](../../api/application) object and use the [service methods](../../api/services) directly. We \"fake\" authentication by setting `params.user` manually.\n\nBy default, the generator creates a service test file that only tests that the service exists.\n\nE.g. like this in `test/services/users.test.ts`:\n\n```ts\nimport assert from 'assert';\nimport app from '../../src/app';\n\ndescribe('\\'users\\' service', () => {\n  it('registered the service', () => {\n    const service = app.service('users');\n\n    assert.ok(service, 'Registered the service');\n  });\n});\n```\n\nWe can then add similar tests that use the service. In this case we are:\n1. verifying that users can be created, the default profile image gets set and the password is encrypted\n2. ensuring that the password does not get sent to external requests\n\nReplace `test/services/users.test.ts` with the following:\n\n```ts\nimport assert from 'assert';\nimport app from '../../src/app';\n\ndescribe('\\'users\\' service', () => {\n  it('registered the service', () => {\n    const service = app.service('users');\n\n    assert.ok(service, 'Registered the service');\n  });\n\n  it('creates a user, encrypts password and adds gravatar', async () => {\n    const user = await app.service('users').create({\n      email: 'test@example.com',\n      password: 'secret'\n    });\n\n    // Verify Gravatar has been set as we'd expect\n    assert.equal(user.avatar, 'https://s.gravatar.com/avatar/55502f40dc8b7c769880b10874abc9d0?s=60');\n    // Makes sure the password got encrypted\n    assert.ok(user.password !== 'secret');\n  });\n\n  it('removes password for external requests', async () => {\n    // Setting `provider` indicates an external request\n    const params = { provider: 'rest' };\n\n    const user = await app.service('users').create({\n      email: 'test2@example.com',\n      password: 'secret'\n    }, params);\n\n    // Make sure password has been removed\n    assert.ok(!user.password);\n  });\n});\n```\n\nWe take a similar approach for the messages service test by creating a test-specific user from the `users` service, then pass it as `params.user` when creating a new message and validates that message's content:\n\nUpdate `test/services/messages.test.ts` as follows:\n\n```ts\nimport assert from 'assert';\nimport app from '../../src/app';\n\ndescribe('\\'messages\\' service', () => {\n  it('registered the service', () => {\n    const service = app.service('messages');\n\n    assert.ok(service, 'Registered the service');\n  });\n\n  it('creates and processes message, adds user information', async () => {\n    // Create a new user we can use for testing\n    const user = await app.service('users').create({\n      email: 'messagetest@example.com',\n      password: 'supersecret'\n    });\n\n    // The messages service call params (with the user we just created)\n    const params = { user };\n    const message = await app.service('messages').create({\n      text: 'a test',\n      additional: 'should be removed'\n    }, params);\n\n    assert.equal(message.text, 'a test');\n    // `userId` should be set to passed users it\n    assert.equal(message.userId, user._id);\n    // Additional property has been removed\n    assert.ok(!message.additional);\n    // `user` has been populated\n    assert.deepEqual(message.user, user);\n  });\n});\n```\n\nRun `npm test` one more time, to verify that all tests are passing.\n\n## Code coverage\n\nCode coverage is a great way to get some insights into how much of our code is actually executed during the tests. Using [Istanbul](https://github.com/gotwarlost/istanbul) we can add it easily:\n\n```sh\nnpm install nyc --save-dev\n```\n\nFor TypeScript we also have to install the TypeScript reporter:\n\n```sh\nnpm install @istanbuljs/nyc-config-typescript --save-dev\n```\n\nAdd the following `.nycrc` file:\n\n```json\n{\n  \"extends\": \"@istanbuljs/nyc-config-typescript\",\n  \"include\": [\n    \"src/**/*.ts\",\n    \"src/**/*.tsx\"\n  ]\n}\n```\n\nAnd then update the `scripts` section of our `package.json` to:\n\n```json\n  \"scripts\": {\n    \"test\": \"npm run compile && npm run coverage\",\n    \"dev\": \"ts-node-dev --no-notify src/\",\n    \"start\": \"npm run compile && node lib/\",\n    \"clean\": \"shx rm -rf test/data/\",\n    \"coverage\": \"nyc npm run mocha\",\n    \"mocha\": \"npm run clean && NODE_ENV=test ts-mocha \\\"test/**/*.ts\\\" --recursive --exit\",\n    \"compile\": \"shx rm -rf lib/ && tsc\"\n  },\n```\n\nOn Windows, the `coverage` command looks like this:\n\n```sh\nnpm run clean & SET NODE_ENV=test& nyc mocha\n```\n\nNow run:\n\n```sh\nnpm test\n```\n\nThis will print out some additional coverage information.\n\n<BlockQuote type=\"warning\">\nWhen using Git for version control, the `.nyc_output/` folder should be added to `.gitignore`.\n</BlockQuote>\n\n## What's next?\n\nThatâ€™s it! Our chat guide is completed! We now have a fully-tested REST and real-time API, with a plain JavaScript frontend including login and signup. Follow up in the [Feathers API documentation](../../api/) for more details about using Feathers, or start building your own first Feathers application!",
    "breadcrumb": "Writing tests",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/basics/testing.md",
    "heading": "Writing tests",
    "subHeadings": [
      "Test database setup",
      "Testing services",
      "Code coverage",
      "What's next?"
    ],
    "hasCode": true,
    "codeLanguages": [
      "json",
      "text",
      "sh",
      "ts"
    ],
    "tokens": 1707,
    "category": "guides",
    "tags": [
      "hooks",
      "services",
      "params",
      "provider",
      "authentication",
      "database",
      "real-time",
      "rest",
      "get",
      "create",
      "update",
      "remove",
      "setup",
      "application"
    ]
  },
  {
    "id": "v6-frameworks-0",
    "content": "# Frontend Frameworks\nBreadcrumb: Frontend Frameworks\nCovers: Client Side Docs | The Feathers chat | Examples | Framework Integrations\nTopics: get, feathers client, application\n\n## Client Side Docs\n\nIf you want to learn how to use Feathers as a client in Node.js, React Native, or in the browser with a module loader like Webpack refer to the [client API docs](../api/client).\n\n## The Feathers chat\n\nThe [Feathers Chat application](../guides/) from guide gives a basic intro to using the Feathers Client in a vanilla JavaScript environment. That's a good place to start to see how things fit together. Framework specific repositories can be found at:\n\n- JavaScript + plain JS frontend: [feathersjs/feathers-chat](https://github.com/feathersjs/feathers-chat)\n- TypeScript + plain JS frontend: [feathersjs/feathers-chat-ts](https://github.com/feathersjs/feathers-chat-ts)\n- React: [feathersjs-ecosystem/feathers-chat-react](https://github.com/feathersjs-ecosystem/feathers-chat-react)\n- React Native: [feathersjs-ecosystem/feathers-react-native-chat](https://github.com/feathersjs-ecosystem/feathers-react-native-chat)\n- Angular: [feathersjs-ecosystem/feathers-chat-angular](https://github.com/feathersjs-ecosystem/feathers-chat-angular)\n- VueJS with Vuex: [feathersjs-ecosystem/feathers-chat-vuex](https://github.com/feathersjs-ecosystem/feathers-chat-vuex)\n\n## Examples\n\nBeyond the basics, see [this list](https://github.com/feathersjs/awesome-feathersjs#examples) of Feathers examples in [awesome-feathersjs](https://github.com/feathersjs/awesome-feathersjs).\n\n## Framework Integrations\n\nSee [this list](https://github.com/feathersjs/awesome-feathersjs#frontend-frameworks) of Feathers front-end framework integrations if you are looking for something that makes Feathers even easier to use with things like React, Vue or others.",
    "rawContent": "## Client Side Docs\n\nIf you want to learn how to use Feathers as a client in Node.js, React Native, or in the browser with a module loader like Webpack refer to the [client API docs](../api/client).\n\n## The Feathers chat\n\nThe [Feathers Chat application](../guides/) from guide gives a basic intro to using the Feathers Client in a vanilla JavaScript environment. That's a good place to start to see how things fit together. Framework specific repositories can be found at:\n\n- JavaScript + plain JS frontend: [feathersjs/feathers-chat](https://github.com/feathersjs/feathers-chat)\n- TypeScript + plain JS frontend: [feathersjs/feathers-chat-ts](https://github.com/feathersjs/feathers-chat-ts)\n- React: [feathersjs-ecosystem/feathers-chat-react](https://github.com/feathersjs-ecosystem/feathers-chat-react)\n- React Native: [feathersjs-ecosystem/feathers-react-native-chat](https://github.com/feathersjs-ecosystem/feathers-react-native-chat)\n- Angular: [feathersjs-ecosystem/feathers-chat-angular](https://github.com/feathersjs-ecosystem/feathers-chat-angular)\n- VueJS with Vuex: [feathersjs-ecosystem/feathers-chat-vuex](https://github.com/feathersjs-ecosystem/feathers-chat-vuex)\n\n## Examples\n\nBeyond the basics, see [this list](https://github.com/feathersjs/awesome-feathersjs#examples) of Feathers examples in [awesome-feathersjs](https://github.com/feathersjs/awesome-feathersjs).\n\n## Framework Integrations\n\nSee [this list](https://github.com/feathersjs/awesome-feathersjs#frontend-frameworks) of Feathers front-end framework integrations if you are looking for something that makes Feathers even easier to use with things like React, Vue or others.",
    "breadcrumb": "Frontend Frameworks",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/frameworks.md",
    "heading": "Frontend Frameworks",
    "subHeadings": [
      "Client Side Docs",
      "The Feathers chat",
      "Examples",
      "Framework Integrations"
    ],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 413,
    "category": "guides",
    "tags": [
      "get",
      "feathers client",
      "application"
    ]
  },
  {
    "id": "v6-javascript-0",
    "content": "# JavaScript web app\nBreadcrumb: JavaScript web app\nCovers: Set up the page | Connect to the API | Base HTML | Displaying pages | Login and signup | Event listeners and real-time | Using the chat application\nTopics: hooks, authentication, jwt, oauth, real-time, websockets, events, find, get, create, update, remove, feathers client, socket.io, application\n\n## Set up the page\n\nFirst, let's update `public/index.html` to initialize everything we need for the chat frontend:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>feathers-chat</title>\n    <meta name=\"description\" content=\"A Feathers chat application\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link\n      href=\"https://cdn.jsdelivr.net/npm/tailwindcss@2.2/dist/tailwind.min.css\"\n      rel=\"stylesheet\"\n      type=\"text/css\"\n    />\n    <link href=\"https://cdn.jsdelivr.net/npm/daisyui@2.18.1/dist/full.css\" rel=\"stylesheet\" type=\"text/css\" />\n    <link rel=\"stylesheet\" href=\"https://dove.feathersjs.com/feathers-chat.css\" />\n  </head>\n  <body>\n    <div id=\"app\" data-theme=\"dracula\"></div>\n    <script src=\"https://unpkg.com/@feathersjs/client@^5.0.0-pre.34/dist/feathers.js\"></script>\n    <script src=\"/socket.io/socket.io.js\"></script>\n    <script type=\"module\" src=\"client.js\"></script>\n  </body>\n</html>\n```\n\nThis will load our chat CSS style, add a container div `#app` and load several libraries:\n\n- The browser version of Feathers (since we are not using a module loader like Webpack or Browserify)\n- Socket.io provided by the chat API\n- [daisyUI](https://daisyui.com/) for a collection of CSS components\n- A `client.js` for our code to live in\n\nLetâ€™s create `public/client.js` where all the following code will live. Each of the following code samples should be added to the end of that file.\n\n## Connect to the API\n\nWeâ€™ll start with the most important thing first, the connection to our Feathers API that connects to our server using websockets and initializes the [authentication client](../basics/authentication):\n\n```js\n/* global io, feathers, moment */\n// Establish a Socket.io connection\nconst socket = io()\n// Initialize our Feathers client application through Socket.io\n// with hooks and authentication.\nconst client = feathers()\n\nclient.configure(feathers.socketio(socket))\n// Use localStorage to store our login token\nclient.configure(feathers.authentication())\n```\n\n## Base HTML\n\nNext, we have to define some static and dynamic HTML that we can insert into the page when we want to show the login page (which also doubles as the signup page) and the actual chat interface:\n\n```js\n// Login screen\nconst loginTemplate = (error) => `<div class=\"login flex min-h-screen bg-neutral justify-center items-center\">\n<div class=\"card w-full max-w-sm bg-base-100 px-4 py-8 shadow-xl\">\n  <div class=\"px-4\"><i alt=\"\" class=\"h-32 w-32 block mx-auto i-logos-feathersjs invert\"></i>\n    <h1 class=\"text-5xl font-bold text-center my-5 bg-clip-text bg-gradient-to-br\">\n      Feathers Chat\n    </h1>\n  </div>\n  <form class=\"card-body pt-2\">\n    ${\n      error\n        ? `<div class=\"alert alert-error justify-start\">\n      <i class=\"i-feather-alert-triangle\"></i>\n      <span class=\"flex-grow\">${error.message}</span>\n    </div>`\n        : ''\n    }\n    <div class=\"form-control\">\n      <label for=\"email\" class=\"label\"><span class=\"label-text\">Email</span></label>\n      <input type=\"text\" name=\"email\" placeholder=\"enter email\" class=\"input input-bordered\">\n    </div>\n    <div class=\"form-control mt-0\">\n      <label for=\"password\" class=\"label\"><span class=\"label-text\">Password</span></label>\n      <input type=\"password\" name=\"password\" placeholder=\"enter password\" class=\"input input-bordered\">\n    </div>\n    <div class=\"form-control mt-6\"><button id=\"login\" type=\"button\" class=\"btn\">Login</button></div>\n    <div class=\"form-control mt-6\"><button id=\"signup\" type=\"button\" class=\"btn\">Signup</button></div>\n    <div class=\"form-control mt-6\"><a href=\"/oauth/github\" id=\"github\" class=\"btn\">Login with GitHub</a></div>\n  </form>\n</div>\n</div>`\n\n// Main chat view\nconst chatTemplate =\n  () => `<div class=\"drawer drawer-mobile\"><input id=\"drawer-left\" type=\"checkbox\" class=\"drawer-toggle\">\n  <div class=\"drawer-content flex flex-col\">\n    <div class=\"navbar w-full\">\n      <div class=\"navbar-start\">\n        <label for=\"drawer-left\" class=\"btn btn-square btn-ghost lg:hidden drawer-button\">\n          <i class=\"i-feather-menu text-lg\"></i>\n        </label>\n      </div>\n      <div class=\"navbar-center flex flex-col\">\n        <p>Feathers Chat</p>\n        <label for=\"drawer-right\" class=\"text-xs cursor-pointer\">\n          <span class=\"online-count\">0</span> User(s)\n        </label>\n      </div>\n      <div class=\"navbar-end\">\n        <div class=\"tooltip tooltip-left\" data-tip=\"Logout\">\n        <button type=\"button\" id=\"logout\" class=\"btn btn-ghost\"><i class=\"i-feather-log-out text-lg\"></i></button>\n      </div>\n      </div>\n    </div>\n    <div id=\"chat\" class=\"h-full overflow-y-auto px-3\"></div>\n    <div class=\"form-control w-full py-2 px-3\">\n      <form class=\"input-group overflow-hidden\" id=\"send-message\">\n        <input name=\"text\" type=\"text\" placeholder=\"Compose message\" class=\"input input-bordered w-full\">\n        <button type=\"submit\" class=\"btn\">Send</button>\n      </form>\n    </div>\n  </div>\n  <div class=\"drawer-side\"><label for=\"drawer-left\" class=\"drawer-overlay\"></label>\n    <ul class=\"menu user-list compact p-2 overflow-y-auto w-60 bg-base-300 text-base-content\">\n      <li class=\"menu-title\"><span>Users</span></li>\n    </ul>\n  </div>\n</div>`\n\n// Helper to safely escape HTML\nconst escapeHTML = (str) => str.replace(/&/g, '&amp').replace(/</g, '&lt').replace(/>/g, '&gt')\n\nconst formatDate = (timestamp) =>\n  new Intl.DateTimeFormat('en-US', {\n    timeStyle: 'short',\n    dateStyle: 'medium'\n  }).format(new Date(timestamp))\n\n// Add a new user to the list\nconst addUser = (user) => {\n  const userList = document.querySelector('.user-list')\n\n  if (userList) {\n    // Add the user to the list\n    userList.innerHTML += `<li class=\"user\">\n      <a>\n        <div class=\"avatar indicator\">\n          <div class=\"w-6 rounded\"><img src=\"${user.avatar}\" alt=\"${user.email}\"></div>\n        </div><span>${user.email}</span>\n      </a>\n    </li>`\n\n    // Update the number of users\n    const userCount = document.querySelectorAll('.user-list li.user').length\n\n    document.querySelector('.online-count').innerHTML = userCount\n  }\n}\n\n// Renders a message to the page\nconst addMessage = (message) => {\n  // The user that sent this message (added by the populate-user hook)\n  const { user = {} } = message\n  const chat = document.querySelector('#chat')\n  // Escape HTML to prevent XSS attacks\n  const text = escapeHTML(message.text)\n\n  if (chat) {\n    chat.innerHTML += `<div class=\"chat chat-start py-2\">\n      <div class=\"chat-image avatar\">\n        <div class=\"w-10 rounded-full\">\n          <img src=\"${user.avatar}\" />\n        </div>\n      </div>\n      <div class=\"chat-header pb-1\">\n        ${user.email}\n        <time class=\"text-xs opacity-50\">${formatDate(message.createdAt)}</time>\n      </div>\n      <div class=\"chat-bubble\">${text}</div>\n    </div>`\n\n    // Always scroll to the bottom of our message list\n    chat.scrollTop = chat.scrollHeight - chat.clientHeight\n  }\n}\n```\n\nThis will add the following variables and functions:\n\n- `loginTemplate` - A function that returns static HTML for the login/signup page. We can also pass an error to render an additional error message\n- `chatTemplate` - Returns the HTML for the main chat page content (once a user is logged in)\n- `addUser(user)` is a function to add a new user to the user list on the left\n- `addMessage(message)` is a function to add a new message to the list. It will also make sure that we always scroll to the bottom of the message list as messages get added\n\n## Displaying pages\n\nNext, we'll add two functions to display the login and chat page, where we'll also add a list of the 25 newest chat messages and the registered users.\n\n```js\n// Show the login page\nconst showLogin = () => {\n  document.getElementById('app').innerHTML = loginTemplate()\n}\n\n// Shows the chat page\nconst showChat = async () => {\n  document.getElementById('app').innerHTML = chatTemplate()\n\n  // Find the latest 25 messages. They will come with the newest first\n  const messages = await client.service('messages').find({\n    query: {\n      $sort: { createdAt: -1 },\n      $limit: 25\n    }\n  })\n\n  // We want to show the newest message last\n  messages.data.reverse().forEach(addMessage)\n\n  // Find all users\n  const users = await client.service('users').find()\n\n  // Add each user to the list\n  users.data.forEach(addUser)\n}\n```\n\n- `showLogin(error)` will either show the content of loginTemplate or, if the login page is already showing, add an error message. This will happen when you try to log in with invalid credentials or sign up with a user that already exists.\n- `showChat()` does several things. First, we add the static chatTemplate to the page. Then we get the latest 25 messages from the messages Feathers service (this is the same as the `/messages` endpoint of our chat API) using the Feathers query syntax. Since the list will come back with the newest message first, we need to reverse the data. Then we add each message by calling our `addMessage` function so that it looks like a chat app shouldâ€Šâ€”â€Šwith old messages getting older as you scroll up. After that we get a list of all registered users to show them in the sidebar by calling addUser.\n\n## Login and signup\n\nAlright. Now we can show the login page (including an error message when something goes wrong) and if we are logged in, call the `showChat` we defined above. Weâ€™ve built out the UI, now we have to add the functionality to actually allow people to sign up, log in and also log out.\n\n```js\n// Retrieve email/password object from the login/signup page\nconst getCredentials = () => {\n  const user = {\n    email: document.querySelector('[name=\"email\"]').value,\n    password: document.querySelector('[name=\"password\"]').value\n  }\n\n  return user\n}\n\n// Log in either using the given email/password or the token from storage\nconst login = async (credentials) => {\n  try {\n    if (!credentials) {\n      // Try to authenticate using an existing token\n      await client.reAuthenticate()\n    } else {\n      // Otherwise log in with the `local` strategy using the credentials we got\n      await client.authenticate({\n        strategy: 'local',\n        ...credentials\n      })\n    }\n\n    // If successful, show the chat page\n    showChat()\n  } catch (error) {\n    // If we got an error, show the login page\n    showLogin(error)\n  }\n}\n```\n\n- `getCredentials()` gets us the values of the username (email) and password fields from the login/signup page to be used directly with Feathers authentication.\n- `login(credentials)` will either authenticate the credentials returned by getCredentials against our Feathers API using the local authentication strategy (e.g. username and password) or, if no credentials are given, try to use the JWT stored in localStorage. This will try and get the JWT from localStorage first where it is put automatically once you log in successfully so that we donâ€™t have to log in every time we visit the chat. Only if that doesnâ€™t work will it show the login page. Finally, if the login was successful it will show the chat page.\n\n## Event listeners and real-time\n\nIn the last step we will add event listeners for all buttons and functionality to send new messages and make the user and message list update in real-time.\n\n```js\nconst addEventListener = (selector, event, handler) => {\n  document.addEventListener(event, async (ev) => {\n    if (ev.target.closest(selector)) {\n      handler(ev)\n    }\n  })\n}\n\n// \"Signup and login\" button click handler\naddEventListener('#signup', 'click', async () => {\n  // For signup, create a new user and then log them in\n  const credentials = getCredentials()\n\n  // First create the user\n  await client.service('users').create(credentials)\n  // If successful log them in\n  await login(credentials)\n})\n\n// \"Login\" button click handler\naddEventListener('#login', 'click', async () => {\n  const user = getCredentials()\n\n  await login(user)\n})\n\n// \"Logout\" button click handler\naddEventListener('#logout', 'click', async () => {\n  await client.logout()\n\n  document.getElementById('app').innerHTML = loginTemplate()\n})\n\n// \"Send\" message form submission handler\naddEventListener('#send-message', 'submit', async (ev) => {\n  // This is the message text input field\n  const input = document.querySelector('[name=\"text\"]')\n\n  ev.preventDefault()\n\n  // Create a new message and then clear the input field\n  await client.service('messages').create({\n    text: input.value\n  })\n\n  input.value = ''\n})\n\n// Listen to created events and add the new message in real-time\nclient.service('messages').on('created', addMessage)\n\n// We will also see when new users get created in real-time\nclient.service('users').on('created', addUser)\n\n// Call login right away so we can show the chat window\n// If the user can already be authenticated\nlogin()\n```\n\n- `addEventListener` is a helper function that lets us add listeners to elements that get added or removed dynamically\n- We also added click event listeners for three buttons. `#login` will get the credentials and just log in with those. Clicking `#signup` will signup and log in at the same time. It will first create a new user on our API and then log in with that same user information. Finally, `#logout` will forget the JWT and then show the login page again.\n- The `#submit` button event listener gets the message text from the input field, creates a new message on the messages service and then clears out the field.\n- Next, we added two `created` event listeners. One for `messages` which calls the `addMessage` function to add the new message to the list and one for `users` which adds the user to the list via `addUser`. This is how Feathers does real-time and everything we need to do in order to get everything to update automatically.\n- To kick our application off, we call `login()` which as mentioned above will either show the chat application right away (if we signed in before and the token hasnâ€™t expired) or the login page.\n\n## Using the chat application\n\nThatâ€™s it. We now have a plain JavaScript real-time chat frontend with login and signup. This example demonstrates many of the basic principles of how you interact with a Feathers API. You can log in with the email (`hello@feathersjs.com`) and password (`supersecret`) from the user we registered in the [authentication chapter](../basics/authentication) or sign up and log in with a different email address.\n\nIf you run into an issue, remember you can find the complete working example at the [feathersjs/feathers-chat](https://github.com/feathersjs/feathers-chat) repository.",
    "rawContent": "## Set up the page\n\nFirst, let's update `public/index.html` to initialize everything we need for the chat frontend:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>feathers-chat</title>\n    <meta name=\"description\" content=\"A Feathers chat application\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link\n      href=\"https://cdn.jsdelivr.net/npm/tailwindcss@2.2/dist/tailwind.min.css\"\n      rel=\"stylesheet\"\n      type=\"text/css\"\n    />\n    <link href=\"https://cdn.jsdelivr.net/npm/daisyui@2.18.1/dist/full.css\" rel=\"stylesheet\" type=\"text/css\" />\n    <link rel=\"stylesheet\" href=\"https://dove.feathersjs.com/feathers-chat.css\" />\n  </head>\n  <body>\n    <div id=\"app\" data-theme=\"dracula\"></div>\n    <script src=\"https://unpkg.com/@feathersjs/client@^5.0.0-pre.34/dist/feathers.js\"></script>\n    <script src=\"/socket.io/socket.io.js\"></script>\n    <script type=\"module\" src=\"client.js\"></script>\n  </body>\n</html>\n```\n\nThis will load our chat CSS style, add a container div `#app` and load several libraries:\n\n- The browser version of Feathers (since we are not using a module loader like Webpack or Browserify)\n- Socket.io provided by the chat API\n- [daisyUI](https://daisyui.com/) for a collection of CSS components\n- A `client.js` for our code to live in\n\nLetâ€™s create `public/client.js` where all the following code will live. Each of the following code samples should be added to the end of that file.\n\n## Connect to the API\n\nWeâ€™ll start with the most important thing first, the connection to our Feathers API that connects to our server using websockets and initializes the [authentication client](../basics/authentication):\n\n```js\n/* global io, feathers, moment */\n// Establish a Socket.io connection\nconst socket = io()\n// Initialize our Feathers client application through Socket.io\n// with hooks and authentication.\nconst client = feathers()\n\nclient.configure(feathers.socketio(socket))\n// Use localStorage to store our login token\nclient.configure(feathers.authentication())\n```\n\n## Base HTML\n\nNext, we have to define some static and dynamic HTML that we can insert into the page when we want to show the login page (which also doubles as the signup page) and the actual chat interface:\n\n```js\n// Login screen\nconst loginTemplate = (error) => `<div class=\"login flex min-h-screen bg-neutral justify-center items-center\">\n<div class=\"card w-full max-w-sm bg-base-100 px-4 py-8 shadow-xl\">\n  <div class=\"px-4\"><i alt=\"\" class=\"h-32 w-32 block mx-auto i-logos-feathersjs invert\"></i>\n    <h1 class=\"text-5xl font-bold text-center my-5 bg-clip-text bg-gradient-to-br\">\n      Feathers Chat\n    </h1>\n  </div>\n  <form class=\"card-body pt-2\">\n    ${\n      error\n        ? `<div class=\"alert alert-error justify-start\">\n      <i class=\"i-feather-alert-triangle\"></i>\n      <span class=\"flex-grow\">${error.message}</span>\n    </div>`\n        : ''\n    }\n    <div class=\"form-control\">\n      <label for=\"email\" class=\"label\"><span class=\"label-text\">Email</span></label>\n      <input type=\"text\" name=\"email\" placeholder=\"enter email\" class=\"input input-bordered\">\n    </div>\n    <div class=\"form-control mt-0\">\n      <label for=\"password\" class=\"label\"><span class=\"label-text\">Password</span></label>\n      <input type=\"password\" name=\"password\" placeholder=\"enter password\" class=\"input input-bordered\">\n    </div>\n    <div class=\"form-control mt-6\"><button id=\"login\" type=\"button\" class=\"btn\">Login</button></div>\n    <div class=\"form-control mt-6\"><button id=\"signup\" type=\"button\" class=\"btn\">Signup</button></div>\n    <div class=\"form-control mt-6\"><a href=\"/oauth/github\" id=\"github\" class=\"btn\">Login with GitHub</a></div>\n  </form>\n</div>\n</div>`\n\n// Main chat view\nconst chatTemplate =\n  () => `<div class=\"drawer drawer-mobile\"><input id=\"drawer-left\" type=\"checkbox\" class=\"drawer-toggle\">\n  <div class=\"drawer-content flex flex-col\">\n    <div class=\"navbar w-full\">\n      <div class=\"navbar-start\">\n        <label for=\"drawer-left\" class=\"btn btn-square btn-ghost lg:hidden drawer-button\">\n          <i class=\"i-feather-menu text-lg\"></i>\n        </label>\n      </div>\n      <div class=\"navbar-center flex flex-col\">\n        <p>Feathers Chat</p>\n        <label for=\"drawer-right\" class=\"text-xs cursor-pointer\">\n          <span class=\"online-count\">0</span> User(s)\n        </label>\n      </div>\n      <div class=\"navbar-end\">\n        <div class=\"tooltip tooltip-left\" data-tip=\"Logout\">\n        <button type=\"button\" id=\"logout\" class=\"btn btn-ghost\"><i class=\"i-feather-log-out text-lg\"></i></button>\n      </div>\n      </div>\n    </div>\n    <div id=\"chat\" class=\"h-full overflow-y-auto px-3\"></div>\n    <div class=\"form-control w-full py-2 px-3\">\n      <form class=\"input-group overflow-hidden\" id=\"send-message\">\n        <input name=\"text\" type=\"text\" placeholder=\"Compose message\" class=\"input input-bordered w-full\">\n        <button type=\"submit\" class=\"btn\">Send</button>\n      </form>\n    </div>\n  </div>\n  <div class=\"drawer-side\"><label for=\"drawer-left\" class=\"drawer-overlay\"></label>\n    <ul class=\"menu user-list compact p-2 overflow-y-auto w-60 bg-base-300 text-base-content\">\n      <li class=\"menu-title\"><span>Users</span></li>\n    </ul>\n  </div>\n</div>`\n\n// Helper to safely escape HTML\nconst escapeHTML = (str) => str.replace(/&/g, '&amp').replace(/</g, '&lt').replace(/>/g, '&gt')\n\nconst formatDate = (timestamp) =>\n  new Intl.DateTimeFormat('en-US', {\n    timeStyle: 'short',\n    dateStyle: 'medium'\n  }).format(new Date(timestamp))\n\n// Add a new user to the list\nconst addUser = (user) => {\n  const userList = document.querySelector('.user-list')\n\n  if (userList) {\n    // Add the user to the list\n    userList.innerHTML += `<li class=\"user\">\n      <a>\n        <div class=\"avatar indicator\">\n          <div class=\"w-6 rounded\"><img src=\"${user.avatar}\" alt=\"${user.email}\"></div>\n        </div><span>${user.email}</span>\n      </a>\n    </li>`\n\n    // Update the number of users\n    const userCount = document.querySelectorAll('.user-list li.user').length\n\n    document.querySelector('.online-count').innerHTML = userCount\n  }\n}\n\n// Renders a message to the page\nconst addMessage = (message) => {\n  // The user that sent this message (added by the populate-user hook)\n  const { user = {} } = message\n  const chat = document.querySelector('#chat')\n  // Escape HTML to prevent XSS attacks\n  const text = escapeHTML(message.text)\n\n  if (chat) {\n    chat.innerHTML += `<div class=\"chat chat-start py-2\">\n      <div class=\"chat-image avatar\">\n        <div class=\"w-10 rounded-full\">\n          <img src=\"${user.avatar}\" />\n        </div>\n      </div>\n      <div class=\"chat-header pb-1\">\n        ${user.email}\n        <time class=\"text-xs opacity-50\">${formatDate(message.createdAt)}</time>\n      </div>\n      <div class=\"chat-bubble\">${text}</div>\n    </div>`\n\n    // Always scroll to the bottom of our message list\n    chat.scrollTop = chat.scrollHeight - chat.clientHeight\n  }\n}\n```\n\nThis will add the following variables and functions:\n\n- `loginTemplate` - A function that returns static HTML for the login/signup page. We can also pass an error to render an additional error message\n- `chatTemplate` - Returns the HTML for the main chat page content (once a user is logged in)\n- `addUser(user)` is a function to add a new user to the user list on the left\n- `addMessage(message)` is a function to add a new message to the list. It will also make sure that we always scroll to the bottom of the message list as messages get added\n\n## Displaying pages\n\nNext, we'll add two functions to display the login and chat page, where we'll also add a list of the 25 newest chat messages and the registered users.\n\n```js\n// Show the login page\nconst showLogin = () => {\n  document.getElementById('app').innerHTML = loginTemplate()\n}\n\n// Shows the chat page\nconst showChat = async () => {\n  document.getElementById('app').innerHTML = chatTemplate()\n\n  // Find the latest 25 messages. They will come with the newest first\n  const messages = await client.service('messages').find({\n    query: {\n      $sort: { createdAt: -1 },\n      $limit: 25\n    }\n  })\n\n  // We want to show the newest message last\n  messages.data.reverse().forEach(addMessage)\n\n  // Find all users\n  const users = await client.service('users').find()\n\n  // Add each user to the list\n  users.data.forEach(addUser)\n}\n```\n\n- `showLogin(error)` will either show the content of loginTemplate or, if the login page is already showing, add an error message. This will happen when you try to log in with invalid credentials or sign up with a user that already exists.\n- `showChat()` does several things. First, we add the static chatTemplate to the page. Then we get the latest 25 messages from the messages Feathers service (this is the same as the `/messages` endpoint of our chat API) using the Feathers query syntax. Since the list will come back with the newest message first, we need to reverse the data. Then we add each message by calling our `addMessage` function so that it looks like a chat app shouldâ€Šâ€”â€Šwith old messages getting older as you scroll up. After that we get a list of all registered users to show them in the sidebar by calling addUser.\n\n## Login and signup\n\nAlright. Now we can show the login page (including an error message when something goes wrong) and if we are logged in, call the `showChat` we defined above. Weâ€™ve built out the UI, now we have to add the functionality to actually allow people to sign up, log in and also log out.\n\n```js\n// Retrieve email/password object from the login/signup page\nconst getCredentials = () => {\n  const user = {\n    email: document.querySelector('[name=\"email\"]').value,\n    password: document.querySelector('[name=\"password\"]').value\n  }\n\n  return user\n}\n\n// Log in either using the given email/password or the token from storage\nconst login = async (credentials) => {\n  try {\n    if (!credentials) {\n      // Try to authenticate using an existing token\n      await client.reAuthenticate()\n    } else {\n      // Otherwise log in with the `local` strategy using the credentials we got\n      await client.authenticate({\n        strategy: 'local',\n        ...credentials\n      })\n    }\n\n    // If successful, show the chat page\n    showChat()\n  } catch (error) {\n    // If we got an error, show the login page\n    showLogin(error)\n  }\n}\n```\n\n- `getCredentials()` gets us the values of the username (email) and password fields from the login/signup page to be used directly with Feathers authentication.\n- `login(credentials)` will either authenticate the credentials returned by getCredentials against our Feathers API using the local authentication strategy (e.g. username and password) or, if no credentials are given, try to use the JWT stored in localStorage. This will try and get the JWT from localStorage first where it is put automatically once you log in successfully so that we donâ€™t have to log in every time we visit the chat. Only if that doesnâ€™t work will it show the login page. Finally, if the login was successful it will show the chat page.\n\n## Event listeners and real-time\n\nIn the last step we will add event listeners for all buttons and functionality to send new messages and make the user and message list update in real-time.\n\n```js\nconst addEventListener = (selector, event, handler) => {\n  document.addEventListener(event, async (ev) => {\n    if (ev.target.closest(selector)) {\n      handler(ev)\n    }\n  })\n}\n\n// \"Signup and login\" button click handler\naddEventListener('#signup', 'click', async () => {\n  // For signup, create a new user and then log them in\n  const credentials = getCredentials()\n\n  // First create the user\n  await client.service('users').create(credentials)\n  // If successful log them in\n  await login(credentials)\n})\n\n// \"Login\" button click handler\naddEventListener('#login', 'click', async () => {\n  const user = getCredentials()\n\n  await login(user)\n})\n\n// \"Logout\" button click handler\naddEventListener('#logout', 'click', async () => {\n  await client.logout()\n\n  document.getElementById('app').innerHTML = loginTemplate()\n})\n\n// \"Send\" message form submission handler\naddEventListener('#send-message', 'submit', async (ev) => {\n  // This is the message text input field\n  const input = document.querySelector('[name=\"text\"]')\n\n  ev.preventDefault()\n\n  // Create a new message and then clear the input field\n  await client.service('messages').create({\n    text: input.value\n  })\n\n  input.value = ''\n})\n\n// Listen to created events and add the new message in real-time\nclient.service('messages').on('created', addMessage)\n\n// We will also see when new users get created in real-time\nclient.service('users').on('created', addUser)\n\n// Call login right away so we can show the chat window\n// If the user can already be authenticated\nlogin()\n```\n\n- `addEventListener` is a helper function that lets us add listeners to elements that get added or removed dynamically\n- We also added click event listeners for three buttons. `#login` will get the credentials and just log in with those. Clicking `#signup` will signup and log in at the same time. It will first create a new user on our API and then log in with that same user information. Finally, `#logout` will forget the JWT and then show the login page again.\n- The `#submit` button event listener gets the message text from the input field, creates a new message on the messages service and then clears out the field.\n- Next, we added two `created` event listeners. One for `messages` which calls the `addMessage` function to add the new message to the list and one for `users` which adds the user to the list via `addUser`. This is how Feathers does real-time and everything we need to do in order to get everything to update automatically.\n- To kick our application off, we call `login()` which as mentioned above will either show the chat application right away (if we signed in before and the token hasnâ€™t expired) or the login page.\n\n## Using the chat application\n\nThatâ€™s it. We now have a plain JavaScript real-time chat frontend with login and signup. This example demonstrates many of the basic principles of how you interact with a Feathers API. You can log in with the email (`hello@feathersjs.com`) and password (`supersecret`) from the user we registered in the [authentication chapter](../basics/authentication) or sign up and log in with a different email address.\n\nIf you run into an issue, remember you can find the complete working example at the [feathersjs/feathers-chat](https://github.com/feathersjs/feathers-chat) repository.",
    "breadcrumb": "JavaScript web app",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/frontend/javascript.md",
    "heading": "JavaScript web app",
    "subHeadings": [
      "Set up the page",
      "Connect to the API",
      "Base HTML",
      "Displaying pages",
      "Login and signup",
      "Event listeners and real-time",
      "Using the chat application"
    ],
    "hasCode": true,
    "codeLanguages": [
      "html",
      "text",
      "js"
    ],
    "tokens": 3637,
    "category": "guides",
    "tags": [
      "hooks",
      "authentication",
      "jwt",
      "oauth",
      "real-time",
      "websockets",
      "events",
      "find",
      "get",
      "create",
      "update",
      "remove",
      "feathers client",
      "socket.io",
      "application"
    ]
  },
  {
    "id": "v6-index-0",
    "content": "# Getting started with Feathers\nBreadcrumb: Getting started with Feathers\nCovers: The Feathers guide | Follow up with | More about Feathers how and why\nTopics: hooks, services, authentication, real-time, get, application\n\n## The Feathers guide\n\nThe Feathers guide will walk you through all the important parts of Feathers. The [quick start](./basics/starting) gets you up and running with a Feathers API and real-time website in less than 15 minutes from scratch to give you an idea what Feathers is about.\n\nIn the next parts we will [generate an application](./basics/generator) and then walk through Feathers core concepts like services, hooks and authentication by building a complete real-time chat application with an API and a website that can register users and send and receive messages in real-time. We will also add a login with GitHub and write unit tests for our API.\n\n[Get started with the Feathers guide >](./basics/starting)\n\n## Follow up with\n\n[The API documentation >](../api/)\n\n[The cookbook for common tasks and patterns >](../cookbook/)\n\n[The Awesome FeathersJS Ecosystem >](https://github.com/feathersjs/awesome-feathersjs)\n\n[Feathers on YouTube >](https://www.youtube.com/playlist?list=PLwSdIiqnDlf_lb5y1liQK2OW5daXYgKOe)\n\n## More about Feathers how and why\n\n[Read about the philosophy behind Feathers and where it came from >](https://blog.feathersjs.com/why-we-built-the-best-web-framework-you-ve-probably-never-heard-of-until-now-176afc5c6aac)\n\n[Learn about the high level design patterns behind Feathers >](https://blog.feathersjs.com/design-patterns-for-modern-web-apis-1f046635215)",
    "rawContent": "## The Feathers guide\n\nThe Feathers guide will walk you through all the important parts of Feathers. The [quick start](./basics/starting) gets you up and running with a Feathers API and real-time website in less than 15 minutes from scratch to give you an idea what Feathers is about.\n\nIn the next parts we will [generate an application](./basics/generator) and then walk through Feathers core concepts like services, hooks and authentication by building a complete real-time chat application with an API and a website that can register users and send and receive messages in real-time. We will also add a login with GitHub and write unit tests for our API.\n\n[Get started with the Feathers guide >](./basics/starting)\n\n## Follow up with\n\n[The API documentation >](../api/)\n\n[The cookbook for common tasks and patterns >](../cookbook/)\n\n[The Awesome FeathersJS Ecosystem >](https://github.com/feathersjs/awesome-feathersjs)\n\n[Feathers on YouTube >](https://www.youtube.com/playlist?list=PLwSdIiqnDlf_lb5y1liQK2OW5daXYgKOe)\n\n## More about Feathers how and why\n\n[Read about the philosophy behind Feathers and where it came from >](https://blog.feathersjs.com/why-we-built-the-best-web-framework-you-ve-probably-never-heard-of-until-now-176afc5c6aac)\n\n[Learn about the high level design patterns behind Feathers >](https://blog.feathersjs.com/design-patterns-for-modern-web-apis-1f046635215)",
    "breadcrumb": "Getting started with Feathers",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/index.md",
    "heading": "Getting started with Feathers",
    "subHeadings": [
      "The Feathers guide",
      "Follow up with",
      "More about Feathers how and why"
    ],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 347,
    "category": "guides",
    "tags": [
      "hooks",
      "services",
      "authentication",
      "real-time",
      "get",
      "application"
    ]
  },
  {
    "id": "v6-migrating-0",
    "content": "# Migrating to v5\nBreadcrumb: Migrating to v5\nCovers: Testing the prerelease | New Features | Core SQL and MongoDB | TypeScript | Application and hook context | Service types | Configuration types | Typed params and query | Deprecations and breaking changes | Express middleware order | Core named export | Custom Filters & Operators | Asynchronous setup | Socket.io 4 and Grant 5 | Configuration | Debugging | Client | Removed Primus Transport | Changes to WebSockets | NotFound for `app.service` | Removed `service.mixin()` | `finally` hook | Other internal changes\nTopics: hooks, services, context, params, provider, authentication, oauth, schema, resolver, database, adapter, mongodb, knex, websockets, rest, get, create, update, remove, hook context, feathers client, socket.io, middleware, setup, application\n\n## Testing the prerelease\n\nYou can run the following to upgrade all Feathers core packages:\n\n```\nnpx npm-check-updates --upgrade --filter /@feathersjs/\nnpm install\n```\n\nYou can see the migration steps necessary for the Feathers chat [here for Javascript](https://github.com/feathersjs/feathers-chat/compare/dove-pre) and [here for TypeScript](https://github.com/feathersjs/feathers-chat-ts/compare/dove-pre).\n\n## New Features\n\nThere are so many new features in this release that they got their own page! Read about the new features on the [What's New in v5](./whats-new) page.\n\n## Core SQL and MongoDB\n\nThe new [schemas and resolvers](../api/schema/index) cover most use cases previously provided by higher level ORMs like Sequelize or Mongoose in a more flexible and Feathers friendly way. This allows for a better database integration into Feathers without the overhead of a full ORM which is why the more low level [MongoDB](../api/databases/mongodb) and [Knex](../api/databases/knex) (SQL) database adapters have been moved into Feathers core for first-class SQL and MongoDB database support.\n\n## TypeScript\n\nThe new version comes with major improvements in TypeScript support from improved service typings, fully typed hook context and typed configuration. You can see the changes necessary in the Feathers chat [here](https://github.com/feathersjs/feathers-chat-ts/compare/dove-pre).\n\n### Application and hook context\n\nTo get the typed hook context and application configuration update your `declarations.ts` as follows:\n\n```ts\nimport '@feathersjs/transport-commons'\nimport { Application as ExpressFeathers } from '@feathersjs/express'\nimport { HookContext as FeathersHookContext } from '@feathersjs/feathers'\n\nexport interface Configuration {\n  // Put types for app.get and app.set here\n  port: number\n}\n// A mapping of service names to types. Will be extended in service files.\nexport interface ServiceTypes {}\n// The application instance type that will be used everywhere else\nexport type Application = ExpressFeathers<ServiceTypes, Configuration>\nexport type HookContext = FeathersHookContext<Application>\n```\n\nNow `import { HookContext } from './declarations'` can be used as the context in hooks.\n\n### Service types\n\nService types now only need the actual service class type and should no longer include the `& ServiceAddons<any>`. E.g. for the messages service like this:\n\n```ts\n// Add this service to the service type index\ndeclare module '../../declarations' {\n  interface ServiceTypes {\n    messages: Messages\n  }\n}\n```\n\n### Configuration types\n\nA Feathers application can now also include types for the values of `app.set` and `app.get`. The configuration can also be validated and the type inferred from a [Feathers schema](../api/schema/index).\n\n### Typed params and query\n\nService `Params` no longer include a catchall property type and need to be explicitly declared for services that use extended `params`. It is also possible to pass your own query type to use with `params.query`:\n\n```ts\nimport { Params } from '@feathersjs/feathers'\n\nexport type MyQuery = {\n  name: string\n}\n\nexport interface MyServiceParams extends Params<MyQuery> {\n  user: User\n}\n```\n\nYou can revert to the previous behaviour by overriding he `Params` declaration:\n\n```ts\ndeclare module '@feathersjs/feathers/lib/declarations' {\n  interface Params {\n    [key: string]: any\n  }\n}\n```\n\n## Deprecations and breaking changes\n\n\n\n### Express middleware order\n\nThe Express `rest` adapter now needs to be configured in the correct order, usually right after the `json()` middleware and before any services are registered. This is already the case in generated applications but it may have to be adjusted in a custom setup.\n\n### Core named export\n\nThe import of `feathers` has changed from\n\n```ts\nconst feathers = require('@feathersjs/feathers')\n\nimport feathers from '@feathersjs/feathers'\n```\n\nTo\n\n```ts\nconst { feathers } = require('@feathersjs/feathers')\n\nimport { feathers } from '@feathersjs/feathers'\n```\n\nThe Express exports for TypeScript have changed from\n\n```ts\nimport express from '@feathersjs/express'\n\napp.use(express.json())\napp.use(express.urlencoded())\napp.use(express.notFound())\napp.use(express.errorHandler())\n```\n\nTo\n\n```ts\nimport express, { json, urlencoded, notFound, errorHandler } from '@feathersjs/express'\n\napp.use(json())\napp.use(urlencoded())\napp.use(notFound())\napp.use(errorHandler())\n```\n\n### Custom Filters & Operators\n\n<BlockQuote type=\"warning\">\nWe are exploring the best migration strategy to replace \"whitelisting\" options with a solution based on [Feathers schema](/api/schema/index). We'll update this guide once the solution is in place.\n</BlockQuote>\n\nThe `whitelist` option is now split into two options: `operators` and `filters`. To migrate, you need to figure out how you're using each item from your old `whitelist`, then move them to the correct option. You can determine if each one is a filter or an operator based on where it is used in a query.\n\n- `filters` are top-level query properties.\n- `operators` are positioned under an attribute.\n\nIn the below example, `$customFilter` would be a filter, `$regex` and `$options` would be operators.\n\n```ts\nconst query = {\n  $customFilter: 'value',\n  name: {\n    $regex: /pattern/,\n    $options: 'igm'\n  }\n}\n```\n\nFor v5 service adapters, split the `whitelist` options into the `filters` object or the `operators` array.\n\n```ts\n// ðŸ‘Ž`whitelist` and `allow are unsupported.\nconst oldServiceOptions = {\n  whitelist: ['$customFilter', '$ignoreCase', '$regex', '$options']\n}\n\n// ðŸ‘ Separate items into `filters` and `operators` for v5 service adapters\nconst serviceOptions = {\n  filters: {\n    // Map a custom filter to a converter function\n    $ignoreCase: (value: any) => (value === 'true' ? true : false),\n    // Enable a custom param without converting\n    $customQueryOperator: true\n  } as const,\n  operators: ['$regex', '$options']\n}\n```\n\nIf you're using TypeScript, notice the `as const` after the `filters` object in the options, above. That will keep type errors from happening when passing the `serviceOptions` to the service.\n\n<BlockQuote type=\"note\">\nThis change only affects service adapters that have been upgraded to v5, like [@feathersjs/mongodb](/api/databases/mongodb), [@feathersjs/knex](/api/databases/knex), and [@feathersjs/memory](/api/databases/memory). This also applies to any community-supported adapters which have been upgraded to v5. If you use a v4 adapter for a service in your v5 app, you do not need to make this change for that service.\n</BlockQuote>\n\n### Asynchronous setup\n\n`service.setup`, `app.setup` and `app.listen` return a Promise:\n\n```js\n// Before\nconst server = app.listen(3030)\n\n// Now\napp.listen(3030).then((server) => {})\n```\n\nUsually you would call `app.listen`. In case you are calling `app.setup` instead (e.g. for internal jobs or seed scripts) it is now also asynchronous:\n\n```js\n// Before\napp.setup()\n// Do something here\n\n// Now\nawait app.setup()\n// Do something here\n```\n\n### Socket.io 4 and Grant 5\n\nThe Socket.io and Grant (oAuth) dependencies have been updated to their latest versions. For more information on breaking changes see:\n\n- The Socket.io [version 3](https://socket.io/docs/v3/migrating-from-2-x-to-3-0/index.html#How-to-upgrade-an-existing-production-deployment) and [version 4](https://socket.io/docs/v3/migrating-from-3-x-to-4-0/) upgrade guide. Important points to note are a new improved [CORS policy](https://socket.io/docs/v3/migrating-from-2-x-to-3-0/index.html#CORS-handling) and an [explicit v2 client compatibility opt-in](https://socket.io/docs/v3/migrating-from-2-x-to-3-0/index.html#How-to-upgrade-an-existing-production-deployment)\n- For oAuth authentication the Grant standard configuration should continue to work as is. If you customized any other settings, see the [Grant v4 to v5 migration guide](https://github.com/simov/grant/blob/master/MIGRATION) for the changes necessary.\n\n### Configuration\n\nThe automatic environment variable substitution in `@feathersjs/configuration` was causing subtle and hard to debug issues. It has been removed to instead rely on the functionality already provided and battle tested by the underlying [node-config](https://github.com/lorenwest/node-config). To update your configuration:\n\n- Relative paths are no longer relative to the configuration file, but instead to where the application runs. This normally (when running from the application folder) means that paths starting with `../` and `./` have to be replaced with `./` and `./config/`.\n- Configuration through environment variables should be included via the `NODE_CONFIG` JSON string or as [Custom Environment Variable support](https://github.com/lorenwest/node-config/wiki/Environment-Variables#custom-environment-variables). To use existing environment variables add the following configuration file in `config/custom-environment-variables.json` like this:\n\n```json\n// config/custom-environment-variables.json\n{\n  \"hostname\": \"HOSTNAME\",\n  \"port\": \"PORT\",\n  \"someSetting\": {\n    \"apiKey\": \"MY_CUSTOM_API_KEY\"\n  }\n}\n```\n\n### Debugging\n\nThe `debug` module has been removed as a direct dependency. This reduces the the client bundle size and allows to support other platforms (like Deno). The original `debug` functionality can now be initialized as follows:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport debug from 'debug'\n\nfeathers.setDebug(debug)\n```\n\nIt is also possible to set a custom logger like this:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\n\nconst customDebug =\n  (name) =>\n  (...args) => {\n    console.log(name, ...args)\n  }\n\nfeathers.setDebug(customDebug)\n```\n\nSetting the debugger will apply to all `@feathersjs` modules.\n\n### Client\n\n- The `request` library has been deprecated and request support has been removed from the REST client.\n- Since all modern browsers now support built-in [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), the Angular and jQuery REST clients have been removed as well.\n- The `@feathersjs/client` package now only comes with a full (`dist/feathers.js`) and core (`dist/core.js`) browser build. Using Feathers [with a module loader](../api/client#module-loaders) is recommended for all other use cases.\n\n### Removed Primus Transport\n\nDue to low usage `@feathersjs/primus` and `@feathers/primus-client` have been removed from Feathers core.\n\n### Changes to WebSockets\n\n#### Legacy Socket Format\n\nThe legacy `servicename::method` socket message format has been deprecated since Feathers 3 and has now been removed. Use a v3 or later [Feathers client](../api/client) or the [current Socket.io direct connection API](../api/client/socketio).\n\n#### Timeouts\n\nThe `timeout` setting for socket services has been removed. It was mainly intended as a fallback for the old message format and interfered with the underlying timeout and retry mechanism provided by the websocket libraries themselves.\n\n### NotFound for `app.service`\n\nBy default, when getting a non existing service via `app.service('something')` on the server, it will now throw a `NotFound` error instead of returning `undefined`. The previous behaviour can be restored by setting [app.defaultService](../api/application#defaultservice):\n\n```js\napp.defaultService = () => {\n  return null // undefined\n}\n```\n\n### Removed `service.mixin()`\n\nServices are no longer Uberproto (an ES5 inheritance utility) objects and instead rely on modern JavaScript classes and extension. This means `app.service(name).mixin(data)` is no longer available which can be replaced with a basic `Object.assign(app.service(name), data)`:\n\n```js\n// Before\napp.mixins.push((service, path) => {\n  service.mixin({\n    create(data, params) {\n      // do something here\n      return this._super(data, params)\n    }\n  })\n})\n\n// Now\napp.mixins.push((service, path) => {\n  const { create } = service\n\n  Object.assign(service, {\n    create(data, params) {\n      // do something here, then invoke the old method\n      // through normal JavaScript functionality\n      return create.call(this, data, params)\n    }\n  })\n})\n```\n\n### `finally` hook\n\nThe undocumented `finally` hook type is no longer available and should be replaced by the new `around` hooks which offer the same functionality using plain JavaScript:\n\n```js\napp.service('myservice').hooks([\n  async (context, next) => {\n    try {\n      await next()\n    } finally {\n      // Do finally hook stuff here\n    }\n  }\n])\n```\n\n### Other internal changes\n\n- The undocumented `service._setup` method introduced in v1 will no longer be called. It was used to circumvent middleware inconsistencies from Express 3 and is no longer necessary.\n- The undocumented `app.providers` has been removed since it provided the same functionality as [`app.mixins`](../api/application#mixins)\n- `app.disable`, `app.disabled`, `app.enable` and `app.enabled` have been removed from basic Feathers applications. It will still be available in an Express-compatible Feathers application. `app.get()` and `app.set()` should be used instead.\n- The `req.authentication` property is no longer set on the express requests, use `req.feathers.authentication` instead.",
    "rawContent": "## Testing the prerelease\n\nYou can run the following to upgrade all Feathers core packages:\n\n```\nnpx npm-check-updates --upgrade --filter /@feathersjs/\nnpm install\n```\n\nYou can see the migration steps necessary for the Feathers chat [here for Javascript](https://github.com/feathersjs/feathers-chat/compare/dove-pre) and [here for TypeScript](https://github.com/feathersjs/feathers-chat-ts/compare/dove-pre).\n\n## New Features\n\nThere are so many new features in this release that they got their own page! Read about the new features on the [What's New in v5](./whats-new) page.\n\n## Core SQL and MongoDB\n\nThe new [schemas and resolvers](../api/schema/index) cover most use cases previously provided by higher level ORMs like Sequelize or Mongoose in a more flexible and Feathers friendly way. This allows for a better database integration into Feathers without the overhead of a full ORM which is why the more low level [MongoDB](../api/databases/mongodb) and [Knex](../api/databases/knex) (SQL) database adapters have been moved into Feathers core for first-class SQL and MongoDB database support.\n\n## TypeScript\n\nThe new version comes with major improvements in TypeScript support from improved service typings, fully typed hook context and typed configuration. You can see the changes necessary in the Feathers chat [here](https://github.com/feathersjs/feathers-chat-ts/compare/dove-pre).\n\n### Application and hook context\n\nTo get the typed hook context and application configuration update your `declarations.ts` as follows:\n\n```ts\nimport '@feathersjs/transport-commons'\nimport { Application as ExpressFeathers } from '@feathersjs/express'\nimport { HookContext as FeathersHookContext } from '@feathersjs/feathers'\n\nexport interface Configuration {\n  // Put types for app.get and app.set here\n  port: number\n}\n// A mapping of service names to types. Will be extended in service files.\nexport interface ServiceTypes {}\n// The application instance type that will be used everywhere else\nexport type Application = ExpressFeathers<ServiceTypes, Configuration>\nexport type HookContext = FeathersHookContext<Application>\n```\n\nNow `import { HookContext } from './declarations'` can be used as the context in hooks.\n\n### Service types\n\nService types now only need the actual service class type and should no longer include the `& ServiceAddons<any>`. E.g. for the messages service like this:\n\n```ts\n// Add this service to the service type index\ndeclare module '../../declarations' {\n  interface ServiceTypes {\n    messages: Messages\n  }\n}\n```\n\n### Configuration types\n\nA Feathers application can now also include types for the values of `app.set` and `app.get`. The configuration can also be validated and the type inferred from a [Feathers schema](../api/schema/index).\n\n### Typed params and query\n\nService `Params` no longer include a catchall property type and need to be explicitly declared for services that use extended `params`. It is also possible to pass your own query type to use with `params.query`:\n\n```ts\nimport { Params } from '@feathersjs/feathers'\n\nexport type MyQuery = {\n  name: string\n}\n\nexport interface MyServiceParams extends Params<MyQuery> {\n  user: User\n}\n```\n\nYou can revert to the previous behaviour by overriding he `Params` declaration:\n\n```ts\ndeclare module '@feathersjs/feathers/lib/declarations' {\n  interface Params {\n    [key: string]: any\n  }\n}\n```\n\n## Deprecations and breaking changes\n\n\n\n### Express middleware order\n\nThe Express `rest` adapter now needs to be configured in the correct order, usually right after the `json()` middleware and before any services are registered. This is already the case in generated applications but it may have to be adjusted in a custom setup.\n\n### Core named export\n\nThe import of `feathers` has changed from\n\n```ts\nconst feathers = require('@feathersjs/feathers')\n\nimport feathers from '@feathersjs/feathers'\n```\n\nTo\n\n```ts\nconst { feathers } = require('@feathersjs/feathers')\n\nimport { feathers } from '@feathersjs/feathers'\n```\n\nThe Express exports for TypeScript have changed from\n\n```ts\nimport express from '@feathersjs/express'\n\napp.use(express.json())\napp.use(express.urlencoded())\napp.use(express.notFound())\napp.use(express.errorHandler())\n```\n\nTo\n\n```ts\nimport express, { json, urlencoded, notFound, errorHandler } from '@feathersjs/express'\n\napp.use(json())\napp.use(urlencoded())\napp.use(notFound())\napp.use(errorHandler())\n```\n\n### Custom Filters & Operators\n\n<BlockQuote type=\"warning\">\nWe are exploring the best migration strategy to replace \"whitelisting\" options with a solution based on [Feathers schema](/api/schema/index). We'll update this guide once the solution is in place.\n</BlockQuote>\n\nThe `whitelist` option is now split into two options: `operators` and `filters`. To migrate, you need to figure out how you're using each item from your old `whitelist`, then move them to the correct option. You can determine if each one is a filter or an operator based on where it is used in a query.\n\n- `filters` are top-level query properties.\n- `operators` are positioned under an attribute.\n\nIn the below example, `$customFilter` would be a filter, `$regex` and `$options` would be operators.\n\n```ts\nconst query = {\n  $customFilter: 'value',\n  name: {\n    $regex: /pattern/,\n    $options: 'igm'\n  }\n}\n```\n\nFor v5 service adapters, split the `whitelist` options into the `filters` object or the `operators` array.\n\n```ts\n// ðŸ‘Ž`whitelist` and `allow are unsupported.\nconst oldServiceOptions = {\n  whitelist: ['$customFilter', '$ignoreCase', '$regex', '$options']\n}\n\n// ðŸ‘ Separate items into `filters` and `operators` for v5 service adapters\nconst serviceOptions = {\n  filters: {\n    // Map a custom filter to a converter function\n    $ignoreCase: (value: any) => (value === 'true' ? true : false),\n    // Enable a custom param without converting\n    $customQueryOperator: true\n  } as const,\n  operators: ['$regex', '$options']\n}\n```\n\nIf you're using TypeScript, notice the `as const` after the `filters` object in the options, above. That will keep type errors from happening when passing the `serviceOptions` to the service.\n\n<BlockQuote type=\"note\">\nThis change only affects service adapters that have been upgraded to v5, like [@feathersjs/mongodb](/api/databases/mongodb), [@feathersjs/knex](/api/databases/knex), and [@feathersjs/memory](/api/databases/memory). This also applies to any community-supported adapters which have been upgraded to v5. If you use a v4 adapter for a service in your v5 app, you do not need to make this change for that service.\n</BlockQuote>\n\n### Asynchronous setup\n\n`service.setup`, `app.setup` and `app.listen` return a Promise:\n\n```js\n// Before\nconst server = app.listen(3030)\n\n// Now\napp.listen(3030).then((server) => {})\n```\n\nUsually you would call `app.listen`. In case you are calling `app.setup` instead (e.g. for internal jobs or seed scripts) it is now also asynchronous:\n\n```js\n// Before\napp.setup()\n// Do something here\n\n// Now\nawait app.setup()\n// Do something here\n```\n\n### Socket.io 4 and Grant 5\n\nThe Socket.io and Grant (oAuth) dependencies have been updated to their latest versions. For more information on breaking changes see:\n\n- The Socket.io [version 3](https://socket.io/docs/v3/migrating-from-2-x-to-3-0/index.html#How-to-upgrade-an-existing-production-deployment) and [version 4](https://socket.io/docs/v3/migrating-from-3-x-to-4-0/) upgrade guide. Important points to note are a new improved [CORS policy](https://socket.io/docs/v3/migrating-from-2-x-to-3-0/index.html#CORS-handling) and an [explicit v2 client compatibility opt-in](https://socket.io/docs/v3/migrating-from-2-x-to-3-0/index.html#How-to-upgrade-an-existing-production-deployment)\n- For oAuth authentication the Grant standard configuration should continue to work as is. If you customized any other settings, see the [Grant v4 to v5 migration guide](https://github.com/simov/grant/blob/master/MIGRATION) for the changes necessary.\n\n### Configuration\n\nThe automatic environment variable substitution in `@feathersjs/configuration` was causing subtle and hard to debug issues. It has been removed to instead rely on the functionality already provided and battle tested by the underlying [node-config](https://github.com/lorenwest/node-config). To update your configuration:\n\n- Relative paths are no longer relative to the configuration file, but instead to where the application runs. This normally (when running from the application folder) means that paths starting with `../` and `./` have to be replaced with `./` and `./config/`.\n- Configuration through environment variables should be included via the `NODE_CONFIG` JSON string or as [Custom Environment Variable support](https://github.com/lorenwest/node-config/wiki/Environment-Variables#custom-environment-variables). To use existing environment variables add the following configuration file in `config/custom-environment-variables.json` like this:\n\n```json\n// config/custom-environment-variables.json\n{\n  \"hostname\": \"HOSTNAME\",\n  \"port\": \"PORT\",\n  \"someSetting\": {\n    \"apiKey\": \"MY_CUSTOM_API_KEY\"\n  }\n}\n```\n\n### Debugging\n\nThe `debug` module has been removed as a direct dependency. This reduces the the client bundle size and allows to support other platforms (like Deno). The original `debug` functionality can now be initialized as follows:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport debug from 'debug'\n\nfeathers.setDebug(debug)\n```\n\nIt is also possible to set a custom logger like this:\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\n\nconst customDebug =\n  (name) =>\n  (...args) => {\n    console.log(name, ...args)\n  }\n\nfeathers.setDebug(customDebug)\n```\n\nSetting the debugger will apply to all `@feathersjs` modules.\n\n### Client\n\n- The `request` library has been deprecated and request support has been removed from the REST client.\n- Since all modern browsers now support built-in [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), the Angular and jQuery REST clients have been removed as well.\n- The `@feathersjs/client` package now only comes with a full (`dist/feathers.js`) and core (`dist/core.js`) browser build. Using Feathers [with a module loader](../api/client#module-loaders) is recommended for all other use cases.\n\n### Removed Primus Transport\n\nDue to low usage `@feathersjs/primus` and `@feathers/primus-client` have been removed from Feathers core.\n\n### Changes to WebSockets\n\n#### Legacy Socket Format\n\nThe legacy `servicename::method` socket message format has been deprecated since Feathers 3 and has now been removed. Use a v3 or later [Feathers client](../api/client) or the [current Socket.io direct connection API](../api/client/socketio).\n\n#### Timeouts\n\nThe `timeout` setting for socket services has been removed. It was mainly intended as a fallback for the old message format and interfered with the underlying timeout and retry mechanism provided by the websocket libraries themselves.\n\n### NotFound for `app.service`\n\nBy default, when getting a non existing service via `app.service('something')` on the server, it will now throw a `NotFound` error instead of returning `undefined`. The previous behaviour can be restored by setting [app.defaultService](../api/application#defaultservice):\n\n```js\napp.defaultService = () => {\n  return null // undefined\n}\n```\n\n### Removed `service.mixin()`\n\nServices are no longer Uberproto (an ES5 inheritance utility) objects and instead rely on modern JavaScript classes and extension. This means `app.service(name).mixin(data)` is no longer available which can be replaced with a basic `Object.assign(app.service(name), data)`:\n\n```js\n// Before\napp.mixins.push((service, path) => {\n  service.mixin({\n    create(data, params) {\n      // do something here\n      return this._super(data, params)\n    }\n  })\n})\n\n// Now\napp.mixins.push((service, path) => {\n  const { create } = service\n\n  Object.assign(service, {\n    create(data, params) {\n      // do something here, then invoke the old method\n      // through normal JavaScript functionality\n      return create.call(this, data, params)\n    }\n  })\n})\n```\n\n### `finally` hook\n\nThe undocumented `finally` hook type is no longer available and should be replaced by the new `around` hooks which offer the same functionality using plain JavaScript:\n\n```js\napp.service('myservice').hooks([\n  async (context, next) => {\n    try {\n      await next()\n    } finally {\n      // Do finally hook stuff here\n    }\n  }\n])\n```\n\n### Other internal changes\n\n- The undocumented `service._setup` method introduced in v1 will no longer be called. It was used to circumvent middleware inconsistencies from Express 3 and is no longer necessary.\n- The undocumented `app.providers` has been removed since it provided the same functionality as [`app.mixins`](../api/application#mixins)\n- `app.disable`, `app.disabled`, `app.enable` and `app.enabled` have been removed from basic Feathers applications. It will still be available in an Express-compatible Feathers application. `app.get()` and `app.set()` should be used instead.\n- The `req.authentication` property is no longer set on the express requests, use `req.feathers.authentication` instead.",
    "breadcrumb": "Migrating to v5",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/migrating.md",
    "heading": "Migrating to v5",
    "subHeadings": [
      "Testing the prerelease",
      "New Features",
      "Core SQL and MongoDB",
      "TypeScript",
      "Application and hook context",
      "Service types",
      "Configuration types",
      "Typed params and query",
      "Deprecations and breaking changes",
      "Express middleware order",
      "Core named export",
      "Custom Filters & Operators",
      "Asynchronous setup",
      "Socket.io 4 and Grant 5",
      "Configuration",
      "Debugging",
      "Client",
      "Removed Primus Transport",
      "Changes to WebSockets",
      "NotFound for `app.service`",
      "Removed `service.mixin()`",
      "`finally` hook",
      "Other internal changes"
    ],
    "hasCode": true,
    "codeLanguages": [
      "text",
      "ts",
      "js",
      "json"
    ],
    "tokens": 3290,
    "category": "guides",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "provider",
      "authentication",
      "oauth",
      "schema",
      "resolver",
      "database",
      "adapter",
      "mongodb",
      "knex",
      "websockets",
      "rest",
      "get",
      "create",
      "update",
      "remove",
      "hook context",
      "feathers client",
      "socket.io",
      "middleware",
      "setup",
      "application"
    ]
  },
  {
    "id": "v6-security-0",
    "content": "# Security\nBreadcrumb: Security\nCovers: Reporting security issues | Security considerations | Technologies used | XSS attacks\nTopics: hooks, params, authentication, jwt, database, real-time, channels, rest, find, create, update, application\n\n## Reporting security issues\n\nIn order to give the community time to respond and upgrade, we strongly urge you report all security issues to us. Send us a PM on [Discord](https://discord.gg/qa8kez8QBx) or email us at [hello@feathersjs.com](mailto:hello@feathersjs.com) with details, and we will respond ASAP. Security issues always take precedence over bug fixes and feature work; so, we'll work with you to come up with a resolution and plan and document the issue on Github in the appropriate repo.\n\nIssuing releases is typically very quick. Once an issue is resolved it is usually released immediately with the appropriate semantic version.\n\n## Security considerations\n\nHere are some things that you should be aware of when writing your app to make sure it is secure.\n\n- Make sure to set up proper [event channels](../api/channels) so that only clients that are allowed to see them can see real-time updates\n- Use hooks to check security roles to make sure users can only access data they should be permitted to. You can find useful hook utilities in [feathers-hooks-common](https://hooks-common.feathersjs.com/) and [feathers-authentication-hooks](https://github.com/feathersjs-ecosystem/feathers-authentication-hooks/).\n- Restrict the [allowed database queries](../api/databases/querying) to only the use cases your application requires by sanitizing `params.query` in a hook.\n- When you explicitly allow multiple element changes, make sure queries are secured properly to limit the items that can be changed.\n\n- Escape any HTML and JavaScript to avoid XSS attacks.\n- Escape any SQL (typically done by the SQL library) to avoid SQL injection.\n- JSON Web Tokens (JWT's) are only signed. They are **not** encrypted. Therefore, the payload can be examined on the client. This is by design. **DO NOT** put anything that should be private in the JWT `payload` unless you encrypt it first.\n- Don't use a weak `secret` for your token service. The generator creates a strong one for you automatically. No need to change it.\n\n## Technologies used\n\n- Password storage inside `@feathers/authentication-local` uses [bcrypt](https://github.com/dcodeIO/bcrypt.js). We don't store the salts separately since they are included in the bcrypt hashes.\n- By default, [JWT](https://jwt.io/)'s are stored in Local Storage (instead of cookies) to avoid CSRF attacks. For JWT, we use the `HS256` algorithm by default (HMAC using SHA-256 hash algorithm). If you choose to store JWT's in cookies, your app may have CSRF vulnerabilities.\n\n## XSS attacks\n\nAs with any web application **you** need to guard against XSS attacks. Since Feathers persists the JWT in localstorage in the browser, if your app falls victim to a XSS attack your JWT could be used by an attacker to make malicious requests on your behalf. This is far from ideal. Therefore you need to take extra care in preventing XSS attacks. Our stance on this particular attack vector is that if you are susceptible to XSS attacks, then a compromised JWT is the least of your worries because keystrokes could be logged and attackers can just steal passwords, credit card numbers, or anything else your users type directly.\n\nFor more information see [this issue](https://github.com/feathersjs/authentication/issues/132)",
    "rawContent": "## Reporting security issues\n\nIn order to give the community time to respond and upgrade, we strongly urge you report all security issues to us. Send us a PM on [Discord](https://discord.gg/qa8kez8QBx) or email us at [hello@feathersjs.com](mailto:hello@feathersjs.com) with details, and we will respond ASAP. Security issues always take precedence over bug fixes and feature work; so, we'll work with you to come up with a resolution and plan and document the issue on Github in the appropriate repo.\n\nIssuing releases is typically very quick. Once an issue is resolved it is usually released immediately with the appropriate semantic version.\n\n## Security considerations\n\nHere are some things that you should be aware of when writing your app to make sure it is secure.\n\n- Make sure to set up proper [event channels](../api/channels) so that only clients that are allowed to see them can see real-time updates\n- Use hooks to check security roles to make sure users can only access data they should be permitted to. You can find useful hook utilities in [feathers-hooks-common](https://hooks-common.feathersjs.com/) and [feathers-authentication-hooks](https://github.com/feathersjs-ecosystem/feathers-authentication-hooks/).\n- Restrict the [allowed database queries](../api/databases/querying) to only the use cases your application requires by sanitizing `params.query` in a hook.\n- When you explicitly allow multiple element changes, make sure queries are secured properly to limit the items that can be changed.\n\n- Escape any HTML and JavaScript to avoid XSS attacks.\n- Escape any SQL (typically done by the SQL library) to avoid SQL injection.\n- JSON Web Tokens (JWT's) are only signed. They are **not** encrypted. Therefore, the payload can be examined on the client. This is by design. **DO NOT** put anything that should be private in the JWT `payload` unless you encrypt it first.\n- Don't use a weak `secret` for your token service. The generator creates a strong one for you automatically. No need to change it.\n\n## Technologies used\n\n- Password storage inside `@feathers/authentication-local` uses [bcrypt](https://github.com/dcodeIO/bcrypt.js). We don't store the salts separately since they are included in the bcrypt hashes.\n- By default, [JWT](https://jwt.io/)'s are stored in Local Storage (instead of cookies) to avoid CSRF attacks. For JWT, we use the `HS256` algorithm by default (HMAC using SHA-256 hash algorithm). If you choose to store JWT's in cookies, your app may have CSRF vulnerabilities.\n\n## XSS attacks\n\nAs with any web application **you** need to guard against XSS attacks. Since Feathers persists the JWT in localstorage in the browser, if your app falls victim to a XSS attack your JWT could be used by an attacker to make malicious requests on your behalf. This is far from ideal. Therefore you need to take extra care in preventing XSS attacks. Our stance on this particular attack vector is that if you are susceptible to XSS attacks, then a compromised JWT is the least of your worries because keystrokes could be logged and attackers can just steal passwords, credit card numbers, or anything else your users type directly.\n\nFor more information see [this issue](https://github.com/feathersjs/authentication/issues/132)",
    "breadcrumb": "Security",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/security.md",
    "heading": "Security",
    "subHeadings": [
      "Reporting security issues",
      "Security considerations",
      "Technologies used",
      "XSS attacks"
    ],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 814,
    "category": "guides",
    "tags": [
      "hooks",
      "params",
      "authentication",
      "jwt",
      "database",
      "real-time",
      "channels",
      "rest",
      "find",
      "create",
      "update",
      "application"
    ]
  },
  {
    "id": "v6-whats-new-0",
    "content": "# What's New in v5\nBreadcrumb: What's New in v5\nCovers: New TypeScript Benefits | Complete TypeScript Rewrite | Typed Client | New Documentation | Framework Agnostic API | KoaJS Support | Lightning-Fast Routing | Service De-Registration | Custom Methods | Official Schemas | Schema-Driven Types | Configuration Schemas | Resolvers | Resolver Utility Hooks | Hooks vs Resolvers | More Powerful Hooks | Before, After, & Error Hooks | Around Hooks | Registering Hooks | When to use Around Hooks | Setup and Teardown Hooks | Rebuilt CLI | State of the Art | Fully TypeScript | Shared Types | New App Structure | The Future\nTopics: hooks, services, context, schema, resolver, typebox, validation, database, adapter, mongodb, real-time, events, rest, find, get, create, update, patch, remove, around hooks, error hooks, custom methods, feathers client, middleware, setup, teardown, application\n\n## New TypeScript Benefits\n\nFeathers has been a TypeScript-friendly framework for years, but TypeScript support took a huge leap forward with Feathers Dove.\n\n### Complete TypeScript Rewrite\n\nWe've completely rewritten all of Feathers in TypeScript. And we're not talking about a lightweight TypeScript implementation. It's TypeScript all the way down. Everything from the official database adapters, built-in hooks, and utilities, right down to Feathers core. The newly-rebuilt [v5 CLI and generator](#rebuilt-cli) even produces a TypeScript application, by default.\n\nYou can find the shiny new TypeScript packages on GitHub, [here](https://github.com/feathersjs/feathers/tree/dove/packages).\n\n### Typed Client\n\nFeathers has had an isomorphic API - working equally well in browser and server - since 2016. Now with Dove, our [new CLI](#rebuilt-cli) generates **shared types for the Feathers server and client**. We even integrated the types with our new [schemas feature](#official-schemas), so you define your types once, in a single location, and use them everywhere. Everything still uses Feathers tried and proven [standard HTTP and websocket](../api/client) communication mechanism. There is no custom protocol or the slow parsing of a domain specific language (like GraphQL) necessary and since it is all plain TypeScript with type information removed at compile time, there is also no bundle size overhead.\n\nThanks to FeathersJS's clean, modular, loosely-coupled architecture, it was pleasantly simple to add this feature. This is another one of the benefits we get from building a pattern-driven framework.\n\nYou can learn more about the Feathers Client, [here](../guides/cli/client).\n\n## New Documentation\n\nThe new docs are built on [Vitepress](https://vitepress.vuejs.org/). It had become difficult to maintain all of the examples in two languages: JavaScript and TypeScript. To simplify, we now ONLY write documentation examples in TypeScript. You can still switch languages in the sidebar thanks to our custom highlighter for Vitepress, which transpiles TypeScript examples to JavaScript.\n\nYou can find the `docs` folder, [here](https://github.com/feathersjs/feathers/tree/dove/docs).\n\n## Framework Agnostic API\n\nIn 2016, we realized that we could decouple Feathers from the underlying HTTP transport, resulting in our first framework-agnostic, isomorphic build. As of Feathers v5, we now support three ways of using Feathers:\n\n- The Feathers client, which provides the same API in the browser, React Native and in Node.js.\n- The [KoaJS transport](../api/koa) (new in Feathers Dove)\n- The [ExpressJS transport](../api/express)\n\n### KoaJS Support\n\nThe CLI's official HTTP integration has always been built on the Express adapter. Lately, Express has been \"showing its age\", so we've made some inviting changes.\n\n- We've released the [`@feathersjs/koa`](../api/koa) adapter and utilities. Now Feathers apps can use [KoaJS](https://koajs.com/) as an API base.\n- The Feathers CLI now uses KoaJS as the default transport.\n- The Express adapter will continue to function alongside KoaJS.\n\nFeathersJS has its own, isomorphic middleware layer, based on [hooks](../api/hooks), so you likely won't need to tap into the middleware layer of any framework adapter. But, in those cases that you need framework middleware, it's available to you.\n\nRead about the KoaJS adapter, [here](../api/koa).\n\n### Lightning-Fast Routing\n\nFeathers just got a huge speed upgrade, now including its own [Radix Trie](https://iq.opengenus.org/radix-tree/) router. This means that the algorithm behind Fastify's speed is now built into Feathers, and it works no matter which framework transport you use under the hood.\n\nThe best part about the new router is that there's not another API you have to learn in order to use Feathers. It just works.\n\nFor those who want to build a custom framework transport, there's a single `.lookup` method which routes requests through Feathers.\n\nLearn about the `lookup` method, [here](/api/application#lookup).\n\n### Service De-Registration\n\nNow that Feathers comes with [its own router](#lightning-fast-routing), it's possible to de-register a service to completely remove it from the application. This allows you to build cleaner, dynamically generated applications. This is a coveted feature for those who want to build, for example, a dynamic CRUD admin application that's driven by some sort of schema.\n\nLearn about service de-registration [here](../api/application#unusepath).\n\n## Custom Methods\n\nWhile Feathers [standard service methods](../api/services) cover 90% of the functionality you need to create and modify data, a service might also provide other custom functionality making custom Method creation one of the most-requested features for Feathers. Feathers Dove introduces an elegant solution for custom methods on top of the Feathers service interface.\n\nWhen you define your service class, you can specify additional methods on the class to create an internal-only method. To expose the method to the public API, add the method's name to the `methods` options when registering the service. Custom methods are similar to the `create` method, so you can POST to them when using HTTP-based adapters.\n\nRead more about custom methods, [here](../api/services#custom-methods).\n\n## Official Schemas\n\nFeathers Dove (v5) introduces new, official tools for data validation in the new core package, [@feathersjs/schema](../api/schema/index). This same package includes schema-based resolvers, which you'll learn about in the next section. Schemas are powered by JSON Schema (an IETF standard) which makes them powerful and portable.\n\n### Schema-Driven Types\n\nOne of the problems we wanted to avoid was the need to define schemas and/or types in multiple places. If we had a motto/slogan for types, it would be\n\n**\"Define it once, use it everywhere.\"**\n\nSo in Feathers Dove, when you create a schema, it dynamically generates validation and proper TypeScript types. You can use the powerful and concise [TypeBox schema format](../api/schema/typebox) or [plain JSON schema](../api/schema/schema).\n\n### Configuration Schemas\n\nIf you've ever experienced pains of deploying to production, you'll appreciate this feature. When your app starts in production, all of your configuration and environment variables are checked against the configuration schema. The app won't start if the schema validation fails. This keeps bugs from missing environment variables from showing up in production days to weeks after deployment.\n\nConfiguration schemas also produce TypeScript types, so the [TypeScript improvements](#new-typescript-benefits) in Feathers Dove include typed configuration lookup for `app.get()` and `app.set()`. It's really convenient.\n\nRead more about configuration schemas, [here](/api/configuration#configuration-schema)\n\n## Resolvers\n\nCombined with the new [schemas](#official-schemas), resolvers allow to dynamically populate properties. It's a powerful tool that has many use cases from populating associations, securing queries or protecting secure data to easily setting values like the creation date or associated user. See the [chat guide](../guides/basics/generator) for an example on how to set the user avatar, populate the user associated with a message and let users only modify their own data.\n\n### Resolver Utility Hooks\n\nResolvers are powered by new hook utilities:\n\n- [resolveData](../api/schema/resolvers#data-resolvers) for incoming data.\n- [resolveResult](../api/schema/resolvers#result-resolvers) for results coming from databases or other services\n- [resolveDispatch](../api/schema/resolvers#safe-data-resolvers) for cleanly defining safe data for WebSocket / Real-time events.\n- [resolveQuery](../api/schema/resolvers#query-resolvers) for incoming query parameters\n\nRead about the new hooks using the links, above. These new hook utils allow you to\n\n- More cleanly manage properties on incoming records, query objects, and/or results\n- Perform advanced validation beyond what's possible with JSON Schema.\n- More efficiently write code for populating relational data (often faster than a normal ORM)\n- Save yourself a lot of boilerplate compared to writing the three features, above, manually with hooks.\n\nYou can start using resolvers right away. The new [CLI](../guides/basics/services#generating-a-service) generates them with all new services. Resolvers are one of the new tools provided in the new core package: [@feathersjs/schema](../api/schema/index).\n\nYou can read more about resolvers, [here](../api/schema/resolvers).\n\n### Hooks vs Resolvers\n\nAt first glance, choosing where to put logic might seem complex. Should the feature go into a hook or a resolver? Here are some general guidelines to assist you:\n\n- Data manipulation and **custom** validation probably fit best in a resolver.\n- Adding or pulling in data from other sources will likely fit best in a resolver.\n- Side effects that manipulate external data should go into a hook with few exceptions.\n\n## More Powerful Hooks\n\nIn Feathers Dove there are now two hook formats. One for `before`, `after`, and `error` hooks, and a new one for `around` hooks:\n\n- **Before, after, and error hooks** have been Feathers' most-used API for years.\n  - Are registered as `before`, `after`, or `error` hooks in the hook object.\n  - Continue to work fully in Feathers Dove.\n  - Are less powerful than the new \"around\" hooks, but visually simpler.\n- **Around Hooks** are new in Feathers Dove.\n  - Are registered in the `around` key of a hook object.\n  - Are capable of handling before, after, and error logic, all within a single hook function.\n  - Have a slightly different function definition than before, after, and error hooks\n  - Are more powerful yet also more visually complex (The \"after\" part of each hook runs in reverse-registered order).\n\nLet's compare the signature of the two types of hooks.\n\n### Before, After, & Error Hooks\n\nLet's look at an example of the before/after/error hook format. These hooks receive the `context` as their only argument. They return either the `context` object or `undefined`.\n\n```ts\nimport type { HookContext } from '../../declarations'\n\nexport const myHook = async (context: HookContext) => {\n  return context\n}\n```\n\nYou can learn more about before/after/error hooks, [here](../api/hooks#before-after-and-error)\n\n### Around Hooks\n\nNow let's see an around hook. An around hook receives two arguments: the `context` object and a `next` function.\n\n```ts\nimport type { HookContext, NextFunction } from '../../declarations'\n\nexport const myHook = async (context: HookContext, next: NextFunction) => {\n  await next()\n}\n```\n\nYou can learn more about around hooks, [here](../api/hooks#around)\n\n### Registering Hooks\n\nThe hooks object now has a new `around` property, which is specifically for `around` hooks. Since around hooks have different function signatures, they are not interchangeable with before/after/error hooks.\n\n```ts\nexport const serviceHooks = {\n  // `around` hook are new in Feathers Dove\n  around: {\n    all: [],\n    find: [],\n    get: [],\n    create: [],\n    update: [],\n    patch: [],\n    remove: []\n  },\n  // before/after/error hooks also continue to work\n  before: {},\n  after: {},\n  error: {}\n}\n```\n\nLearn more about registering hooks, [here](../api/hooks#registering-hooks).\n\n### When to use Around Hooks\n\nUsing `around` hooks or `regular` hooks is mostly a matter of preference. There's no imminent need to rewrite all of your regular hooks into around hooks. Both hooks work together, as explained [here](/api/hooks#hook-flow).\n\nStarting with Dove, the CLI templates and new tooling features are written in `around` hooks. The around hooks simplify code in core tools because we can keep the logic for the entire hook flow (before, after, error) all in one file.\n\nHere are a couple of examples of where `around` hooks work really well:\n\n<BlockQuote type=\"note\">\nOne great use case for `around` hooks is data caching. A caching hook typically has the following responsibilities:\n\n- Check the cache for existing results. (before the service method executes)\n- Push new results into the cache, once received. (after the service method executes)\n- Handle and report errors which occur in the hook.\n\nWith regular hooks, a cache hook has to be split into three parts, one for each responsibility. Instead, a single `around` hook can handle everything on its own.\n\nBelow is an example of an overly-simple cache hook using JavaScript's `Map` API. Everything before `await next()` runs before the database call. Everything afterwards runs after the database call. You could also drop in a try/catch to handle possible errors.\n\n```ts\nimport type { HookContext, NextFunction } from '../../declarations'\n\nexport const simpleCache = new Map()\n\nexport const myHook = async (context: HookContext, next: NextFunction) => {\n  // Check the cache for an existing record\n  const existing = simpleCache.get(context.id)\n\n  // If an existing record was found, set it as context.result to skip the database call.\n  if (existing) {\n    context.result = existing\n  }\n\n  await next()\n\n  // Cache the latest record by its id\n  simpleCache.set(context.result.id, context.result)\n}\n```\n</BlockQuote>\n\n### Setup and Teardown Hooks\n\nFeathers v5 Dove adds built-in support for app-level `setup` and `teardown` hooks. They are special hooks that don't run on the service level but instead directly on [app.setup](../api/application#setupserver) or `app.listen` and [app.teardown](../api/application#teardownserver). They allow you to perform some async logic while starting and stopping the Feathers server.\n\n```ts\napp.hooks({\n  setup: [connectMongoDB],\n  teardown: [closeMongoDB]\n})\n```\n\nLearn more about `setup` and `teardown` hooks, [here](../api/hooks#setup-and-teardown)\n\n## Rebuilt CLI\n\nThe new CLI is completely different under the hood, and very familiar on the surface. There are a few differences in file structure compared to apps generated with previous versions of the CLI.\n\n### State of the Art\n\nWhen creating the new generator, we looked at open-source generators already available. We were very impressed with [Hygen](https://hygen.io). It's absolutely impressive work, for sure, so we even wrote a custom generator to try it out. Then [@fratzinger](https://github.com/fratzinger) came up with the idea of a 100% TypeScript generator based on JavaScript template strings. We couldn't find an existing project, so we made one!\n\nThe new Feathers CLI is built on top of [Pinion](https://github.com/feathershq/pinion), our own generator with TypeScript-based templates. Instead of using some custom templating language, like Handlebars or EJS, Pinion uses Typed [Template Literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), providing some wonderful benefits:\n\n- No more mystery context. You always know the exact context of the templates and what helpers are available.\n- It just worksâ„¢ with existing npm packages. There's no need to make an EJS plugin for some custom helper using an obscure API. Just import the module and use it in your template.\n- Integrates with all existing TypeScript tooling. Hover over a variable and inspect the context like you would any TS code.\n\nNow that we have what we consider the best generator on the planet, we have some exciting plans for the Feathers CLI, which we will announce in the future.\n\nYou can read more about Pinion, [here](https://github.com/feathershq/pinion)\n\n### Fully TypeScript\n\nWe have dramatically reduced the surface area for bugs to be introduced into the app. We've committed 100% to TypeScript, while making sure that you can still generate a JavaScript app.\n\nWhen you select `JavaScript` to generate an app, the CLI works some magic under the hood by\n\n- Compiling the `.ts` templates to JavaScript, in memory\n- Formatting the JavaScript code with Prettier\n- Writing clean `.js` to the file system.\n\nFor Feathers Maintainers, committing to TypeScript means we only contribute to a single set of templates. And they get magically compiled - on the fly - to plain JavaScript when you want it.\n\n### Shared Types\n\nWe covered this [in more detail, earlier](#typed-client), but it's worth briefly mentioning again. The new generator powers Shared Types for both the Feathers server and client. You can make your public-facing API easier to use and give developers a typed client SDK.\n\nRead more about shared types, [here](#typed-client).\n\n### New App Structure\n\nThe file and folder structure of generated apps has changed a little bit. Here's an overview of the changes:\n\n- Each service has its own schema and resolver file\n- The service hooks are now found together with the service registration.\n- The `src/models` folder no longer gets created, since [Feathers schemas](#official-schemas) replace models.\n- Each service has its own folder inside the `tests` folder.\n\nYou can learn more about the generated files in the [CLI guide](./cli/index).\n\n## The Future\n\nWe are self-funded and community powered. In every way, Feathers has a solid foundation for a steady, stable future. How did we ever manage to build such a great framework without millions of dollars? Really, we have a wonderful, active community of contributors who share values of good API design, boilerplate elimination, and making development fun. This is rewarding for us!\n\nWe started in 2013 from a core architecture that's unique among frameworks - in **any** language. We offer the same API across multiple transports, which allows us all to build real-time, restful applications. The result is a robust, flexible framework that continues to be unique while showing its maturity. Feathers has made its way into enterprises that serve a large portion of the connected planet. With all of the new features in Feathers v5 (Dove), we're excited to build! And we're even more excited to see what you build!\n\nWe have a few more things to show off in the coming months. Stay tuned!\n\nEnjoy the release! And come chat with us on [Discord](https://discord.gg/qa8kez8QBx) when you feel like it.",
    "rawContent": "## New TypeScript Benefits\n\nFeathers has been a TypeScript-friendly framework for years, but TypeScript support took a huge leap forward with Feathers Dove.\n\n### Complete TypeScript Rewrite\n\nWe've completely rewritten all of Feathers in TypeScript. And we're not talking about a lightweight TypeScript implementation. It's TypeScript all the way down. Everything from the official database adapters, built-in hooks, and utilities, right down to Feathers core. The newly-rebuilt [v5 CLI and generator](#rebuilt-cli) even produces a TypeScript application, by default.\n\nYou can find the shiny new TypeScript packages on GitHub, [here](https://github.com/feathersjs/feathers/tree/dove/packages).\n\n### Typed Client\n\nFeathers has had an isomorphic API - working equally well in browser and server - since 2016. Now with Dove, our [new CLI](#rebuilt-cli) generates **shared types for the Feathers server and client**. We even integrated the types with our new [schemas feature](#official-schemas), so you define your types once, in a single location, and use them everywhere. Everything still uses Feathers tried and proven [standard HTTP and websocket](../api/client) communication mechanism. There is no custom protocol or the slow parsing of a domain specific language (like GraphQL) necessary and since it is all plain TypeScript with type information removed at compile time, there is also no bundle size overhead.\n\nThanks to FeathersJS's clean, modular, loosely-coupled architecture, it was pleasantly simple to add this feature. This is another one of the benefits we get from building a pattern-driven framework.\n\nYou can learn more about the Feathers Client, [here](../guides/cli/client).\n\n## New Documentation\n\nThe new docs are built on [Vitepress](https://vitepress.vuejs.org/). It had become difficult to maintain all of the examples in two languages: JavaScript and TypeScript. To simplify, we now ONLY write documentation examples in TypeScript. You can still switch languages in the sidebar thanks to our custom highlighter for Vitepress, which transpiles TypeScript examples to JavaScript.\n\nYou can find the `docs` folder, [here](https://github.com/feathersjs/feathers/tree/dove/docs).\n\n## Framework Agnostic API\n\nIn 2016, we realized that we could decouple Feathers from the underlying HTTP transport, resulting in our first framework-agnostic, isomorphic build. As of Feathers v5, we now support three ways of using Feathers:\n\n- The Feathers client, which provides the same API in the browser, React Native and in Node.js.\n- The [KoaJS transport](../api/koa) (new in Feathers Dove)\n- The [ExpressJS transport](../api/express)\n\n### KoaJS Support\n\nThe CLI's official HTTP integration has always been built on the Express adapter. Lately, Express has been \"showing its age\", so we've made some inviting changes.\n\n- We've released the [`@feathersjs/koa`](../api/koa) adapter and utilities. Now Feathers apps can use [KoaJS](https://koajs.com/) as an API base.\n- The Feathers CLI now uses KoaJS as the default transport.\n- The Express adapter will continue to function alongside KoaJS.\n\nFeathersJS has its own, isomorphic middleware layer, based on [hooks](../api/hooks), so you likely won't need to tap into the middleware layer of any framework adapter. But, in those cases that you need framework middleware, it's available to you.\n\nRead about the KoaJS adapter, [here](../api/koa).\n\n### Lightning-Fast Routing\n\nFeathers just got a huge speed upgrade, now including its own [Radix Trie](https://iq.opengenus.org/radix-tree/) router. This means that the algorithm behind Fastify's speed is now built into Feathers, and it works no matter which framework transport you use under the hood.\n\nThe best part about the new router is that there's not another API you have to learn in order to use Feathers. It just works.\n\nFor those who want to build a custom framework transport, there's a single `.lookup` method which routes requests through Feathers.\n\nLearn about the `lookup` method, [here](/api/application#lookup).\n\n### Service De-Registration\n\nNow that Feathers comes with [its own router](#lightning-fast-routing), it's possible to de-register a service to completely remove it from the application. This allows you to build cleaner, dynamically generated applications. This is a coveted feature for those who want to build, for example, a dynamic CRUD admin application that's driven by some sort of schema.\n\nLearn about service de-registration [here](../api/application#unusepath).\n\n## Custom Methods\n\nWhile Feathers [standard service methods](../api/services) cover 90% of the functionality you need to create and modify data, a service might also provide other custom functionality making custom Method creation one of the most-requested features for Feathers. Feathers Dove introduces an elegant solution for custom methods on top of the Feathers service interface.\n\nWhen you define your service class, you can specify additional methods on the class to create an internal-only method. To expose the method to the public API, add the method's name to the `methods` options when registering the service. Custom methods are similar to the `create` method, so you can POST to them when using HTTP-based adapters.\n\nRead more about custom methods, [here](../api/services#custom-methods).\n\n## Official Schemas\n\nFeathers Dove (v5) introduces new, official tools for data validation in the new core package, [@feathersjs/schema](../api/schema/index). This same package includes schema-based resolvers, which you'll learn about in the next section. Schemas are powered by JSON Schema (an IETF standard) which makes them powerful and portable.\n\n### Schema-Driven Types\n\nOne of the problems we wanted to avoid was the need to define schemas and/or types in multiple places. If we had a motto/slogan for types, it would be\n\n**\"Define it once, use it everywhere.\"**\n\nSo in Feathers Dove, when you create a schema, it dynamically generates validation and proper TypeScript types. You can use the powerful and concise [TypeBox schema format](../api/schema/typebox) or [plain JSON schema](../api/schema/schema).\n\n### Configuration Schemas\n\nIf you've ever experienced pains of deploying to production, you'll appreciate this feature. When your app starts in production, all of your configuration and environment variables are checked against the configuration schema. The app won't start if the schema validation fails. This keeps bugs from missing environment variables from showing up in production days to weeks after deployment.\n\nConfiguration schemas also produce TypeScript types, so the [TypeScript improvements](#new-typescript-benefits) in Feathers Dove include typed configuration lookup for `app.get()` and `app.set()`. It's really convenient.\n\nRead more about configuration schemas, [here](/api/configuration#configuration-schema)\n\n## Resolvers\n\nCombined with the new [schemas](#official-schemas), resolvers allow to dynamically populate properties. It's a powerful tool that has many use cases from populating associations, securing queries or protecting secure data to easily setting values like the creation date or associated user. See the [chat guide](../guides/basics/generator) for an example on how to set the user avatar, populate the user associated with a message and let users only modify their own data.\n\n### Resolver Utility Hooks\n\nResolvers are powered by new hook utilities:\n\n- [resolveData](../api/schema/resolvers#data-resolvers) for incoming data.\n- [resolveResult](../api/schema/resolvers#result-resolvers) for results coming from databases or other services\n- [resolveDispatch](../api/schema/resolvers#safe-data-resolvers) for cleanly defining safe data for WebSocket / Real-time events.\n- [resolveQuery](../api/schema/resolvers#query-resolvers) for incoming query parameters\n\nRead about the new hooks using the links, above. These new hook utils allow you to\n\n- More cleanly manage properties on incoming records, query objects, and/or results\n- Perform advanced validation beyond what's possible with JSON Schema.\n- More efficiently write code for populating relational data (often faster than a normal ORM)\n- Save yourself a lot of boilerplate compared to writing the three features, above, manually with hooks.\n\nYou can start using resolvers right away. The new [CLI](../guides/basics/services#generating-a-service) generates them with all new services. Resolvers are one of the new tools provided in the new core package: [@feathersjs/schema](../api/schema/index).\n\nYou can read more about resolvers, [here](../api/schema/resolvers).\n\n### Hooks vs Resolvers\n\nAt first glance, choosing where to put logic might seem complex. Should the feature go into a hook or a resolver? Here are some general guidelines to assist you:\n\n- Data manipulation and **custom** validation probably fit best in a resolver.\n- Adding or pulling in data from other sources will likely fit best in a resolver.\n- Side effects that manipulate external data should go into a hook with few exceptions.\n\n## More Powerful Hooks\n\nIn Feathers Dove there are now two hook formats. One for `before`, `after`, and `error` hooks, and a new one for `around` hooks:\n\n- **Before, after, and error hooks** have been Feathers' most-used API for years.\n  - Are registered as `before`, `after`, or `error` hooks in the hook object.\n  - Continue to work fully in Feathers Dove.\n  - Are less powerful than the new \"around\" hooks, but visually simpler.\n- **Around Hooks** are new in Feathers Dove.\n  - Are registered in the `around` key of a hook object.\n  - Are capable of handling before, after, and error logic, all within a single hook function.\n  - Have a slightly different function definition than before, after, and error hooks\n  - Are more powerful yet also more visually complex (The \"after\" part of each hook runs in reverse-registered order).\n\nLet's compare the signature of the two types of hooks.\n\n### Before, After, & Error Hooks\n\nLet's look at an example of the before/after/error hook format. These hooks receive the `context` as their only argument. They return either the `context` object or `undefined`.\n\n```ts\nimport type { HookContext } from '../../declarations'\n\nexport const myHook = async (context: HookContext) => {\n  return context\n}\n```\n\nYou can learn more about before/after/error hooks, [here](../api/hooks#before-after-and-error)\n\n### Around Hooks\n\nNow let's see an around hook. An around hook receives two arguments: the `context` object and a `next` function.\n\n```ts\nimport type { HookContext, NextFunction } from '../../declarations'\n\nexport const myHook = async (context: HookContext, next: NextFunction) => {\n  await next()\n}\n```\n\nYou can learn more about around hooks, [here](../api/hooks#around)\n\n### Registering Hooks\n\nThe hooks object now has a new `around` property, which is specifically for `around` hooks. Since around hooks have different function signatures, they are not interchangeable with before/after/error hooks.\n\n```ts\nexport const serviceHooks = {\n  // `around` hook are new in Feathers Dove\n  around: {\n    all: [],\n    find: [],\n    get: [],\n    create: [],\n    update: [],\n    patch: [],\n    remove: []\n  },\n  // before/after/error hooks also continue to work\n  before: {},\n  after: {},\n  error: {}\n}\n```\n\nLearn more about registering hooks, [here](../api/hooks#registering-hooks).\n\n### When to use Around Hooks\n\nUsing `around` hooks or `regular` hooks is mostly a matter of preference. There's no imminent need to rewrite all of your regular hooks into around hooks. Both hooks work together, as explained [here](/api/hooks#hook-flow).\n\nStarting with Dove, the CLI templates and new tooling features are written in `around` hooks. The around hooks simplify code in core tools because we can keep the logic for the entire hook flow (before, after, error) all in one file.\n\nHere are a couple of examples of where `around` hooks work really well:\n\n<BlockQuote type=\"note\">\nOne great use case for `around` hooks is data caching. A caching hook typically has the following responsibilities:\n\n- Check the cache for existing results. (before the service method executes)\n- Push new results into the cache, once received. (after the service method executes)\n- Handle and report errors which occur in the hook.\n\nWith regular hooks, a cache hook has to be split into three parts, one for each responsibility. Instead, a single `around` hook can handle everything on its own.\n\nBelow is an example of an overly-simple cache hook using JavaScript's `Map` API. Everything before `await next()` runs before the database call. Everything afterwards runs after the database call. You could also drop in a try/catch to handle possible errors.\n\n```ts\nimport type { HookContext, NextFunction } from '../../declarations'\n\nexport const simpleCache = new Map()\n\nexport const myHook = async (context: HookContext, next: NextFunction) => {\n  // Check the cache for an existing record\n  const existing = simpleCache.get(context.id)\n\n  // If an existing record was found, set it as context.result to skip the database call.\n  if (existing) {\n    context.result = existing\n  }\n\n  await next()\n\n  // Cache the latest record by its id\n  simpleCache.set(context.result.id, context.result)\n}\n```\n</BlockQuote>\n\n### Setup and Teardown Hooks\n\nFeathers v5 Dove adds built-in support for app-level `setup` and `teardown` hooks. They are special hooks that don't run on the service level but instead directly on [app.setup](../api/application#setupserver) or `app.listen` and [app.teardown](../api/application#teardownserver). They allow you to perform some async logic while starting and stopping the Feathers server.\n\n```ts\napp.hooks({\n  setup: [connectMongoDB],\n  teardown: [closeMongoDB]\n})\n```\n\nLearn more about `setup` and `teardown` hooks, [here](../api/hooks#setup-and-teardown)\n\n## Rebuilt CLI\n\nThe new CLI is completely different under the hood, and very familiar on the surface. There are a few differences in file structure compared to apps generated with previous versions of the CLI.\n\n### State of the Art\n\nWhen creating the new generator, we looked at open-source generators already available. We were very impressed with [Hygen](https://hygen.io). It's absolutely impressive work, for sure, so we even wrote a custom generator to try it out. Then [@fratzinger](https://github.com/fratzinger) came up with the idea of a 100% TypeScript generator based on JavaScript template strings. We couldn't find an existing project, so we made one!\n\nThe new Feathers CLI is built on top of [Pinion](https://github.com/feathershq/pinion), our own generator with TypeScript-based templates. Instead of using some custom templating language, like Handlebars or EJS, Pinion uses Typed [Template Literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), providing some wonderful benefits:\n\n- No more mystery context. You always know the exact context of the templates and what helpers are available.\n- It just worksâ„¢ with existing npm packages. There's no need to make an EJS plugin for some custom helper using an obscure API. Just import the module and use it in your template.\n- Integrates with all existing TypeScript tooling. Hover over a variable and inspect the context like you would any TS code.\n\nNow that we have what we consider the best generator on the planet, we have some exciting plans for the Feathers CLI, which we will announce in the future.\n\nYou can read more about Pinion, [here](https://github.com/feathershq/pinion)\n\n### Fully TypeScript\n\nWe have dramatically reduced the surface area for bugs to be introduced into the app. We've committed 100% to TypeScript, while making sure that you can still generate a JavaScript app.\n\nWhen you select `JavaScript` to generate an app, the CLI works some magic under the hood by\n\n- Compiling the `.ts` templates to JavaScript, in memory\n- Formatting the JavaScript code with Prettier\n- Writing clean `.js` to the file system.\n\nFor Feathers Maintainers, committing to TypeScript means we only contribute to a single set of templates. And they get magically compiled - on the fly - to plain JavaScript when you want it.\n\n### Shared Types\n\nWe covered this [in more detail, earlier](#typed-client), but it's worth briefly mentioning again. The new generator powers Shared Types for both the Feathers server and client. You can make your public-facing API easier to use and give developers a typed client SDK.\n\nRead more about shared types, [here](#typed-client).\n\n### New App Structure\n\nThe file and folder structure of generated apps has changed a little bit. Here's an overview of the changes:\n\n- Each service has its own schema and resolver file\n- The service hooks are now found together with the service registration.\n- The `src/models` folder no longer gets created, since [Feathers schemas](#official-schemas) replace models.\n- Each service has its own folder inside the `tests` folder.\n\nYou can learn more about the generated files in the [CLI guide](./cli/index).\n\n## The Future\n\nWe are self-funded and community powered. In every way, Feathers has a solid foundation for a steady, stable future. How did we ever manage to build such a great framework without millions of dollars? Really, we have a wonderful, active community of contributors who share values of good API design, boilerplate elimination, and making development fun. This is rewarding for us!\n\nWe started in 2013 from a core architecture that's unique among frameworks - in **any** language. We offer the same API across multiple transports, which allows us all to build real-time, restful applications. The result is a robust, flexible framework that continues to be unique while showing its maturity. Feathers has made its way into enterprises that serve a large portion of the connected planet. With all of the new features in Feathers v5 (Dove), we're excited to build! And we're even more excited to see what you build!\n\nWe have a few more things to show off in the coming months. Stay tuned!\n\nEnjoy the release! And come chat with us on [Discord](https://discord.gg/qa8kez8QBx) when you feel like it.",
    "breadcrumb": "What's New in v5",
    "version": "v6",
    "sourceFile": "docs/v6_docs/guides/whats-new.md",
    "heading": "What's New in v5",
    "subHeadings": [
      "New TypeScript Benefits",
      "Complete TypeScript Rewrite",
      "Typed Client",
      "New Documentation",
      "Framework Agnostic API",
      "KoaJS Support",
      "Lightning-Fast Routing",
      "Service De-Registration",
      "Custom Methods",
      "Official Schemas",
      "Schema-Driven Types",
      "Configuration Schemas",
      "Resolvers",
      "Resolver Utility Hooks",
      "Hooks vs Resolvers",
      "More Powerful Hooks",
      "Before, After, & Error Hooks",
      "Around Hooks",
      "Registering Hooks",
      "When to use Around Hooks",
      "Setup and Teardown Hooks",
      "Rebuilt CLI",
      "State of the Art",
      "Fully TypeScript",
      "Shared Types",
      "New App Structure",
      "The Future"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text"
    ],
    "tokens": 4522,
    "category": "guides",
    "tags": [
      "hooks",
      "services",
      "context",
      "schema",
      "resolver",
      "typebox",
      "validation",
      "database",
      "adapter",
      "mongodb",
      "real-time",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "around hooks",
      "error hooks",
      "custom methods",
      "feathers client",
      "middleware",
      "setup",
      "teardown",
      "application"
    ]
  },
  {
    "id": "v6-faq-0",
    "content": "# FAQ\nBreadcrumb: FAQ\nCovers: Why should I use Feathers? | Is Feathers production ready? | What Node versions does Feathers support | How do I create custom methods? | How do I do nested or custom routes? | Why are you using JWT for sessions | Can you support another database? | How do I watch for database changes? | How do I do search? | Why am I not getting JSON errors? | Why am I not getting the correct HTTP error code | How can I do custom methods like `findOrCreate`? | How do I create channels or rooms | How do I do validation? | How do I do associations? | How do I access the request object in hooks or services? | How do I mount sub apps? | How do I do some processing after sending the response to the user? | How do I debug my app | Why can't I pass `params` from the client? | My queries with null values aren't working | Why are queries with arrays failing? | I always get a 404 for my custom middleware | My configuration isn't loaded | How do I set up HTTPS?\nTopics: hooks, services, context, params, authentication, jwt, schema, resolver, validation, database, adapter, mongodb, real-time, websockets, channels, events, rest, find, get, create, update, patch, custom methods, middleware, application\n\n## Why should I use Feathers?\n\nThere are many other Frameworks that let you build web applications so this is definitely a justified question. The key part for Feathers is that it takes a different approach to both, traditional MVC frameworks like Rails, Sails or NestJS and low level HTTP frameworks like Sinatra, Express or Fastify. Instead of creating routes, controllers and HTTP request and response handlers, Feathers uses services and workflows (hooks) that let you focus on your application logic independently from how it is being accessed.\n\nThis makes applications easier to understand and test and it allows Feathers to automatically provide REST APIs, websocket real-time APIs (which can often be quite a bit faster) and universal usage on the client and the server. It also makes it possible to add new communication protocols (like HTTP2 or GraphQL) without having to change anything in your application code. Feathers does all that while staying lightweight with a small API surface and codebase and flexible by letting you use it with the backend and frontend technology that best suits your needs.\n\nFor more information\n\n- [Read about the philosophy behind Feathers and where it came from](https://blog.feathersjs.com/why-we-built-the-best-web-framework-you-ve-probably-never-heard-of-until-now-176afc5c6aac)\n- [Learn about the high level design patterns behind Feathers](https://blog.feathersjs.com/design-patterns-for-modern-web-apis-1f046635215)\n\n## Is Feathers production ready?\n\nYes! Feathers had its first stable release in 2014 and is being used in production by a bunch of companies from startups to fortune 500s. For some more details see [this answer on Quora](https://www.quora.com/Is-FeathersJS-production-ready).\n\n## What Node versions does Feathers support\n\nFeathers supports all NodeJS versions from the current Active LTS upwards. See [the Node.JS working group release schedule](https://github.com/nodejs/Release#release-schedule) for more information.\n\n## How do I create custom methods?\n\nFeathers is built around the [REST architectural constraints](https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints) reflected by its standard service methods. There are many benefits using those methods like security, predictability and sending pre-defined real-time events so you should try to structure your application with the [standard service methods](../api/services#service-methods). For example:\n\n> Send email action that does not store mail message in database.\n\nResources (services) don't have to be database records. It can be any kind of resource (like the current weather for a city or creating an email which will send it). Sending emails is usually done with either a separate email [service](../api/services):\n\n```ts\nclass EmailService {\n  async create(data: EmailData) {\n    return sendEmail(data)\n  }\n}\n\napp.use('/email', new EmailService())\n```\n\n> Place an order in e-commerce web site. Behind the scenes, there are many records will be inserted in one transaction: order_item, order_header, voucher_tracking etc.\n\nThis is what [Feathers hooks](../api/hooks) are used for. When creating a new order you also have a well defined hook chain:\n\n```ts\napp.service('orders').hooks({\n  before: {\n    create: [validateData(), checkStock(), checkVoucher()]\n  },\n  after: {\n    create: [\n      chargePayment(), // hook that calls `app.service('payment').create()`\n      sendEmail(), // hook that calls `app.service('email').create()`\n      updateStock() // Update product stock here\n    ]\n  }\n})\n```\n\nHowever, there are some use cases where you might still want to allow additional methods for a client to call (like re-sending a verification email or resetting a password on the user service) and this is what [custom service method](../api/services#custom-methods) can be used for.\n\n## How do I do nested or custom routes?\n\nNormally we find that they actually aren't needed and that it is much better to keep your routes as flat as possible. For example something like `users/:userId/posts` is - although nice to read for humans - actually not as easy to parse and process as the equivalent `/posts?userId=<userid>` that is already [supported by Feathers database adapters](../api/databases/querying). Additionally, this will also work much better when using Feathers through websocket connections which do not have a concept of routes at all.\n\nHowever, nested routes for services can still be created by registering an existing service on the nested route and mapping the route parameter to a query parameter like this:\n\n```ts\napp.use('/posts', postService)\napp.use('/users', userService)\n\n// re-export the posts service on the /users/:userId/posts route\napp.use('/users/:userId/posts', app.service('posts'))\n\n// A hook that updates `data` with the route parameter\nasync function mapUserIdToData(context: HookContext) {\n  if (context.data && context.params.route.userId) {\n    context.data.userId = context.params.route.userId\n  }\n}\n\n// For the new route, map the `:userId` route parameter to the query in a hook\napp.service('users/:userId/posts').hooks({\n  before: {\n    find: [\n      async (context: HookContext) => {\n        // Map the `userId` route parameter to the query\n        context.params.query = {\n          ...context.params.query,\n          userId: context.params.route.userId\n        }\n      }\n    ],\n    create: mapUserIdToData,\n    update: mapUserIdToData,\n    patch: mapUserIdToData\n  }\n})\n```\n\nNow going to `/users/123/posts` will call `postService.find({ query: { userId: 123 } })` and return all posts for that user.\n\nFor more information about URL routing and parameters, refer to [the Express chapter](../api/express).\n\n<BlockQuote type=\"warning\">\nURLs should never contain actions that change data (like `post/publish` or `post/delete`). This has always been an important part of the HTTP protocol and Feathers enforces this more strictly than most other frameworks. For example to publish a post you would call `.patch(id, { published: true })`.\n</BlockQuote>\n\n## Why are you using JWT for sessions\n\nFeathers is using [JSON web tokens (JWT)](https://jwt.io/) for its standard authentication mechanism. Some articles like [Stop using JWT for sessions](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) promotes using standard cookies and HTTP sessions. While it brings up some valid points, not all of them apply to Feathers and there are other good reasons why Feathers relies on JWT:\n\n- Feathers is designed to support many different transport mechanisms, most of which do not rely on HTTP but do work well with JWT as the authentication mechanism. This is even already the case for websockets where an established connection normally is not secured by a traditional HTTP session.\n- By default the only thing that Feathers stored in the JWT payload is the user id. It is a stateful token. You can change this and make the token stateless by putting more data into the JWT payload but this is at your discretion. Currently the user is looked up on every request after the JWT is verified to not be expired or tampered with.\n- You need to make sure that you revoke JWT tokens or set a low expiration date or add custom logic to verify that a userâ€™s account is still valid/active. Currently the default expiration is 1 day. We chose a reasonable default for most apps but depending on your application this might be too long or too short.\n\nAdditionally, it is still possible to use Feathers with existing _traditional_ Express session mechanism by using [custom Express middleware](../api/express). For example, `params.user` for all service calls from a traditional Express session can be passed like this:\n\n```ts\napp.use(function (req, res, next) {\n  // Set service call `param.user` from `session.user`\n  req.feathers.user = req.session.user\n})\n```\n\n## Can you support another database?\n\nFeathers [database adapters](../api/databases/adapters) implement 90% of the functionality you may need to use Feathers with certain databases. You can also find a wide variety of community maintained database adapters [in the ecosystem](/ecosystem/?cat=Database&sort=lastPublish). However, even if your favourite database or ORM is not on the list or the adapter does not support specific functionality you are looking for, Feathers can still accommodate all your needs by [writing your own services](../api/services).\n\n<BlockQuote type=\"warning\">\nTo use Feathers properly it is very important to understand how services work and that all existing database adapters are just services that talk to the database themselves.\n</BlockQuote>\n\nThe why and how to write your own services is covered [in the Feathers guide](../guides/). A custom service can be generated by running `npx feathers generate service`, choosing \"A custom service\" and then editing the `<servicename>/<servicename>.class.js` file to make the database calls.\n\nIf you would like to publish your own database adapter, first make sure there isn't already a [community maintained adapter](/ecosystem/?cat=Database&sort=lastPublish) for that database. If one exists, many maintainers are happy to get some help. If not, you can find a database adapter reference implementation in the [@feathersjs/memory module](https://github.com/feathersjs/feathers/tree/dove/packages/memory). It is always possible for community maintained adapters to graduate into an _official_ Feathers adapter, at the moment there are however no plans to add support for any new databases from the Feathers team directly.\n\n## How do I watch for database changes?\n\nIn order to get real-time updates for a change, all requests have to go through your Feathers application or API server. Feathers **does not** watch the database for changes so if changes in the database are made outside of the Feathers application and clients should be notified, the notification needs to be sent manually.\n\n## How do I do search?\n\nThis depends on the database adapter you are using. See [the search querying chapter](../api/databases/querying#search) for more information.\n\n## Why am I not getting JSON errors?\n\nIf you get a plain text error and a 500 status code for errors that should return different status codes, make sure you have the `express.errorHandler()` from the `@feathersjs/express` module configured as described in the [Express errors](../api/express#expresserrorhandler) chapter.\n\n## Why am I not getting the correct HTTP error code\n\nSee the above answer.\n\n## How can I do custom methods like `findOrCreate`?\n\nCustom functionality can almost always be mapped to an existing service method using hooks. For example, `findOrCreate` can be implemented as a before-hook on the service's `get` method. [See this gist](https://gist.github.com/marshallswain/9fa3b1e855633af00998) for an example of how to implement this in a before-hook. It is also possible to implement [custom methods](../api/services#custom-methods) on the service for functionality that can't be implemented in a hook.\n\n## How do I create channels or rooms\n\nIn Feathers [channels](../api/channels) are the way to send [real-time events](../api/events) to only certain clients.\n\n## How do I do validation?\n\n[Schemas](../api/schema/index) and [validator](../api/schema/validators) are the recommended way to implement basic validations based on JSON schema. [Resolvers](../api/schema/resolvers) can be used for advanced validation like dynamic password policies.\n\nSchemas and resolvers are then used as [validation hooks](../api/schema/validators#hooks) and [resolver hooks](../api/schema/resolvers#hooks). Hooks are also the place to perform validation without schemas and resolvers.\n\n## How do I do associations?\n\nThe preferred way for associations are [resolvers](../api/schema/resolvers). See [the guide](../guides/basics/schemas) for an example on how to do associations.\n\n## How do I access the request object in hooks or services?\n\nIn short, you shouldn't need to. If you look at the [hooks chapter](../api/hooks) you'll see all the params that are available on a hook.\n\nIf you still need something from the request object (for example, the requesting IP address) you can tack it on to the `req.feathers` object as described [here for Express](../api/express#params), here [for Koa](../api/koa#params) or `socket.feathers` when using web sockets as [described here](../api/socketio#appconfiguresocketiocallback).\n\n## How do I mount sub apps?\n\nIt's pretty much exactly the same as Express. More information can be found [here](../api/express#sub-apps).\n\n## How do I do some processing after sending the response to the user?\n\nThe hooks workflow allows you to handle these situations quite gracefully. It depends if you `await` or not in your hook. Here's an example of a hook that sends an email, but doesn't wait for a success message.\n\n```ts\n;async (context: HookContext) => {\n  // Send an email by calling to the email service.\n  context.app.service('emails').create({\n    to: 'user@email.com',\n    body: 'You are so great!'\n  })\n\n  // Send a message to some logging service.\n  context.app.service('logging').create(context.data)\n\n  return context\n}\n```\n\n## How do I debug my app\n\nIt's really no different than debugging any other NodeJS app but you can refer to [this blog post](https://blog.feathersjs.com/debugging-feathers-with-visual-studio-code-406e6adf2882) for more Feathers specific tips and tricks.\n\n## Why can't I pass `params` from the client?\n\nWhen you make a call like:\n\n```ts\nconst params = { foo: 'bar' }\n\nconst user = await client.service('users').patch(1, { admin: true }, params)\n```\n\non the client the `context.params` object will only be available in your client side hooks. It will not be provided to the server. The reason for this is because `context.params` on the server usually contains information that should be server-side only. This can be database options, whether a request is authenticated, etc. If we passed those directly from the client to the server this would be a big security risk. **Only the client side** `context.params.query` and `context.params.headers` objects are provided to the server.\n\nIf you need to pass info from the client to the server that is not part of the query you need to add it to `context.params.query` on the client side and explicitly pull it out of `context.params.query` on the server side. This can be achieved like so:\n\n```ts\n// client side\nclient.hooks({\n  before: {\n    all: [\n      async (context: HookContext) => {\n        context.params.query = {\n          ...context.params.query,\n          $client: {\n            platform: 'ios',\n            version: '1.0'\n          }\n        }\n      }\n    ]\n  }\n})\n```\n\nOn the server in `src/app`:\n\n```ts\napp.hooks({\n  before: {\n    all: [\n      async (context: HookContext) => {\n        // Pull out `$client` parameter and create a new `query` object\n        const {\n          $client: { platform, version },\n          ...query\n        } = params.query\n\n        // Update context.params with the new information\n        context.params = {\n          ...context.params,\n          platform,\n          version,\n          query\n        }\n      }\n    ]\n  }\n})\n```\n\n<BlockQuote type=\"danger\">\nMake sure to validate and sanitize any client side values to prevent security issues.\n</BlockQuote>\n\n## My queries with null values aren't working\n\n<BlockQuote type=\"tip\">\nQuery values will be converted to the correct type automatically when using a [query schema](../api/schema/index). This issue also does not happen when using websockets since it retains all type information.\n</BlockQuote>\n\nWhen making a request using REST (HTTP) query _string_ values don't have any type information and will always be strings. Some database adapters that have a schema (like `feathers-mongoose` or `feathers-sequelize`) will try to convert values to the correct type but others (like `feathers-mongodb`) can't. Additionally, `null` will always be a string and always has to be converted if you want to query for `null`. This can be done in a `before` [hook](../api/hooks):\n\n```ts\napp.service('myservice').hooks({\n  before: {\n    find: [\n      async (context: HookContext) => {\n        const {\n          params: { query = {} }\n        } = context\n\n        if (query.phone === 'null') {\n          query.phone = null\n        }\n\n        context.params.query = query\n\n        return context\n      }\n    ]\n  }\n})\n```\n\nAlso see [this issue](https://github.com/feathersjs/feathers/issues/894).\n\n## Why are queries with arrays failing?\n\nIf you are using REST and queries with larger arrays (more than 21 items to be exact) are failing, you are probably running into an issue with the [querystring](https://github.com/ljharb/qs) module which [limits the size of arrays to 21 items](https://github.com/ljharb/qs#parsing-arrays) by default. The recommended solution is to implement a custom query string parser function via `app.set('query parser', parserFunction)` with the `arrayLimit` option set to a higher value:\n\n```js\nvar qs = require('qs')\n\napp.set('query parser', function (str) {\n  return qs.parse(str, {\n    arrayLimit: 100\n  })\n})\n```\n\nFor more information see the [Express application settings](http://expressjs.com/en/4x/api.html#app.set) [@feathersjs/rest#88](https://github.com/feathersjs/feathers-rest/issues/88) and [feathers-mongoose#205](https://github.com/feathersjs-ecosystem/feathers-mongoose/issues/205).\n\n## I always get a 404 for my custom middleware\n\nJust like in Express itself, the order of middleware matters. If you registered a custom middleware outside of the generator, you have to make sure that it runs before the `notFound()` error midlleware.\n\n## My configuration isn't loaded\n\nIf you are running or requiring the Feathers app from a different folder [Feathers configuration](../api/configuration) needs to be instructed where the configuration files for the app are located. Since it uses [node-config](https://github.com/lorenwest/node-config) this can be done by setting the [NODE_CONFIG_DIR envorinment variable](https://github.com/lorenwest/node-config/wiki/Environment-Variables#node_config_dir).\n\n## How do I set up HTTPS?\n\nIn most production environments your Feathers application should be behind an NginX proxy that handles HTTPS. It is also possible to add SSL directly to your Feathers application which is described in the [Express HTTPS docs](../api/express#https).",
    "rawContent": "## Why should I use Feathers?\n\nThere are many other Frameworks that let you build web applications so this is definitely a justified question. The key part for Feathers is that it takes a different approach to both, traditional MVC frameworks like Rails, Sails or NestJS and low level HTTP frameworks like Sinatra, Express or Fastify. Instead of creating routes, controllers and HTTP request and response handlers, Feathers uses services and workflows (hooks) that let you focus on your application logic independently from how it is being accessed.\n\nThis makes applications easier to understand and test and it allows Feathers to automatically provide REST APIs, websocket real-time APIs (which can often be quite a bit faster) and universal usage on the client and the server. It also makes it possible to add new communication protocols (like HTTP2 or GraphQL) without having to change anything in your application code. Feathers does all that while staying lightweight with a small API surface and codebase and flexible by letting you use it with the backend and frontend technology that best suits your needs.\n\nFor more information\n\n- [Read about the philosophy behind Feathers and where it came from](https://blog.feathersjs.com/why-we-built-the-best-web-framework-you-ve-probably-never-heard-of-until-now-176afc5c6aac)\n- [Learn about the high level design patterns behind Feathers](https://blog.feathersjs.com/design-patterns-for-modern-web-apis-1f046635215)\n\n## Is Feathers production ready?\n\nYes! Feathers had its first stable release in 2014 and is being used in production by a bunch of companies from startups to fortune 500s. For some more details see [this answer on Quora](https://www.quora.com/Is-FeathersJS-production-ready).\n\n## What Node versions does Feathers support\n\nFeathers supports all NodeJS versions from the current Active LTS upwards. See [the Node.JS working group release schedule](https://github.com/nodejs/Release#release-schedule) for more information.\n\n## How do I create custom methods?\n\nFeathers is built around the [REST architectural constraints](https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints) reflected by its standard service methods. There are many benefits using those methods like security, predictability and sending pre-defined real-time events so you should try to structure your application with the [standard service methods](../api/services#service-methods). For example:\n\n> Send email action that does not store mail message in database.\n\nResources (services) don't have to be database records. It can be any kind of resource (like the current weather for a city or creating an email which will send it). Sending emails is usually done with either a separate email [service](../api/services):\n\n```ts\nclass EmailService {\n  async create(data: EmailData) {\n    return sendEmail(data)\n  }\n}\n\napp.use('/email', new EmailService())\n```\n\n> Place an order in e-commerce web site. Behind the scenes, there are many records will be inserted in one transaction: order_item, order_header, voucher_tracking etc.\n\nThis is what [Feathers hooks](../api/hooks) are used for. When creating a new order you also have a well defined hook chain:\n\n```ts\napp.service('orders').hooks({\n  before: {\n    create: [validateData(), checkStock(), checkVoucher()]\n  },\n  after: {\n    create: [\n      chargePayment(), // hook that calls `app.service('payment').create()`\n      sendEmail(), // hook that calls `app.service('email').create()`\n      updateStock() // Update product stock here\n    ]\n  }\n})\n```\n\nHowever, there are some use cases where you might still want to allow additional methods for a client to call (like re-sending a verification email or resetting a password on the user service) and this is what [custom service method](../api/services#custom-methods) can be used for.\n\n## How do I do nested or custom routes?\n\nNormally we find that they actually aren't needed and that it is much better to keep your routes as flat as possible. For example something like `users/:userId/posts` is - although nice to read for humans - actually not as easy to parse and process as the equivalent `/posts?userId=<userid>` that is already [supported by Feathers database adapters](../api/databases/querying). Additionally, this will also work much better when using Feathers through websocket connections which do not have a concept of routes at all.\n\nHowever, nested routes for services can still be created by registering an existing service on the nested route and mapping the route parameter to a query parameter like this:\n\n```ts\napp.use('/posts', postService)\napp.use('/users', userService)\n\n// re-export the posts service on the /users/:userId/posts route\napp.use('/users/:userId/posts', app.service('posts'))\n\n// A hook that updates `data` with the route parameter\nasync function mapUserIdToData(context: HookContext) {\n  if (context.data && context.params.route.userId) {\n    context.data.userId = context.params.route.userId\n  }\n}\n\n// For the new route, map the `:userId` route parameter to the query in a hook\napp.service('users/:userId/posts').hooks({\n  before: {\n    find: [\n      async (context: HookContext) => {\n        // Map the `userId` route parameter to the query\n        context.params.query = {\n          ...context.params.query,\n          userId: context.params.route.userId\n        }\n      }\n    ],\n    create: mapUserIdToData,\n    update: mapUserIdToData,\n    patch: mapUserIdToData\n  }\n})\n```\n\nNow going to `/users/123/posts` will call `postService.find({ query: { userId: 123 } })` and return all posts for that user.\n\nFor more information about URL routing and parameters, refer to [the Express chapter](../api/express).\n\n<BlockQuote type=\"warning\">\nURLs should never contain actions that change data (like `post/publish` or `post/delete`). This has always been an important part of the HTTP protocol and Feathers enforces this more strictly than most other frameworks. For example to publish a post you would call `.patch(id, { published: true })`.\n</BlockQuote>\n\n## Why are you using JWT for sessions\n\nFeathers is using [JSON web tokens (JWT)](https://jwt.io/) for its standard authentication mechanism. Some articles like [Stop using JWT for sessions](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) promotes using standard cookies and HTTP sessions. While it brings up some valid points, not all of them apply to Feathers and there are other good reasons why Feathers relies on JWT:\n\n- Feathers is designed to support many different transport mechanisms, most of which do not rely on HTTP but do work well with JWT as the authentication mechanism. This is even already the case for websockets where an established connection normally is not secured by a traditional HTTP session.\n- By default the only thing that Feathers stored in the JWT payload is the user id. It is a stateful token. You can change this and make the token stateless by putting more data into the JWT payload but this is at your discretion. Currently the user is looked up on every request after the JWT is verified to not be expired or tampered with.\n- You need to make sure that you revoke JWT tokens or set a low expiration date or add custom logic to verify that a userâ€™s account is still valid/active. Currently the default expiration is 1 day. We chose a reasonable default for most apps but depending on your application this might be too long or too short.\n\nAdditionally, it is still possible to use Feathers with existing _traditional_ Express session mechanism by using [custom Express middleware](../api/express). For example, `params.user` for all service calls from a traditional Express session can be passed like this:\n\n```ts\napp.use(function (req, res, next) {\n  // Set service call `param.user` from `session.user`\n  req.feathers.user = req.session.user\n})\n```\n\n## Can you support another database?\n\nFeathers [database adapters](../api/databases/adapters) implement 90% of the functionality you may need to use Feathers with certain databases. You can also find a wide variety of community maintained database adapters [in the ecosystem](/ecosystem/?cat=Database&sort=lastPublish). However, even if your favourite database or ORM is not on the list or the adapter does not support specific functionality you are looking for, Feathers can still accommodate all your needs by [writing your own services](../api/services).\n\n<BlockQuote type=\"warning\">\nTo use Feathers properly it is very important to understand how services work and that all existing database adapters are just services that talk to the database themselves.\n</BlockQuote>\n\nThe why and how to write your own services is covered [in the Feathers guide](../guides/). A custom service can be generated by running `npx feathers generate service`, choosing \"A custom service\" and then editing the `<servicename>/<servicename>.class.js` file to make the database calls.\n\nIf you would like to publish your own database adapter, first make sure there isn't already a [community maintained adapter](/ecosystem/?cat=Database&sort=lastPublish) for that database. If one exists, many maintainers are happy to get some help. If not, you can find a database adapter reference implementation in the [@feathersjs/memory module](https://github.com/feathersjs/feathers/tree/dove/packages/memory). It is always possible for community maintained adapters to graduate into an _official_ Feathers adapter, at the moment there are however no plans to add support for any new databases from the Feathers team directly.\n\n## How do I watch for database changes?\n\nIn order to get real-time updates for a change, all requests have to go through your Feathers application or API server. Feathers **does not** watch the database for changes so if changes in the database are made outside of the Feathers application and clients should be notified, the notification needs to be sent manually.\n\n## How do I do search?\n\nThis depends on the database adapter you are using. See [the search querying chapter](../api/databases/querying#search) for more information.\n\n## Why am I not getting JSON errors?\n\nIf you get a plain text error and a 500 status code for errors that should return different status codes, make sure you have the `express.errorHandler()` from the `@feathersjs/express` module configured as described in the [Express errors](../api/express#expresserrorhandler) chapter.\n\n## Why am I not getting the correct HTTP error code\n\nSee the above answer.\n\n## How can I do custom methods like `findOrCreate`?\n\nCustom functionality can almost always be mapped to an existing service method using hooks. For example, `findOrCreate` can be implemented as a before-hook on the service's `get` method. [See this gist](https://gist.github.com/marshallswain/9fa3b1e855633af00998) for an example of how to implement this in a before-hook. It is also possible to implement [custom methods](../api/services#custom-methods) on the service for functionality that can't be implemented in a hook.\n\n## How do I create channels or rooms\n\nIn Feathers [channels](../api/channels) are the way to send [real-time events](../api/events) to only certain clients.\n\n## How do I do validation?\n\n[Schemas](../api/schema/index) and [validator](../api/schema/validators) are the recommended way to implement basic validations based on JSON schema. [Resolvers](../api/schema/resolvers) can be used for advanced validation like dynamic password policies.\n\nSchemas and resolvers are then used as [validation hooks](../api/schema/validators#hooks) and [resolver hooks](../api/schema/resolvers#hooks). Hooks are also the place to perform validation without schemas and resolvers.\n\n## How do I do associations?\n\nThe preferred way for associations are [resolvers](../api/schema/resolvers). See [the guide](../guides/basics/schemas) for an example on how to do associations.\n\n## How do I access the request object in hooks or services?\n\nIn short, you shouldn't need to. If you look at the [hooks chapter](../api/hooks) you'll see all the params that are available on a hook.\n\nIf you still need something from the request object (for example, the requesting IP address) you can tack it on to the `req.feathers` object as described [here for Express](../api/express#params), here [for Koa](../api/koa#params) or `socket.feathers` when using web sockets as [described here](../api/socketio#appconfiguresocketiocallback).\n\n## How do I mount sub apps?\n\nIt's pretty much exactly the same as Express. More information can be found [here](../api/express#sub-apps).\n\n## How do I do some processing after sending the response to the user?\n\nThe hooks workflow allows you to handle these situations quite gracefully. It depends if you `await` or not in your hook. Here's an example of a hook that sends an email, but doesn't wait for a success message.\n\n```ts\n;async (context: HookContext) => {\n  // Send an email by calling to the email service.\n  context.app.service('emails').create({\n    to: 'user@email.com',\n    body: 'You are so great!'\n  })\n\n  // Send a message to some logging service.\n  context.app.service('logging').create(context.data)\n\n  return context\n}\n```\n\n## How do I debug my app\n\nIt's really no different than debugging any other NodeJS app but you can refer to [this blog post](https://blog.feathersjs.com/debugging-feathers-with-visual-studio-code-406e6adf2882) for more Feathers specific tips and tricks.\n\n## Why can't I pass `params` from the client?\n\nWhen you make a call like:\n\n```ts\nconst params = { foo: 'bar' }\n\nconst user = await client.service('users').patch(1, { admin: true }, params)\n```\n\non the client the `context.params` object will only be available in your client side hooks. It will not be provided to the server. The reason for this is because `context.params` on the server usually contains information that should be server-side only. This can be database options, whether a request is authenticated, etc. If we passed those directly from the client to the server this would be a big security risk. **Only the client side** `context.params.query` and `context.params.headers` objects are provided to the server.\n\nIf you need to pass info from the client to the server that is not part of the query you need to add it to `context.params.query` on the client side and explicitly pull it out of `context.params.query` on the server side. This can be achieved like so:\n\n```ts\n// client side\nclient.hooks({\n  before: {\n    all: [\n      async (context: HookContext) => {\n        context.params.query = {\n          ...context.params.query,\n          $client: {\n            platform: 'ios',\n            version: '1.0'\n          }\n        }\n      }\n    ]\n  }\n})\n```\n\nOn the server in `src/app`:\n\n```ts\napp.hooks({\n  before: {\n    all: [\n      async (context: HookContext) => {\n        // Pull out `$client` parameter and create a new `query` object\n        const {\n          $client: { platform, version },\n          ...query\n        } = params.query\n\n        // Update context.params with the new information\n        context.params = {\n          ...context.params,\n          platform,\n          version,\n          query\n        }\n      }\n    ]\n  }\n})\n```\n\n<BlockQuote type=\"danger\">\nMake sure to validate and sanitize any client side values to prevent security issues.\n</BlockQuote>\n\n## My queries with null values aren't working\n\n<BlockQuote type=\"tip\">\nQuery values will be converted to the correct type automatically when using a [query schema](../api/schema/index). This issue also does not happen when using websockets since it retains all type information.\n</BlockQuote>\n\nWhen making a request using REST (HTTP) query _string_ values don't have any type information and will always be strings. Some database adapters that have a schema (like `feathers-mongoose` or `feathers-sequelize`) will try to convert values to the correct type but others (like `feathers-mongodb`) can't. Additionally, `null` will always be a string and always has to be converted if you want to query for `null`. This can be done in a `before` [hook](../api/hooks):\n\n```ts\napp.service('myservice').hooks({\n  before: {\n    find: [\n      async (context: HookContext) => {\n        const {\n          params: { query = {} }\n        } = context\n\n        if (query.phone === 'null') {\n          query.phone = null\n        }\n\n        context.params.query = query\n\n        return context\n      }\n    ]\n  }\n})\n```\n\nAlso see [this issue](https://github.com/feathersjs/feathers/issues/894).\n\n## Why are queries with arrays failing?\n\nIf you are using REST and queries with larger arrays (more than 21 items to be exact) are failing, you are probably running into an issue with the [querystring](https://github.com/ljharb/qs) module which [limits the size of arrays to 21 items](https://github.com/ljharb/qs#parsing-arrays) by default. The recommended solution is to implement a custom query string parser function via `app.set('query parser', parserFunction)` with the `arrayLimit` option set to a higher value:\n\n```js\nvar qs = require('qs')\n\napp.set('query parser', function (str) {\n  return qs.parse(str, {\n    arrayLimit: 100\n  })\n})\n```\n\nFor more information see the [Express application settings](http://expressjs.com/en/4x/api.html#app.set) [@feathersjs/rest#88](https://github.com/feathersjs/feathers-rest/issues/88) and [feathers-mongoose#205](https://github.com/feathersjs-ecosystem/feathers-mongoose/issues/205).\n\n## I always get a 404 for my custom middleware\n\nJust like in Express itself, the order of middleware matters. If you registered a custom middleware outside of the generator, you have to make sure that it runs before the `notFound()` error midlleware.\n\n## My configuration isn't loaded\n\nIf you are running or requiring the Feathers app from a different folder [Feathers configuration](../api/configuration) needs to be instructed where the configuration files for the app are located. Since it uses [node-config](https://github.com/lorenwest/node-config) this can be done by setting the [NODE_CONFIG_DIR envorinment variable](https://github.com/lorenwest/node-config/wiki/Environment-Variables#node_config_dir).\n\n## How do I set up HTTPS?\n\nIn most production environments your Feathers application should be behind an NginX proxy that handles HTTPS. It is also possible to add SSL directly to your Feathers application which is described in the [Express HTTPS docs](../api/express#https).",
    "breadcrumb": "FAQ",
    "version": "v6",
    "sourceFile": "docs/v6_docs/help/faq.md",
    "heading": "FAQ",
    "subHeadings": [
      "Why should I use Feathers?",
      "Is Feathers production ready?",
      "What Node versions does Feathers support",
      "How do I create custom methods?",
      "How do I do nested or custom routes?",
      "Why are you using JWT for sessions",
      "Can you support another database?",
      "How do I watch for database changes?",
      "How do I do search?",
      "Why am I not getting JSON errors?",
      "Why am I not getting the correct HTTP error code",
      "How can I do custom methods like `findOrCreate`?",
      "How do I create channels or rooms",
      "How do I do validation?",
      "How do I do associations?",
      "How do I access the request object in hooks or services?",
      "How do I mount sub apps?",
      "How do I do some processing after sending the response to the user?",
      "How do I debug my app",
      "Why can't I pass `params` from the client?",
      "My queries with null values aren't working",
      "Why are queries with arrays failing?",
      "I always get a 404 for my custom middleware",
      "My configuration isn't loaded",
      "How do I set up HTTPS?"
    ],
    "hasCode": true,
    "codeLanguages": [
      "ts",
      "text",
      "js"
    ],
    "tokens": 4603,
    "category": "services",
    "tags": [
      "hooks",
      "services",
      "context",
      "params",
      "authentication",
      "jwt",
      "schema",
      "resolver",
      "validation",
      "database",
      "adapter",
      "mongodb",
      "real-time",
      "websockets",
      "channels",
      "events",
      "rest",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "custom methods",
      "middleware",
      "application"
    ]
  },
  {
    "id": "v6-index-0",
    "content": "# Getting Help\nBreadcrumb: Getting Help\nCovers: Resources | Help channels | Consulting and app development | Support Feathers, get help\nTopics: channels, get\n\n## Resources\n\nExisting resources may already have an answer to your question, so it always makes sense checking them first:\n\n- [API Docs >](../api/)\n- [FAQ >](./faq)\n- [GitHub issues >](https://github.com/issues?utf8=%E2%9C%93&q=is%3Aopen+is%3Aissue+user%3Afeathersjs+)\n- [GitHub discussions](https://github.com/feathersjs/feathers/discussions)\n- [Cookbook](/cookbook/)\n- [Blog >](https://blog.feathersjs.com/)\n- [Stack Overflow >](http://stackoverflow.com/questions/tagged/feathersjs)\n\n## Help channels\n\nIf none of those work it's a very real possibility that we screwed something up or it's just not clear. We're sorry :disappointed_relieved: We want to hear about it and are very friendly so feel free to come talk to us:\n\n[Join our Discord server >](https://discord.gg/qa8kez8QBx)\n\n[Submit an issue to GitHub >](https://github.com/feathersjs/feathers/issues/new)\n\n[Ask on StackOverflow using the `feathersjs` tag >](http://stackoverflow.com)\n\n## Consulting and app development\n\n[Feathers Cloud](https://feathers.cloud/) specialize in app development and consulting to get your app on the right track. [Contact us](https://feathers.cloud/consulting.html) to see how we can help.\n\n## Support Feathers, get help\n\nBy [becoming a sponsor](https://github.com/sponsors/daffl/) you support Feathers continued development and get access to a Feathers newsletter and tiers with 30 or 60 minute monthly office hour sessions to walk you through any issues you may be facing using FeathersJS. This may include architecture discussions, debug sessions, patterns, or more.",
    "rawContent": "## Resources\n\nExisting resources may already have an answer to your question, so it always makes sense checking them first:\n\n- [API Docs >](../api/)\n- [FAQ >](./faq)\n- [GitHub issues >](https://github.com/issues?utf8=%E2%9C%93&q=is%3Aopen+is%3Aissue+user%3Afeathersjs+)\n- [GitHub discussions](https://github.com/feathersjs/feathers/discussions)\n- [Cookbook](/cookbook/)\n- [Blog >](https://blog.feathersjs.com/)\n- [Stack Overflow >](http://stackoverflow.com/questions/tagged/feathersjs)\n\n## Help channels\n\nIf none of those work it's a very real possibility that we screwed something up or it's just not clear. We're sorry :disappointed_relieved: We want to hear about it and are very friendly so feel free to come talk to us:\n\n[Join our Discord server >](https://discord.gg/qa8kez8QBx)\n\n[Submit an issue to GitHub >](https://github.com/feathersjs/feathers/issues/new)\n\n[Ask on StackOverflow using the `feathersjs` tag >](http://stackoverflow.com)\n\n## Consulting and app development\n\n[Feathers Cloud](https://feathers.cloud/) specialize in app development and consulting to get your app on the right track. [Contact us](https://feathers.cloud/consulting.html) to see how we can help.\n\n## Support Feathers, get help\n\nBy [becoming a sponsor](https://github.com/sponsors/daffl/) you support Feathers continued development and get access to a Feathers newsletter and tiers with 30 or 60 minute monthly office hour sessions to walk you through any issues you may be facing using FeathersJS. This may include architecture discussions, debug sessions, patterns, or more.",
    "breadcrumb": "Getting Help",
    "version": "v6",
    "sourceFile": "docs/v6_docs/help/index.md",
    "heading": "Getting Help",
    "subHeadings": [
      "Resources",
      "Help channels",
      "Consulting and app development",
      "Support Feathers, get help"
    ],
    "hasCode": false,
    "codeLanguages": [],
    "tokens": 391,
    "category": "events",
    "tags": [
      "channels",
      "get"
    ]
  }
]