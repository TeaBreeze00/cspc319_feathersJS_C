[
  {
    "id": "snp-009",
    "type": "around",
    "useCase": "Measure method execution time",
    "code": "app.service('messages').hooks({\n  around: {\n    all: [\n      async (context: HookContext, next: NextFunction) => {\n        const startTime = Date.now()\n        await next()\n        const duration = Date.now() - startTime\n        console.log(`${context.method} on ${context.path} took ${duration}ms`)\n      }\n    ]\n  }\n})",
    "explanation": "Around hook that wraps a service method to measure and log execution time.",
    "version": "both",
    "language": "typescript",
    "tags": [
      "performance",
      "timing",
      "logging",
      "monitoring"
    ]
  },
  {
    "id": "snp-010",
    "type": "around",
    "useCase": "Transaction wrapper for Knex",
    "code": "import { transaction } from '@feathersjs/knex'\n\napp.service('orders').hooks({\n  around: {\n    create: [transaction.start(), transaction.end()],\n  },\n  error: {\n    create: [transaction.rollback()],\n  }\n})",
    "explanation": "Wraps the create method in a Knex database transaction. Automatically commits on success and rolls back on error.",
    "version": "both",
    "language": "typescript",
    "tags": [
      "transaction",
      "knex",
      "sql",
      "database"
    ]
  },
  {
    "id": "snp-011",
    "type": "around",
    "useCase": "Soft delete pattern",
    "code": "app.service('messages').hooks({\n  around: {\n    remove: [\n      async (context: HookContext, next: NextFunction) => {\n        // Instead of deleting, patch with deletedAt\n        context.result = await context.service.patch(context.id, {\n          deletedAt: Date.now()\n        })\n        // Skip the actual remove by not calling next()\n      }\n    ],\n    find: [\n      async (context: HookContext, next: NextFunction) => {\n        // Filter out soft-deleted records\n        context.params.query = {\n          ...context.params.query,\n          deletedAt: null\n        }\n        await next()\n      }\n    ]\n  }\n})",
    "explanation": "Implements soft delete by patching a deletedAt field instead of actually removing records. Filters soft-deleted records from find queries.",
    "version": "both",
    "language": "typescript",
    "tags": [
      "soft-delete",
      "remove",
      "pattern"
    ]
  },
  {
    "id": "snp-016",
    "type": "channels",
    "useCase": "Room-based channel pattern",
    "code": "app.service('messages').publish('created', (data: Message, context: HookContext) => {\n  return app.channel(`room/${data.roomId}`)\n})\n\n// Join room when user connects\napp.on('login', (authResult: any, { connection }: Params) => {\n  if (connection) {\n    const user = authResult.user\n    user.rooms.forEach((roomId: string) => {\n      app.channel(`room/${roomId}`).join(connection)\n    })\n  }\n})",
    "explanation": "Room-based real-time messaging pattern using channels. Users join room channels on login; messages are published to the specific room channel.",
    "version": "both",
    "language": "typescript",
    "tags": [
      "channels",
      "rooms",
      "real-time",
      "publish"
    ]
  },
  {
    "id": "snp-017",
    "type": "channels",
    "useCase": "User-specific events",
    "code": "app.service('notifications').publish((data: any, context: HookContext) => {\n  return app.channel(app.channels).filter(connection =>\n    connection.user?.id === data.userId\n  )\n})",
    "explanation": "Publishes events only to the specific user the notification belongs to, using channel filtering.",
    "version": "both",
    "language": "typescript",
    "tags": [
      "channels",
      "filter",
      "user-specific",
      "notifications"
    ]
  },
  {
    "id": "snp-027",
    "type": "around",
    "useCase": "Cache with invalidation",
    "code": "const cache = new Map()\n\napp.service('settings').hooks({\n  around: {\n    find: [async (context: HookContext, next: NextFunction) => {\n      const key = 'settings:' + JSON.stringify(context.params.query || {})\n      const cached = cache.get(key)\n      if (cached) { context.result = cached; return }\n      await next()\n      cache.set(key, context.result)\n    }],\n    create: [async (context: HookContext, next: NextFunction) => {\n      await next()\n      cache.clear() // Invalidate on write\n    }],\n    patch: [async (context: HookContext, next: NextFunction) => {\n      await next()\n      cache.clear()\n    }]\n  }\n})",
    "explanation": "Around hook implementing read-through cache with automatic invalidation on writes.",
    "version": "both",
    "language": "typescript",
    "tags": [
      "cache",
      "performance",
      "around"
    ]
  },
  {
    "id": "snp-028",
    "type": "around",
    "useCase": "Request context propagation",
    "code": "app.hooks({\n  around: {\n    all: [\n      async (context: HookContext, next: NextFunction) => {\n        // Add request ID for tracing\n        context.params.requestId = context.params.requestId ||\n          Math.random().toString(36).substring(2, 15)\n        await next()\n      }\n    ]\n  }\n})",
    "explanation": "Adds a unique request ID to all service calls for distributed tracing.",
    "version": "both",
    "language": "typescript",
    "tags": [
      "tracing",
      "context",
      "around",
      "monitoring"
    ]
  }
]