[
  {
    "id": "hook-common-disallow-external",
    "type": "common",
    "useCase": "Restrict a method to internal calls only",
    "code": "// Common hook: disallow external access\nconst disallowExternal = async (context: HookContext) => {\n  if (context.params.provider) {\n    throw new Forbidden('This method is not available via external access');\n  }\n  return context;\n};\n\n// v4 equivalent using feathers-hooks-common:\n// const { disallow } = require('feathers-hooks-common');\n// before: { update: [disallow('external')] }\n\n// Usage: before: { update: [disallowExternal] }",
    "explanation": "Prevents external clients (REST, Socket.io) from calling specific methods. Useful for blocking update or internal-only operations.",
    "version": "both"
  },
  {
    "id": "hook-common-rate-limit",
    "type": "common",
    "useCase": "Rate-limit service calls per user",
    "code": "// Common pattern: simple in-memory rate limiter\nconst rateLimit = (maxPerMinute = 60) => {\n  const counts = new Map<string, { count: number; reset: number }>();\n\n  return async (context: HookContext) => {\n    const key = context.params.user?._id || context.params.ip || 'anonymous';\n    const now = Date.now();\n    let entry = counts.get(key);\n\n    if (!entry || now > entry.reset) {\n      entry = { count: 0, reset: now + 60_000 };\n      counts.set(key, entry);\n    }\n\n    entry.count++;\n    if (entry.count > maxPerMinute) {\n      throw new TooManyRequests('Rate limit exceeded. Try again later.');\n    }\n    return context;\n  };\n};\n\n// Usage: before: { all: [rateLimit(100)] }",
    "explanation": "Simple per-user rate limiter using an in-memory Map. Resets every 60 seconds. Use a Redis-backed solution in production clusters.",
    "version": "both"
  },
  {
    "id": "hook-common-soft-delete",
    "type": "common",
    "useCase": "Implement soft-delete instead of hard removal",
    "code": "// Common hook: soft delete pattern\nconst softDelete = async (context: HookContext) => {\n  const { method, service, id, params } = context;\n\n  if (method === 'remove') {\n    // Instead of removing, patch with deleted flag\n    context.result = await service.patch(id, {\n      deleted: true,\n      deletedAt: new Date().toISOString()\n    }, params);\n    return context;\n  }\n\n  if (method === 'find') {\n    // Exclude soft-deleted records from finds\n    context.params.query = {\n      ...context.params.query,\n      deleted: { $ne: true }\n    };\n  }\n\n  return context;\n};\n\n// Usage: before: { all: [softDelete] }",
    "explanation": "Intercepts remove calls and converts them to patches that set a deleted flag. Also filters soft-deleted records from find queries.",
    "version": "both"
  },
  {
    "id": "hook-common-cache-result",
    "type": "common",
    "useCase": "Cache get/find results in memory",
    "code": "// Common hook: in-memory cache for get/find\nconst cache = (ttlMs = 30_000) => {\n  const store = new Map<string, { data: any; expires: number }>();\n\n  const before = async (context: HookContext) => {\n    if (context.method !== 'find' && context.method !== 'get') return context;\n    const key = JSON.stringify({ path: context.path, method: context.method, id: context.id, query: context.params.query });\n    const cached = store.get(key);\n    if (cached && Date.now() < cached.expires) {\n      context.result = cached.data;\n    }\n    context.params._cacheKey = key;\n    return context;\n  };\n\n  const after = async (context: HookContext) => {\n    const key = context.params._cacheKey;\n    if (key && (context.method === 'find' || context.method === 'get')) {\n      store.set(key, { data: context.result, expires: Date.now() + ttlMs });\n    }\n    return context;\n  };\n\n  return { before, after };\n};\n\n// Usage:\n// const { before: cacheBefore, after: cacheAfter } = cache(60_000);\n// hooks: { before: { find: [cacheBefore] }, after: { find: [cacheAfter] } }",
    "explanation": "Two-phase cache hook (before checks cache, after stores). Avoids redundant DB reads for frequently accessed data.",
    "version": "both"
  },
  {
    "id": "hook-common-v4-authenticate-all",
    "type": "common",
    "useCase": "v4 pattern for authenticating all service methods",
    "code": "const { authenticate } = require('@feathersjs/authentication').hooks;\nconst { iff, isProvider } = require('feathers-hooks-common');\n\nmodule.exports = {\n  before: {\n    all: [iff(isProvider('external'), authenticate('jwt'))],\n    find: [],\n    get: [],\n    create: [],\n    update: [],\n    patch: [],\n    remove: []\n  },\n  after: { all: [] },\n  error: { all: [] }\n};",
    "explanation": "v4 pattern using feathers-hooks-common conditionals. Only authenticates external (REST/Socket) requests, allowing internal service-to-service calls without auth.",
    "version": "v4"
  },
  {
    "id": "hook-common-v5-resolve-dispatch",
    "type": "common",
    "useCase": "v5 resolver to dispatch different data to real-time events",
    "code": "import { resolve } from '@feathersjs/schema';\nimport { Type } from '@feathersjs/typebox';\nimport type { HookContext } from '../declarations';\n\n// Define a dispatch schema â€” what gets sent via events\nconst messageDispatchSchema = Type.Object({\n  _id: Type.String(),\n  text: Type.String(),\n  userId: Type.String(),\n  createdAt: Type.String()\n});\n\nexport const messageDispatchResolver = resolve(messageDispatchSchema, {\n  properties: {}\n});\n\n// Usage in service registration:\n// app.service('messages').hooks({\n//   around: { all: [schemaHooks.resolveDispatch(messageDispatchResolver)] }\n// });",
    "explanation": "v5 dispatch resolvers control what data is sent via real-time events. This prevents sending sensitive data (like passwords) over WebSockets.",
    "version": "v5"
  }
]
