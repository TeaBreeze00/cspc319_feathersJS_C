[
  {
    "id": "v5-guides-basics-services",
    "title": "Services",
    "content": "Services | feathers\n    \n    \n    â€¢ Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Services â€‹\nServices are the heart of every Feathers application. You probably remember the service we made in the quick start to create and find messages. In this chapter we will dive more into services and create a database backed service for our chat messages.\n## Feathers services â€‹\nIn Feathers, a service is an object or instance of a class that implements certain methods. Services provide a way for Feathers to interact with different kinds of data sources in a uniform, protocol-independent way.For example, you could use services to read and/or write data to one of the supported databases, interact with the file system, call a third-party API/service (such as MailGun for sending emails, Stripe for processing payments, or OpenWeatherMap for returning weather information), or even read and/or write to a completely different type of database.A standardized interface allows us to interact with the Database/API/Gnomes inside in a uniform manner across any transport protocol, be it REST, websockets, internally within the application, or Carrier Pigeon ðŸ•Šï¸Once you write a service method, which usually does not do anything Feathers-specific, you can automatically use it as a REST endpoint or call it through a websocket. Feathers takes care of all the necessary boilerplate, so you can focus on writing the service method itself.\n### Service methods â€‹\nService methods are CRUD methods that a service can implement. Feathers offers a set of general methods that a service can implement, these are:`find` - Find all data (potentially matching a query)\nâ€¢ `get` - Get a single data entry by its unique identifier\nâ€¢ `create` - Create new data\nâ€¢ `update` - Update an existing data entry by completely replacing it\nâ€¢ `patch` - Update one or more data entries by merging with the new data\nâ€¢ `remove` - Remove one or more existing data entries\nâ€¢ `setup` - Called when the application is started\nâ€¢ `teardown` - Called when the application is shut down\n\nBelow is an example of Feathers service interface as a class and basic registration on a Feathers application via app.use(name, service[, options]):\n\nts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport type { Application, Id, NullableId, Params } from '@feathersjs/feathers'\n\nclass MyService {\n  async find(params: Params) {}\n  async get(id: Id, params: Params) {}\n  async create(data: any, params: Params) {}\n  async update(id: NullableId, data: any, params: Params) {}\n  async patch(id: NullableId, data: any, params: Params) {}\n  async remove(id: NullableId, params: Params) {}\n  async setup(path: string, app: Application) {}\n  async teardown(path: string, app: Application) {}\n}\n\nconst app = feathers()\n\napp.use('myservice', new MyService())\n```\n\nThe parameters for service methods are:\nâ€¢ `id` - The unique identifier for the data\nâ€¢ `data` - The data sent by the user (for `create`, `update`, `patch` and custom methods)\nâ€¢ `params` - Additional parameters, for example the authenticated user or the query\n\nFor `setup` and `teardown` (which are only called once on application startup and shutdown) we have\nâ€¢ `path` - The path the service is registered on\nâ€¢ `app` - The Feathers application\n\nUsually those methods can be used for most API functionality but it is also possible to add your own custom service methods.\n\ninfo\n\nA service does not have to implement all those methods but must have at least one. For more information about services, service methods, and parameters see the Service API documentation.\n\nWhen used as a REST API, incoming requests get mapped automatically to their corresponding service method like this:\n\nService methodHTTP methodPath\n\n`service.find({ query: {} })`GET/messages\n\n`service.find({ query: { unread: true } })`GET/messages?unread=true\n\n`service.get(123)`GET/messages/123\n\n`service.create(body)`POST/messages\n\n`service.update(123, body)`PUT/messages/123\n\n`service.patch(123, body)`PATCH/messages/123\n\n`service.remove(123)`DELETE/messages/123\n\n### Service events â€‹\n\nA registered service will automatically become a NodeJS EventEmitter that sends events with the new data when a service method that modifies data (`create`, `update`, `patch` and `remove`) returns. Events can be listened to with `app.service('messages').on('eventName', data => {})`. Here is a list of the service methods and their corresponding events:\n\nService methodService event\n\n`service.create()``service.on('created')`\n\n`service.update()``service.on('updated')`\n\n`service.patch()``service.on('patched')`\n\n`service.remove()``service.on('removed')`\n\nThis is how Feathers does real-time.\n\njs\n```\napp.service('myservice').on('created', (data) => {\n  console.log('Got created event', data)\n})\n```\n\n## Database adapters â€‹\n\nNow that we have all those service methods, we could go ahead and implement any kind of custom logic using any backend, similar to what we did in the quick start guide. Very often, this means creating, rea",
    "version": "v5",
    "tokens": [
      "services",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "are",
      "the",
      "heart",
      "every",
      "application",
      "you",
      "probably",
      "remember",
      "service",
      "made",
      "quick",
      "start",
      "create",
      "and",
      "find",
      "messages",
      "this",
      "chapter",
      "will",
      "dive",
      "more",
      "into",
      "database",
      "backed",
      "for",
      "our",
      "chat",
      "object",
      "instance",
      "class",
      "that",
      "implements",
      "certain",
      "methods",
      "provide",
      "way",
      "interact",
      "with",
      "different",
      "kinds",
      "data",
      "sources",
      "uniform",
      "protocol",
      "independent",
      "example",
      "could",
      "use",
      "read",
      "write",
      "one",
      "supported",
      "databases",
      "file",
      "system",
      "call",
      "third",
      "party",
      "api",
      "such",
      "mailgun",
      "sending",
      "emails",
      "stripe",
      "processing",
      "payments",
      "openweathermap",
      "returning",
      "weather",
      "information",
      "even",
      "completely",
      "type",
      "standardized",
      "interface",
      "allows",
      "gnomes",
      "inside",
      "manner",
      "across",
      "any",
      "transport",
      "rest",
      "websockets",
      "internally",
      "within",
      "carrier",
      "pigeon",
      "once",
      "method",
      "which",
      "usually",
      "does",
      "not",
      "anything",
      "specific",
      "can",
      "automatically",
      "endpoint",
      "through",
      "websocket",
      "takes",
      "care",
      "all",
      "necessary",
      "boilerplate",
      "focus",
      "writing",
      "itself",
      "crud",
      "implement",
      "offers",
      "set",
      "general",
      "these",
      "potentially",
      "matching",
      "query",
      "get",
      "single",
      "entry",
      "its",
      "unique",
      "identifier",
      "new",
      "update",
      "existing",
      "replacing",
      "patch",
      "entries",
      "merging",
      "remove",
      "setup",
      "called",
      "when"
    ],
    "category": "services"
  },
  {
    "id": "v5-guides-cli-service",
    "title": "Service",
    "content": "Service | feathers\n    \n    \n    â€¢ Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Service â€‹\nThe main service file registers the service on the application as well as the hooks used on this service.\n## Registration â€‹\nThe service is added to the main application via app.use under the path you chose when creating the service. It usses the following options:`methods` - A list of methods available for external clients. You can remove methods that are not used or add your own custom methods. Not that this list also has to be updated in the client file.\nâ€¢ `events` - A list of additional custom events sent to clients.\n\nIn TypeScript the `ServiceTypes` interface defined in the declarations will also be extended with the correct service class type using the shared path as a key:\n\nts\n```\ndeclare module '../../../declarations' {\n  interface ServiceTypes {\n    [testingPath]: TestingService\n  }\n}\n```\n\n## Registering hooks â€‹\n\nThis file is also where service hooks are registered on the service. Depending on the selection, it commonly includes the authentication hook and hooks that validate and resolve the schemas from the service.schemas file.\n\nts\n```\n// Initialize hooks\napp.service(messagePath).hooks({\n  around: {\n    all: [\n      authenticate('jwt'),\n      schemaHooks.resolveExternal(messageExternalResolver),\n      schemaHooks.resolveResult(messageResolver)\n    ]\n  },\n  before: {\n    all: [schemaHooks.validateQuery(messageQueryValidator), schemaHooks.resolveQuery(messageQueryResolver)],\n    find: [],\n    get: [],\n    create: [schemaHooks.validateData(messageDataValidator), schemaHooks.resolveData(messageDataResolver)],\n    patch: [schemaHooks.validateData(messagePatchValidator), schemaHooks.resolveData(messagePatchResolver)],\n    remove: []\n  },\n  after: {\n    all: []\n  },\n  error: {\n    all: []\n  }\n})\n```\n\nNote that you can add hooks to a specific method as documented in the hook registration API. For example, to use the profiling hook only for `find` and `get` the registration can be updated like this:\n\nts\n```\nimport { profiler } from '../../hooks/profiler'\n// ...\n\n// Initialize hooks\napp.service(messagePath).hooks({\n  around: {\n    all: [\n      authenticate('jwt'),\n      schemaHooks.resolveExternal(messageExternalResolver),\n      schemaHooks.resolveResult(messageResolver)\n    ],\n    find: [profiler],\n    get: [profiler]\n  },\n  before: {\n    all: [schemaHooks.validateQuery(messageQueryValidator), schemaHooks.resolveQuery(messageQueryResolver)],\n    find: [],\n    get: [],\n    create: [schemaHooks.validateData(messageDataValidator), schemaHooks.resolveData(messageDataResolver)],\n    patch: [schemaHooks.validateData(messagePatchValidator), schemaHooks.resolveData(messagePatchResolver)],\n    remove: []\n  },\n  after: {\n    all: []\n  },\n  error: {\n    all: []\n  }\n})\n```\n\nThis also applies to any hook plugins like feathers-hooks-common.\n\n Suggest changes to this page\n\nLast updated: \n\nReleased under the MIT License.\n\nCopyright Â© 2012-2026 FeathersJS contributors\n\n feathers \n\nâ€¢ About\nâ€¢ Philosophy\nâ€¢ Comparison\nâ€¢ Ecosystem\nâ€¢ Learn\nâ€¢ Guides\nâ€¢ API\nâ€¢ Blog\nâ€¢ Ecosystem\nâ€¢ Become a Backer\nâ€¢ Find Help\nâ€¢ Github Issues\n\nReleased under the MIT License.\n\nCopyright Â© 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "service",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "the",
      "main",
      "file",
      "registers",
      "application",
      "well",
      "hooks",
      "used",
      "this",
      "registration",
      "added",
      "via",
      "app",
      "use",
      "under",
      "path",
      "you",
      "chose",
      "when",
      "creating",
      "usses",
      "following",
      "options",
      "methods",
      "list",
      "available",
      "for",
      "external",
      "clients",
      "can",
      "remove",
      "that",
      "are",
      "not",
      "add",
      "your",
      "own",
      "custom",
      "also",
      "has",
      "updated",
      "client",
      "events",
      "additional",
      "sent",
      "typescript",
      "servicetypes",
      "interface",
      "defined",
      "declarations",
      "will",
      "extended",
      "with",
      "correct",
      "class",
      "type",
      "using",
      "shared",
      "key",
      "declare",
      "module",
      "testingpath",
      "testingservice",
      "registering",
      "where",
      "registered",
      "depending",
      "selection",
      "commonly",
      "includes",
      "authentication",
      "hook",
      "and",
      "validate",
      "resolve",
      "schemas",
      "from",
      "initialize",
      "messagepath",
      "around",
      "all",
      "authenticate",
      "jwt",
      "schemahooks",
      "resolveexternal",
      "messageexternalresolver",
      "resolveresult",
      "messageresolver",
      "before",
      "validatequery",
      "messagequeryvalidator",
      "resolvequery",
      "messagequeryresolver",
      "find",
      "get",
      "create",
      "validatedata",
      "messagedatavalidator",
      "resolvedata",
      "messagedataresolver",
      "patch",
      "messagepatchvalidator",
      "messagepatchresolver",
      "after",
      "error",
      "note",
      "specific",
      "method",
      "documented",
      "api",
      "example",
      "profiling",
      "only"
    ],
    "category": "services"
  },
  {
    "id": "v5-guides-cli-service.class",
    "title": "Service classes",
    "content": "Service classes | feathers\n    \n    \n    â€¢ Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Service classes â€‹\nThe `.class` file exports the service class or object.\n## Database services ï¿½ï¿½\nWhen using a database, the service class will be extended from the Feathers database adapter service. Like any class, existing methods can be overriden or you can add your own methods (which can also be made available externally as custom methods when registering the service).NoteThe generic types for a database service are always `AdapterService`. The `MessageService` generic is used to change the parameter type when using this service interface as a client side service.\n### Overriding methods â€‹\nWhen overriding an existing service method on a database adapter the method and overload signatures have to match. The following example shows how to override every service method. Only the methods you want to customize have to be added.The SQL Knex service methods can be customized like this:ts\n```\nimport { Id, NullableId, Paginated } from '@feathersjs/feathers'\n\nexport interface MessageParams extends KnexAdapterParams {}\n\n// By default calls the standard Knex adapter service methods but can be customized with your own functionality.\nexport class MessageService extends KnexService {\n  async find(\n    params?: MessageParams & { paginate?: { default?: number; max?: number } }\n  ): Promise>\n  async find(params?: ServiceParams & { paginate: false }): Promise\n  async find(params?: ServiceParams): Promise | Message[]>\n  async find(params?: ServiceParams): Promise | Message[]> {\n    return super.find(params)\n  }\n\n  async get(id: Id, params?: ServiceParams): Promise {\n    return super.get(id, params)\n  }\n\n  async create(data: MessageData, params?: ServiceParams): Promise\n  async create(data: MessageData[], params?: ServiceParams): Promise\n  async create(data: MessageData | MessageData[], params?: ServiceParams): Promise {\n    return super.create(data, params)\n  }\n\n  async update(id: Id, data: Data, params?: ServiceParams): Promise {\n    return super.update(id, data, params)\n  }\n\n  async patch(id: Id, data: MessagePatch, params?: ServiceParams): Promise\n  async patch(id: null, data: MessagePatch, params?: ServiceParams): Promise\n  async patch(id: NullableId, data: MessagePatch, params?: ServiceParams): Promise {\n    return super.patch(id, data, params)\n  }\n\n  async remove(id: Id, params?: ServiceParams): Promise\n  async remove(id: null, params?: ServiceParams): Promise\n  async remove(id: NullableId, params?: ServiceParams): Promise {\n    return super.remove(id, params)\n  }\n}\n```\nThe MongoDB service methods can be customized like this:ts\n```\nimport { Paginated } from '@feathersjs/feathers'\nimport { AdapterId } from '@feathersjs/mongodb'\n\nexport interface MessageParams extends MongoDBAdapterParams {}\n\n// By default calls the standard MongoDB adapter service methods but can be customized with your own functionality.\nexport class MessageService extends MongoDBService {\n  async find(\n    params?: ServiceParams & { paginate?: { paginate?: { default?: number; max?: number } } }\n  ): Promise>\n  async find(params?: ServiceParams & { paginate: false }): Promise\n  async find(params?: ServiceParams): Promise | Message[]>\n  async find(params?: ServiceParams): Promise | Message[]> {\n    return super.find(params)\n  }\n\n  async get(id: AdapterId, params?: ServiceParams): Promise {\n    return super.get(id, params)\n  }\n\n  async create(data: MessageData, params?: ServiceParams): Promise\n  async create(data: MessageData[], params?: ServiceParams): Promise\n  async create(data: MessageData | MessageData[], params?: ServiceParams): Promise {\n    return super.create(data, params)\n  }\n\n  async update(id: AdapterId, data: MessageData, params?: ServiceParams): Promise {\n    return super.update(id, data, params)\n  }\n\n  async patch(id: null, data: MessagePatch, params?: ServiceParams): Promise\n  async patch(id: AdapterId, data: MessagePatch, params?: ServiceParams): Promise\n  async patch(\n    id: NullableAdapterId,\n    data: MessagePatch,\n    params?: ServiceParams\n  ): Promise {\n    return super.patch(id, data, params)\n  }\n\n  async remove(id: AdapterId, params?: ServiceParams): Promise\n  async remove(id: null, params?: ServiceParams): Promise\n  async remove(id: NullableAdapterId, params?: ServiceParams): Promise {\n    return super.remove(id, params)\n  }\n}\n```\n\n### Other service methods â€‹\nIt is also possible to write your own service methods where the signatures don't have to match by extending from the `KnexAdapter` (instead of the `KnexService`) class. It does not have any of the service methods implemented but you can use the internal `_find`, `_get`, `_update`, `_patch` and `_remove` adapter methods to work with the database and implement the service method in the way you need.ts\n```\nimport { Id } from '@feathersjs/feathers'\nimport { KnexAdapter } from '@feathersjs/knex'\n\nexport interface MessageParams extends KnexAdapterParams {}\n\n// By default ca",
    "version": "v5",
    "tokens": [
      "service",
      "classes",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "the",
      "class",
      "file",
      "exports",
      "object",
      "database",
      "services",
      "when",
      "using",
      "will",
      "extended",
      "from",
      "adapter",
      "like",
      "any",
      "existing",
      "methods",
      "can",
      "overriden",
      "you",
      "add",
      "your",
      "own",
      "which",
      "also",
      "made",
      "available",
      "externally",
      "custom",
      "registering",
      "notethe",
      "generic",
      "types",
      "for",
      "are",
      "always",
      "adapterservice",
      "messageservice",
      "used",
      "change",
      "parameter",
      "type",
      "this",
      "interface",
      "client",
      "side",
      "overriding",
      "method",
      "and",
      "overload",
      "signatures",
      "have",
      "match",
      "following",
      "example",
      "shows",
      "how",
      "override",
      "every",
      "only",
      "want",
      "customize",
      "added",
      "sql",
      "knex",
      "customized",
      "import",
      "nullableid",
      "paginated",
      "feathersjs",
      "export",
      "messageparams",
      "extends",
      "knexadapterparams",
      "default",
      "calls",
      "standard",
      "but",
      "with",
      "functionality",
      "knexservice",
      "async",
      "find",
      "params",
      "paginate",
      "number",
      "max",
      "promise",
      "serviceparams",
      "false",
      "message",
      "return",
      "super",
      "get",
      "create",
      "data",
      "messagedata"
    ],
    "category": "services"
  },
  {
    "id": "v5-guides-cli-service.schemas",
    "title": "Service Schemas and Resolvers",
    "content": "Service Schemas and Resolvers | feathers\n    \n    \n    â€¢ Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Service Schemas and Resolvers â€‹\nThe `.schemas` file contains the schemas and resolvers for this service.infoThe examples on this page are using TypeBox. For more information on plain JSON schema see the JSON schema API documentation.\n## Patterns â€‹\nThere a four main types of schemas and resolvers. The schemas, resolvers and types are declared as follows:ts\n```\n// The schema definition\nexport const nameSchema = Type.Object({\n  text: Type.String()\n})\n// The TypeScript type inferred from the schema\nexport type Name = Static\n// The validator for the schema\nexport const nameValidator = getValidator(nameSchema, dataValidator)\n// The resolver for the schema\nexport const nameResolver = resolve({})\n```\n\n## Main schema and resolvers â€‹\nThis schema defines the main data model of all properties and is normally the shape of the data that is returned. This includes database properties as well as associations and other computed properties.ts\n```\n// Main data model schema\nexport const messageSchema = Type.Object(\n  {\n    id: Type.Number(),\n    text: Type.String()\n  },\n  { $id: 'Message', additionalProperties: false }\n)\nexport type Message = Static\nexport const messageValidator = getValidator(messageSchema, dataValidator)\nexport const messageResolver = resolve({})\n```\n\n## External Resolvers â€‹\nThe external resolver defines the data that is sent to a client and is often use to e.g. hide protected properties they should not see:ts\n```\nexport const messagesExternalResolver = resolve({\n  someSecretProperty: async () => undefined\n})\n```\n\n## Data schema and resolvers â€‹\nThe data schema validates the data when creating a new entry calling service.create. It usually picks its properties from the main schema but can be changed to whatever is needed.ts\n```\n// Schema for creating new entries\nexport const messageDataSchema = Type.Pick(messageSchema, ['text'], {\n  $id: 'MessageData'\n})\nexport type MessageData = Static\nexport const messageDataValidator = getValidator(messageDataSchema, dataValidator)\nexport const messageDataResolver = resolve({})\n```\n\n## Patch schema and Resolvers â€‹\nThe patch schema is used for updating existing entries calling service.patch. This is often different then the data schema for new entries and by default is a partial of the main schema.ts\n```\n// Schema for updating existing entries\nexport const messagePatchSchema = Type.Partial(messageSchema, {\n  $id: 'MessagePatch'\n})\nexport type MessagePatch = Static\nexport const messagePatchValidator = getValidator(messagePatchSchema, dataValidator)\nexport const messagePatchResolver = resolve({})\n```\n\n## Query Schema and Resolvers â€‹\nThe query schema defines what can be sent in queries in params.query and also converts strings to the correct type.ts\n```\n// Schema for allowed query properties\nexport const messageQueryProperties = Type.Pick(messageSchema, ['id', 'text', 'createdAt', 'userId'])\nexport const messageQuerySchema = Type.Intersect(\n  [\n    querySyntax(messageQueryProperties),\n    // Add additional query properties here\n    Type.Object({}, { additionalProperties: false })\n  ],\n  { additionalProperties: false }\n)\nexport type MessageQuery = Static\nexport const messageQueryValidator = getValidator(messageQuerySchema, queryValidator)\nexport const messageQueryResolver = resolve({})\n```\nTo add additional operators like `$like` see the querySyntax documentation. You can also add your own query parameters in the `Type.Object({}, { additionalProperties: false })` definition.ImportantNote that references (`Type.Ref`) can not be used in a query schema. Association querying is usually done by dot separated properties which have to be added manually in MongoDB and SQL. Suggest changes to this pageLast updated: Released under the MIT License.Copyright Â© 2012-2026 FeathersJS contributors feathers About\nâ€¢ Philosophy\nâ€¢ Comparison\nâ€¢ Ecosystem\nâ€¢ Learn\nâ€¢ Guides\nâ€¢ API\nâ€¢ Blog\nâ€¢ Ecosystem\nâ€¢ Become a Backer\nâ€¢ Find Help\nâ€¢ Github Issues\n\nReleased under the MIT License.\n\nCopyright Â© 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "service",
      "schemas",
      "and",
      "resolvers",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "the",
      "file",
      "contains",
      "for",
      "this",
      "infothe",
      "examples",
      "page",
      "are",
      "using",
      "typebox",
      "more",
      "information",
      "plain",
      "json",
      "schema",
      "see",
      "api",
      "documentation",
      "patterns",
      "there",
      "four",
      "main",
      "types",
      "declared",
      "follows",
      "definition",
      "export",
      "const",
      "nameschema",
      "type",
      "object",
      "text",
      "string",
      "typescript",
      "inferred",
      "from",
      "name",
      "static",
      "validator",
      "namevalidator",
      "getvalidator",
      "datavalidator",
      "resolver",
      "nameresolver",
      "resolve",
      "defines",
      "data",
      "model",
      "all",
      "properties",
      "normally",
      "shape",
      "that",
      "returned",
      "includes",
      "database",
      "well",
      "associations",
      "other",
      "computed",
      "messageschema",
      "number",
      "message",
      "additionalproperties",
      "false",
      "messagevalidator",
      "messageresolver",
      "external",
      "sent",
      "client",
      "often",
      "use",
      "hide",
      "protected",
      "they",
      "should",
      "not",
      "messagesexternalresolver",
      "somesecretproperty",
      "async",
      "undefined",
      "validates",
      "when",
      "creating",
      "new",
      "entry",
      "calling",
      "create",
      "usually",
      "picks",
      "its",
      "but",
      "can",
      "changed",
      "whatever",
      "needed",
      "entries",
      "messagedataschema",
      "pick"
    ],
    "category": "services"
  },
  {
    "id": "v5-guides-cli-service.shared",
    "title": "Service Shared",
    "content": "Service Shared | feathers\n    \n    \n    â€¢ Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Service Shared â€‹\nThe `.shared` file contains variables and type declarations that are shared between the client and the server application. It can also be used for shared utility functions or schemas (e.g. for client side validation).\n## Variables â€‹\nBy default two shared variables are exported:`Path` - The path of the service. Changing this will change the path for the service in all places like the application, the client and types\nâ€¢ `Methods` - The list of service methods available to the client. This can be updated with service and custom methods a client should be able to use.\n\n## Client setup â€‹\n\nThis file also includes the client side service registration which will be included in the client. It will register a client side service based on the shared path and methods.\n\n Suggest changes to this page\n\nLast updated: \n\nReleased under the MIT License.\n\nCopyright Â© 2012-2026 FeathersJS contributors\n\n feathers \n\nâ€¢ About\nâ€¢ Philosophy\nâ€¢ Comparison\nâ€¢ Ecosystem\nâ€¢ Learn\nâ€¢ Guides\nâ€¢ API\nâ€¢ Blog\nâ€¢ Ecosystem\nâ€¢ Become a Backer\nâ€¢ Find Help\nâ€¢ Github Issues\n\nReleased under the MIT License.\n\nCopyright Â© 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "service",
      "shared",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "the",
      "file",
      "contains",
      "variables",
      "and",
      "type",
      "declarations",
      "that",
      "are",
      "between",
      "client",
      "server",
      "application",
      "can",
      "also",
      "used",
      "for",
      "utility",
      "functions",
      "schemas",
      "side",
      "validation",
      "default",
      "two",
      "exported",
      "path",
      "changing",
      "this",
      "will",
      "change",
      "all",
      "places",
      "like",
      "types",
      "methods",
      "list",
      "available",
      "updated",
      "with",
      "custom",
      "should",
      "able",
      "use",
      "setup",
      "includes",
      "registration",
      "which",
      "included",
      "register",
      "based",
      "suggest",
      "changes",
      "page",
      "last",
      "released",
      "under",
      "mit",
      "license",
      "copyright",
      "feathersjs",
      "contributors",
      "about",
      "philosophy",
      "comparison",
      "ecosystem",
      "learn",
      "guides",
      "api",
      "blog",
      "become",
      "backer",
      "find",
      "help",
      "github",
      "issues"
    ],
    "category": "services"
  },
  {
    "id": "v5-api-services",
    "title": "Services",
    "content": "Services | feathers\n    \n    \n    â€¢ Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Services â€‹\nServices are the heart of every Feathers application. Services are objects or instances of classes that implement certain methods. Feathers itself will also add some additional methods and functionality to its services.\n## Service methods â€‹\nService methods are pre-defined CRUD and custom methods that your service provides or that have already been implemented by one of the database adapters. Below is an example of a Feathers service as a class or object.ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params, Id, NullableId } from '@feathersjs/feathers'\n\nclass MyServiceClass {\n  async find(params: Params) {\n    return []\n  }\n  async get(id: Id, params: Params) {}\n  async create(data: any, params: Params) {}\n  async update(id: NullableId, data: any, params: Params) {}\n  async patch(id: NullableId, data: any, params: Params) {}\n  async remove(id: NullableId, params: Params) {}\n  async setup(app: Application, path: string) {}\n  async teardown(app: Application, path: string) {}\n}\n\nconst myServiceObject = {\n  async find(params: Params) {\n    return []\n  },\n  async get(id: Id, params: Params) {},\n  async create(data: any, params: Params) {},\n  async update(id: NullableId, data: any, params: Params) {},\n  async patch(id: NullableId, data: any, params: Params) {},\n  async remove(id: NullableId, params: Params) {},\n  async setup(app: Application, path: string) {},\n  async teardown(app: Application, path: string) {}\n}\n\ntype ServiceTypes = {\n  'my-service': MyServiceClass\n  'my-service-object': typeof myServiceObject\n}\n\nconst app = feathers()\n\napp.use('my-service', new MyServiceClass())\napp.use('my-service-object', myServiceObject)\n```\ndangerAlways use the service returned by `app.service(path)` not the service object or class directly or you will not get any of the Feathers service functionalitytipMethods are optional and if a method is not implemented Feathers will automatically emit a `NotImplemented` error. At least one standard service method must be implemented to be considered a service. If you used `methods` option when registering the service via app.use, all methods listed must be available.Service methods must use async/await or return a Promise and have the following parameters:`id` â€” The identifier for the resource. A resource is the data identified by a unique id.\nâ€¢ `data` â€” The resource data.\nâ€¢ `params` - Additional parameters for the method call (see params)\n\nOnce registered, the service can be retrieved and used via app.service():\n\njs\n```\nconst myService = app.service('my-service')\n\nconst items = await myService.find()\n\nconst item = await app.service('my-service').get(1)\n\nconsole.log('.get(1)', item)\n```\n\ninfo\n\nAlthough probably the most common use case, a service does not necessarily have to connect to a database. A custom service can implement any functionality like talking to another API or send an email etc.\n\nImportant\n\nThis section describes the general usage of service methods and how to implement them. They are already implemented by the official Feathers database adapters. For specifics on how to use the database adapters, see the database adapters documentation.\n\n### params â€‹\n\n`params` contain additional information for the service method call. Some properties in `params` can be set by Feathers already. Commonly used are:\nâ€¢ `params.query` - the query parameters from the client, either passed as URL query parameters (see the REST chapter) or through websockets (see Socket.io).\nâ€¢ `params.provider` - The transport (`rest` or `socketio`) used for this service call. Will be `undefined` for internal calls from the server (unless passed explicitly).\nâ€¢ `params.authentication` - The authentication information to use for the authentication service\nâ€¢ `params.user` - The authenticated user, either set by Feathers authentication or passed explicitly.\nâ€¢ `params.connection` - If the service call has been made by a real-time transport (e.g. through websockets), `params.connection` is the connection object that can be used with channels.\nâ€¢ `params.headers` - The HTTP headers connected to this service call if available. This is either the headers of the REST call or the headers passed when initializing a websocket connection.\n\nImportant\n\nFor external calls only `params.query` will be sent between the client and server. This is because other parameters in `params` on the server often contain security critical information (like `params.user` or `params.authentication`).\n\n### .find(params) â€‹\n\n`service.find(params) -> Promise` - Retrieves a list of all resources from the service. `params.query` can be used to filter and limit the returned data.\n\nts\n```\nclass MessageService {\n  async find(params: Params) {\n    return [\n      {\n        id: 1,\n        text: 'Message 1'\n      },\n      {\n        id: 2,\n        text: 'Message 2'\n      }\n    ]\n  }\n}\n\napp.use('messages', new MessageService())\n",
    "version": "v5",
    "tokens": [
      "services",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "are",
      "the",
      "heart",
      "every",
      "application",
      "objects",
      "instances",
      "classes",
      "that",
      "implement",
      "certain",
      "methods",
      "itself",
      "will",
      "also",
      "add",
      "some",
      "additional",
      "and",
      "functionality",
      "its",
      "service",
      "pre",
      "defined",
      "crud",
      "custom",
      "your",
      "provides",
      "have",
      "already",
      "been",
      "implemented",
      "one",
      "database",
      "adapters",
      "below",
      "example",
      "class",
      "object",
      "import",
      "from",
      "feathersjs",
      "type",
      "params",
      "nullableid",
      "myserviceclass",
      "async",
      "find",
      "return",
      "get",
      "create",
      "data",
      "any",
      "update",
      "patch",
      "remove",
      "setup",
      "app",
      "path",
      "string",
      "teardown",
      "const",
      "myserviceobject",
      "servicetypes",
      "typeof",
      "use",
      "new",
      "dangeralways",
      "returned",
      "not",
      "directly",
      "you",
      "functionalitytipmethods",
      "optional",
      "method"
    ],
    "category": "services"
  },
  {
    "id": "v4-api-services",
    "title": "Services",
    "content": "# Services \"Services\" are the heart of every Feathers application. Services are JavaScript objects (or instances of ES6 classes (opens new window) ) that implement certain methods . Feathers itself will also add some additional methods and functionality to its services. # Service methods Service methods are pre-defined CRUD (opens new window) methods that your service object can implement (or that have already been implemented by one of the database adapters ). Below is an example of a Feathers service using async/await (opens new window) as a JavaScript object and a JavaScript or Typescript class (opens new window) : const myService = { async find ( params ) { return [ ] ; } , async get ( id , params ) { } , async create ( data , params ) { } , async update ( id , data , params ) { } , async patch ( id , data , params ) { } , async remove ( id , params ) { } , setup ( app , path ) { } } app . use ( '/my-service' , myService ) ;",
    "version": "v4",
    "tokens": [
      "services",
      "are",
      "the",
      "heart",
      "every",
      "feathers",
      "application",
      "javascript",
      "objects",
      "instances",
      "classes",
      "opens",
      "new",
      "window",
      "that",
      "implement",
      "certain",
      "methods",
      "itself",
      "will",
      "also",
      "add",
      "some",
      "additional",
      "and",
      "functionality",
      "its",
      "service",
      "pre",
      "defined",
      "crud",
      "your",
      "object",
      "can",
      "have",
      "already",
      "been",
      "implemented",
      "one",
      "database",
      "adapters",
      "below",
      "example",
      "using",
      "async",
      "await",
      "typescript",
      "class",
      "const",
      "myservice",
      "find",
      "params",
      "return",
      "get",
      "create",
      "data",
      "update",
      "patch",
      "remove",
      "setup",
      "app",
      "path",
      "use"
    ],
    "category": "services"
  },
  {
    "id": "v4-guides-basics-services",
    "title": "Services",
    "content": "# Services Services are the heart of every Feathers application. You probably remember the service we created in the getting started chapter to create and find messages. In this chapter we will dive more into services and update the existing user service in our chat application to include an avatar image. # Feathers services In general, a service is an object or instance of a class (opens new window) that implements certain methods. Services provide a uniform, protocol independent interface for how to interact with any kind of data like: Reading and/or writing from a database Interacting with the file system Call another API Call other services like Sending an email Processing a payment Returning the current weather for a location, etc. Protocol independent means that to a Feathers service it does not matter if it has been called through a REST API, websockets, internally in our application or any other way. # Service methods Service methods are CRUD (opens new window) methods that a service can implement. Feathers service methods are: find - Find all data (potentially matching a query) get - Get a single data entry by its unique identifier create - Create new data update - Update an existing data entry by completely replacing it patch - Update one or more data entries by merging with the new data remove - Remove one or more existing data entries Below is an example of Feathers service interface as a class and a normal object: class MyService { async find ( params ) { } async get ( id , params ) { } async create ( data , params ) { } async update ( id , data , params ) { } async patch ( id , data , params ) { } async remove ( id , params ) { } } app . use ( '/my-service' , new MyService ( ) ) ;",
    "version": "v4",
    "tokens": [
      "services",
      "are",
      "the",
      "heart",
      "every",
      "feathers",
      "application",
      "you",
      "probably",
      "remember",
      "service",
      "created",
      "getting",
      "started",
      "chapter",
      "create",
      "and",
      "find",
      "messages",
      "this",
      "will",
      "dive",
      "more",
      "into",
      "update",
      "existing",
      "user",
      "our",
      "chat",
      "include",
      "avatar",
      "image",
      "general",
      "object",
      "instance",
      "class",
      "opens",
      "new",
      "window",
      "that",
      "implements",
      "certain",
      "methods",
      "provide",
      "uniform",
      "protocol",
      "independent",
      "interface",
      "for",
      "how",
      "interact",
      "with",
      "any",
      "kind",
      "data",
      "like",
      "reading",
      "writing",
      "from",
      "database",
      "interacting",
      "file",
      "system",
      "call",
      "another",
      "api",
      "other",
      "sending",
      "email",
      "processing",
      "payment",
      "returning",
      "current",
      "weather",
      "location",
      "etc",
      "means",
      "does",
      "not",
      "matter",
      "has",
      "been",
      "called",
      "through",
      "rest",
      "websockets",
      "internally",
      "way",
      "crud"
    ],
    "category": "services"
  },
  {
    "id": "v4-api-client-rest",
    "title": "REST Client",
    "content": "# REST Client # @feathersjs/rest-client (opens new window) (opens new window) npm install @feathersjs/rest-client --save",
    "version": "v4",
    "tokens": [
      "rest",
      "client",
      "feathersjs",
      "opens",
      "new",
      "window",
      "npm",
      "install",
      "save"
    ],
    "category": "services"
  },
  {
    "id": "v4-api-client-socketio",
    "title": "Socket.io Client",
    "content": "# Socket.io Client # @feathersjs/socketio-client (opens new window) (opens new window) npm install @feathersjs/socketio-client --save",
    "version": "v4",
    "tokens": [
      "socket",
      "client",
      "feathersjs",
      "socketio",
      "opens",
      "new",
      "window",
      "npm",
      "install",
      "save"
    ],
    "category": "services"
  },
  {
    "id": "v4-api-client-primus",
    "title": "Primus Client",
    "content": "# Primus Client Note: We recommend using Feathers and the @feathersjs/primus-client module on the client if possible. To use a direct Primus connection without using Feathers on the client however see the Direct connection section. # Loading the Primus client library In the browser the Primus client library (usually at primus/primus.js ) always has to be loaded using a <script> tag: < script type = \" text/javascript \" src = \" primus/primus.js \" > </ script >",
    "version": "v4",
    "tokens": [
      "primus",
      "client",
      "note",
      "recommend",
      "using",
      "feathers",
      "and",
      "the",
      "feathersjs",
      "module",
      "possible",
      "use",
      "direct",
      "connection",
      "without",
      "however",
      "see",
      "section",
      "loading",
      "library",
      "browser",
      "usually",
      "always",
      "has",
      "loaded",
      "script",
      "tag",
      "type",
      "text",
      "javascript",
      "src"
    ],
    "category": "services"
  }
]
