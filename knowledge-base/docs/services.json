[
  {
    "id": "v5-services",
    "title": "Services",
    "content": "---\noutline: deep\n---\n\n# Services\n\nServices are the heart of every Feathers application. Services are objects or instances of [classes](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes) that implement [certain methods](#service-methods). Feathers itself will also add some [additional methods and functionality](#feathers-functionality) to its services.\n\n## Service methods\n\nService methods are pre-defined [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) and [custom methods](#custom-methods) that your service provides or that have already been implemented by one of the [database adapters](./databases/common.md). Below is an example of a Feathers service as a class or object.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params, Id, NullableId } from '@feathersjs/feathers'\n\nclass MyServiceClass {\n  async find(params: Params) {\n    return []\n  }\n  async get(id: Id, params: Params) {}\n  async create(data: any, params: Params) {}\n  async update(id: NullableId, data: any, params: Params) {}\n  async patch(id: NullableId, data: any, params: Params) {}\n  async remove(id: NullableId, params: Params) {}\n  async setup(app: Application, path: string) {}\n  async teardown(app: Application, path: string) {}\n}\n\nconst myServiceObject = {\n  async find(params: Params) {\n    return []\n  },\n  async get(id: Id, params: Params) {},\n  async create(data: any, params: Params) {},\n  async update(id: NullableId, data: any, params: Params) {},\n  async patch(id: NullableId, data: any, params: Params) {},\n  async remove(id: NullableId, params: Params) {},\n  async setup(app: Application, path: string) {},\n  async teardown(app: Application, path: string) {}\n}\n\ntype ServiceTypes = {\n  'my-service': MyServiceClass\n  'my-service-object': typeof myServiceObject\n}\n\nconst app = feathers<ServiceTypes>()\n\napp.use('my-service', new MyServiceClass())\napp.use('my-service-object', myServiceObject)\n```\n\n<BlockQuote type=\"danger\">\n\nAlways use the service returned by `app.service(path)` not the service object or class directly or you will not get any of the [Feathers service functionality](services.md#feathers-functionality)\n\n</BlockQuote>\n\n<BlockQuote type=\"tip\">\n\nMethods are optional and if a method is not implemented Feathers will automatically emit a `NotImplemented` error. At least one standard service method must be implemented to be considered a service. If you used `methods` option when registering the service via [app.use](./application.md#usepath-service--options), all methods listed must be available.\n\n</BlockQuote>\n\nService methods must use [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) or return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) and have the following parameters:\n\n- `id` — The identifier for the resource. A resource is the data identified by a unique id.\n- `data` — The resource data.\n- `params",
    "version": "v5",
    "tokens": [
      "services",
      "---",
      "outline",
      "deep",
      "---",
      "services",
      "services",
      "are",
      "the",
      "heart",
      "every",
      "feathers",
      "application",
      "services",
      "are",
      "objects",
      "instances",
      "classes",
      "https",
      "developer",
      "mozilla",
      "org",
      "docs",
      "web",
      "javascript",
      "reference",
      "classes",
      "that",
      "implement",
      "certain",
      "methods",
      "service-methods",
      "feathers",
      "itself",
      "will",
      "also",
      "add",
      "some",
      "additional",
      "methods",
      "and",
      "functionality",
      "feathers-functionality",
      "its",
      "services",
      "service",
      "methods",
      "service",
      "methods",
      "are",
      "pre-defined",
      "crud",
      "https",
      "wikipedia",
      "org",
      "wiki",
      "create",
      "_read",
      "_update_and_delete",
      "and",
      "custom",
      "methods",
      "custom-methods",
      "that",
      "your",
      "service",
      "provides",
      "that",
      "have",
      "already",
      "been",
      "implemented",
      "one",
      "the",
      "database",
      "adapters",
      "databases",
      "common",
      "below",
      "example",
      "feathers",
      "service",
      "class",
      "object",
      "import",
      "feathers",
      "from",
      "feathersjs",
      "feathers",
      "import",
      "type",
      "params",
      "nullableid",
      "from",
      "feathersjs",
      "feathers",
      "class",
      "myserviceclass",
      "async",
      "find",
      "params",
      "params",
      "return",
      "async",
      "get",
      "params",
      "params",
      "async",
      "create",
      "data",
      "any",
      "params",
      "params"
    ],
    "category": "services"
  },
  {
    "id": "v5-hooks",
    "title": "Hooks",
    "content": "---\noutline: deep\n---\n\n# Hooks\n\nHooks are pluggable middleware functions that can be registered **around**, **before**, **after** or on **error**(s) of a [service method](./services.md). Multiple hook functions can be chained to create complex work-flows. A hook is **transport independent**, which means it does not matter if it has been called internally on the server, through HTTP(S) (REST), websockets or any other transport Feathers supports. They are also service agnostic, meaning they can be used with ​**any**​ service regardless of whether they use a database or not.\n\nHooks are commonly used to handle things like permissions, validation, logging, [authentication](./authentication/hook.md), [data schemas and resolvers](./schema/index.md), sending notifications and more. This pattern keeps your application logic flexible, composable, and easier to trace through and debug. For more information about the design patterns behind hooks see [this blog post](https://blog.feathersjs.com/api-service-composition-with-hooks-47af13aa6c01).\n\n## Quick Example\n\nThe following example logs the runtime of any service method on the `messages` service and adds `createdAt` property before saving the data to the database:\n\n```ts\nimport { feathers, type HookContext, type NextFunction } from '@feathersjs/feathers'\n\nconst app = feathers()\n\napp.service('messages').hooks({\n  around: {\n    all: [\n      // A hook that wraps around all other hooks and the service method\n      // logging the total runtime of a successful call\n      async (context: HookContext, next: NextFunction) => {\n        const startTime = Date.now()\n\n        await next()\n\n        console.log(`Method ${context.method} on ${context.path} took ${Date.now() - startTime}ms`)\n      }\n    ]\n  },\n  before: {\n    create: [\n      async (context: HookContext) => {\n        context.data = {\n          ...context.data,\n          createdAt: Date.now()\n        }\n      }\n    ]\n  }\n})\n```\n\n<BlockQuote type=\"info\">\n\nWhile it is always possible to add properties like `createdAt` in the above example via hooks, the preferred way to make data modifications like this in Feathers 5 is via [schemas and resolvers](./schema/index.md).\n\n</BlockQuote>\n\n## Hook functions\n\n### before, after and error\n\n`before`, `after` and `error` hook functions are functions that are `async` or return a promise and take the [hook context](#hook-context) as the parameter and return nothing or throw an error.\n\n```ts\nimport { HookContext } from '../declarations'\n\nexport const hookFunction = async (context: HookContext) => {\n  // Do things here\n}\n```\n\nFor more information see the [hook flow](#hook-flow) section.\n\n### around\n\n`around` hooks are a special kind of hook that allow to control the entire `before`, `after` and `error` flow in a single function. They are a Feathers specific version of the generic [@feathersjs/hooks](https://github.com/feathersjs/hooks). An `around` hook is an `async` function that accepts two arguments:\n\n- The [hook context](#h",
    "version": "v5",
    "tokens": [
      "hooks",
      "---",
      "outline",
      "deep",
      "---",
      "hooks",
      "hooks",
      "are",
      "pluggable",
      "middleware",
      "functions",
      "that",
      "can",
      "registered",
      "around",
      "before",
      "after",
      "error",
      "service",
      "method",
      "services",
      "multiple",
      "hook",
      "functions",
      "can",
      "chained",
      "create",
      "complex",
      "work-flows",
      "hook",
      "transport",
      "independent",
      "which",
      "means",
      "does",
      "not",
      "matter",
      "has",
      "been",
      "called",
      "internally",
      "the",
      "server",
      "through",
      "http",
      "rest",
      "websockets",
      "any",
      "other",
      "transport",
      "feathers",
      "supports",
      "they",
      "are",
      "also",
      "service",
      "agnostic",
      "meaning",
      "they",
      "can",
      "used",
      "with",
      "any",
      "service",
      "regardless",
      "whether",
      "they",
      "use",
      "database",
      "not",
      "hooks",
      "are",
      "commonly",
      "used",
      "handle",
      "things",
      "like",
      "permissions",
      "validation",
      "logging",
      "authentication",
      "authentication",
      "hook",
      "data",
      "schemas",
      "and",
      "resolvers",
      "schema",
      "index",
      "sending",
      "notifications",
      "and",
      "more",
      "this",
      "pattern",
      "keeps",
      "your",
      "application",
      "logic",
      "flexible",
      "composable",
      "and",
      "easier",
      "trace",
      "through",
      "and",
      "debug",
      "for",
      "more",
      "information",
      "about",
      "the",
      "design",
      "patterns",
      "behind",
      "hooks",
      "see",
      "this",
      "blog",
      "post",
      "https",
      "blog",
      "feathersjs",
      "com",
      "api"
    ],
    "category": "hooks"
  },
  {
    "id": "v5-application",
    "title": "Application",
    "content": "---\noutline: deep\n---\n\n# Application\n\n<Badges>\n\n[![npm version](https://img.shields.io/npm/v/@feathersjs/authentication-client.svg?style=flat-square)](https://www.npmjs.com/package/@feathersjs/feathers)\n[![Changelog](https://img.shields.io/badge/changelog-.md-blue.svg?style=flat-square)](https://github.com/feathersjs/feathers/blob/dove/packages/feathers/CHANGELOG.md)\n\n</Badges>\n\n```\nnpm install @feathersjs/feathers --save\n```\n\nThe core `@feathersjs/feathers` module provides the ability to initialize a new Feathers application instance. It works in Node, React Native and the browser (see the [client](./client.md) chapter for more information). Each instance allows for registration and retrieval of [services](./services.md), [hooks](./hooks.md), plugin configuration, and getting and setting configuration options. An initialized Feathers application is referred to as the **app object**.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\n\ntype ServiceTypes = {\n  // Add registered services here\n}\n\n// Types for `app.set(name, value)` and `app.get(name)`\ntype Configuration = {\n  port: number\n}\n\nconst app = feathers<ServiceTypes, Configuration>()\n```\n\n## .use(path, service [, options])\n\n`app.use(path, service [, options]) -> app` allows registering a [service object](./services.md) on a given `path`.\n\n```ts\nimport { feathers, type Id } from '@feathersjs/feathers'\n\nclass MessageService {\n  async get(id: Id) {\n    return {\n      id,\n      text: `This is the ${id} message!`\n    }\n  }\n}\n\ntype ServiceTypes = {\n  // Add services path to type mapping here\n  messages: MessageService\n}\n\nconst app = feathers<ServiceTypes>()\n\n// Register a service instance on the app\napp.use('messages', new MessageService())\n\n// Get the service and call the service method with the correct types\nconst message = await app.service('messages').get('test')\n```\n\n### path\n\nThe `path` is a string that should be URL friendly and may contain `/` as a separator. `path` can also be `/` to register a service at the root level. A path may contain placeholders in the form of `:userId/messages` which will be included in `params.route` by a transport.\n\n### options\n\nThe following options are available:\n\n- `methods` (default: `['find', 'get', 'create', 'patch', 'update','remove']`) - A list of official and [custom service methods](services.md#custom-methods) that should be available to clients. When using this option **all** method names that should be available externally must be passed. Those methods will automatically be available for use with [hooks](./hooks).\n- `events` - A list of [public custom events sent by this service](./events.md#custom-events)\n\n```ts\nimport { EventEmitter } from 'events'\nimport { feathers, type Id } from '@feathersjs/feathers'\n\n// Feathers services will always be event emitters\n// but we can also extend it for better type consistency\nclass MessageService extends EventEmitter {\n  async doSomething(data: { message: string }, params: Params) {\n    this.emit('something',",
    "version": "v5",
    "tokens": [
      "application",
      "---",
      "outline",
      "deep",
      "---",
      "application",
      "badges",
      "npm",
      "version",
      "https",
      "img",
      "shields",
      "npm",
      "feathersjs",
      "authentication-client",
      "svg",
      "style",
      "flat-square",
      "https",
      "www",
      "npmjs",
      "com",
      "package",
      "feathersjs",
      "feathers",
      "changelog",
      "https",
      "img",
      "shields",
      "badge",
      "changelog-",
      "md-blue",
      "svg",
      "style",
      "flat-square",
      "https",
      "github",
      "com",
      "feathersjs",
      "feathers",
      "blob",
      "dove",
      "packages",
      "feathers",
      "changelog",
      "badges",
      "npm",
      "install",
      "feathersjs",
      "feathers",
      "--save",
      "the",
      "core",
      "feathersjs",
      "feathers",
      "module",
      "provides",
      "the",
      "ability",
      "initialize",
      "new",
      "feathers",
      "application",
      "instance",
      "works",
      "node",
      "react",
      "native",
      "and",
      "the",
      "browser",
      "see",
      "the",
      "client",
      "client",
      "chapter",
      "for",
      "more",
      "information",
      "each",
      "instance",
      "allows",
      "for",
      "registration",
      "and",
      "retrieval",
      "services",
      "services",
      "hooks",
      "hooks",
      "plugin",
      "configuration",
      "and",
      "getting",
      "and",
      "setting",
      "configuration",
      "options",
      "initialized",
      "feathers",
      "application",
      "referred",
      "the",
      "app",
      "object",
      "import",
      "feathers",
      "from",
      "feathersjs",
      "feathers",
      "type",
      "servicetypes",
      "add",
      "registered",
      "servi"
    ],
    "category": "application"
  },
  {
    "id": "v5-events",
    "title": "Events",
    "content": "---\noutline: deep\n---\n\n# Events\n\nEvents are the key part of Feathers real-time functionality. All events in Feathers are provided through the [NodeJS EventEmitter](https://nodejs.org/api/events.html) interface. This section describes\n\n- A quick overview of the [NodeJS EventEmitter interface](#eventemitters)\n- The standard [service events](#service-events)\n- How to allow sending [custom events](#custom-events) from the server to the client\n\n<BlockQuote type=\"warning\" label=\"Important\">\n\nFor more information on how to safely send real-time events to clients, see the [Channels chapter](./channels.md).\n\n</BlockQuote>\n\n## EventEmitters\n\nOnce registered, any [service](./services.md) gets turned into a standard [NodeJS EventEmitter](https://nodejs.org/api/events.html) and can be used accordingly.\n\n```ts\nconst messages = app.service('messages')\n\n// Listen to a normal service event\nmessages.on('patched', (message: Message) => console.log('message patched', message))\n\n// Only listen to an event once\nmesssages.once('removed', (message: Message) => console.log('First time a message has been removed', message))\n\n// A reference to a handler\nconst onCreatedListener = (message: Message) => console.log('New message created', message)\n\n// Listen `created` with a handler reference\nmessages.on('created', onCreatedListener)\n\n// Unbind the `created` event listener\nmessages.removeListener('created', onCreatedListener)\n\n// Send a custom event\nmessages.emit('customEvent', {\n  anything: 'Data can be anything'\n})\n```\n\n## Service Events\n\nAny service automatically emits `created`, `updated`, `patched` and `removed` events when the respective service method returns successfully. This works on the client as well as on the server. Events are not fired until all [hooks](./hooks.md) have executed. When the client is using [Socket.io](socketio.md), events will be pushed automatically from the server to all connected clients. This is how Feathers does real-time.\n\n<BlockQuote type=\"tip\">\n\nTo disable sending of events e.g. when updating a large amount of data, set [context.event](./hooks.md#context-event) to `null` in a hook.\n\n</BlockQuote>\n\nAdditionally to the event `data`, all events also get the [hook context](./hooks.md) from their method call passed as the second parameter.\n\n### created\n\nThe `created` event will fire with the result data when a service `create` returns successfully.\n\n```ts\nimport { feathers, type Params, type HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async create(data: Message) {\n    return data\n  }\n}\n\nconst app = feathers<{ messages: MessageService }>()\n\napp.use('messages', new MessageService())\n\n// Retrieve the wrapped service object which is also an EventEmitter\nconst messages = app.service('messages')\n\nmessages.on('created', (message: Message, contexHookContext) => console.log('created', message))\n\nmessages.create({\n  text: 'We have to do something!'\n})\n```\n\n### updated, patched\n\nThe `updated` and `p",
    "version": "v5",
    "tokens": [
      "events",
      "---",
      "outline",
      "deep",
      "---",
      "events",
      "events",
      "are",
      "the",
      "key",
      "part",
      "feathers",
      "real-time",
      "functionality",
      "all",
      "events",
      "feathers",
      "are",
      "provided",
      "through",
      "the",
      "nodejs",
      "eventemitter",
      "https",
      "nodejs",
      "org",
      "api",
      "events",
      "html",
      "interface",
      "this",
      "section",
      "describes",
      "quick",
      "overview",
      "the",
      "nodejs",
      "eventemitter",
      "interface",
      "eventemitters",
      "the",
      "standard",
      "service",
      "events",
      "service-events",
      "how",
      "allow",
      "sending",
      "custom",
      "events",
      "custom-events",
      "from",
      "the",
      "server",
      "the",
      "client",
      "blockquote",
      "type",
      "warning",
      "label",
      "important",
      "for",
      "more",
      "information",
      "how",
      "safely",
      "send",
      "real-time",
      "events",
      "clients",
      "see",
      "the",
      "channels",
      "chapter",
      "channels",
      "blockquote",
      "eventemitters",
      "once",
      "registered",
      "any",
      "service",
      "services",
      "gets",
      "turned",
      "into",
      "standard",
      "nodejs",
      "eventemitter",
      "https",
      "nodejs",
      "org",
      "api",
      "events",
      "html",
      "and",
      "can",
      "used",
      "accordingly",
      "const",
      "messages",
      "app",
      "service",
      "messages",
      "listen",
      "normal",
      "service",
      "event",
      "messages",
      "patched",
      "message",
      "message",
      "console",
      "log",
      "message",
      "patched",
      "message",
      "only",
      "listen",
      "event"
    ],
    "category": "events"
  },
  {
    "id": "v5-channels",
    "title": "Channels",
    "content": "---\noutline: deep\n---\n\n# Channels\n\nOn a Feathers server with a real-time transport (like [Socket.io](./socketio.md)) configured, event channels determine which connected clients to send [real-time events](./events.md) to and how the sent data should look.\n\nThis chapter describes:\n\n- [Concepts](#concepts) of real-time communication\n- [An example](#example) channels.js file\n- [Real-time Connections](#connections) and how to access them\n- [Channel usage](#channels) and how to retrieve, join and leave channels\n- [Publishing events](#publishing) to channels\n\n<BlockQuote label=\"Important\">\n\nChannels functionality will not be available in the following two scenarios:\n\n- When you're making a rest-only API, not using a real-time adapter.\n- When you're using Feathers on the client. Only server-side Feathers has channel management.\n\n</BlockQuote>\n\nHere are some example logic conditions where channels are useful:\n\n- Real-time events should only be sent to authenticated users\n- Users should only get updates about messages from chat rooms they joined\n- Only users in the same organization should receive real-time updates about their data changes\n- Only admins should be notified when new users are created\n- When a user is created, modified or removed, non-admins should only receive a \"safe\" version of the user object (e.g. only `email`, `id` and `avatar`)\n\n## Concepts\n\nA **_channel_** is basically an array of **_connection_** objects. Each array is explicitly given a name. When using a real-time server transport and a new client connects, you can tell the server to explicitly add that client's connection object to any relevant channels. Any connection in a channel will receive all events that are sent to that channel. This allows clients to receive only their intended messages.\n\nWhen using a real-time transport, the server pushes events (such as \"created\", \"removed\" etc. for a particular service) down to its clients. Using channels allows customizing which clients should receive each event. The client doesn’t subscribe to individual channels, directly, but rather subscribes to specific events like `created`, `patched`, custom events, etc, in which they are interested. Those events will only fire for a client if the server pushes data to one a channel to which the client has been added.\n\nYou can have any number of channels. This helps to organise how data is sent and to control the volume of data, by not sending things that aren't relevant.\n\nThe server can also change connection channel membership from time to time, eg. before vs after login.\n\nThe server needs to explicitly **publish** channels it is interested in sharing with clients before they become available.\n\n## Example\n\nThe example below shows a `channels.js` file illustrating how the different parts fit together:\n\n```ts\nimport type { RealTimeConnection, Params } from '@feathersjs/feathers'\nimport type { Application, HookContext } from './declarations'\n\nexport default function (app: any) {\n  if (typeof app",
    "version": "v5",
    "tokens": [
      "channels",
      "---",
      "outline",
      "deep",
      "---",
      "channels",
      "feathers",
      "server",
      "with",
      "real-time",
      "transport",
      "like",
      "socket",
      "socketio",
      "configured",
      "event",
      "channels",
      "determine",
      "which",
      "connected",
      "clients",
      "send",
      "real-time",
      "events",
      "events",
      "and",
      "how",
      "the",
      "sent",
      "data",
      "should",
      "look",
      "this",
      "chapter",
      "describes",
      "concepts",
      "concepts",
      "real-time",
      "communication",
      "example",
      "example",
      "channels",
      "file",
      "real-time",
      "connections",
      "connections",
      "and",
      "how",
      "access",
      "them",
      "channel",
      "usage",
      "channels",
      "and",
      "how",
      "retrieve",
      "join",
      "and",
      "leave",
      "channels",
      "publishing",
      "events",
      "publishing",
      "channels",
      "blockquote",
      "label",
      "important",
      "channels",
      "functionality",
      "will",
      "not",
      "available",
      "the",
      "following",
      "two",
      "scenarios",
      "when",
      "you",
      "making",
      "rest-only",
      "api",
      "not",
      "using",
      "real-time",
      "adapter",
      "when",
      "you",
      "using",
      "feathers",
      "the",
      "client",
      "only",
      "server-side",
      "feathers",
      "has",
      "channel",
      "management",
      "blockquote",
      "here",
      "are",
      "some",
      "example",
      "logic",
      "conditions",
      "where",
      "channels",
      "are",
      "useful",
      "real-time",
      "events",
      "should",
      "only",
      "sent",
      "authenticated",
      "users",
      "users",
      "should",
      "only"
    ],
    "category": "channels"
  },
  {
    "id": "v5-configuration",
    "title": "Configuration",
    "content": "---\noutline: deep\n---\n\n# Configuration\n\n<Badges>\n\n[![npm version](https://img.shields.io/npm/v/@feathersjs/configuration.svg?style=flat-square)](https://www.npmjs.com/package/@feathersjs/configuration)\n[![Changelog](https://img.shields.io/badge/changelog-.md-blue.svg?style=flat-square)](https://github.com/feathersjs/feathers/blob/dove/packages/configuration/CHANGELOG.md)\n\n</Badges>\n\n```\nnpm install @feathersjs/configuration --save\n```\n\n`@feathersjs/configuration` is a wrapper for [node-config](https://github.com/lorenwest/node-config) to make configuration values available via [app.get](./application.md#get-name) which can then be used to configure an application.\n\nBy default it will look in `config/*` for `default.json`. It will be merged with other configuration files in the `config/` folder using the `NODE_ENV` environment variable. So setting `NODE_ENV=production` will merge `config/default.json` with `config/production.json`.\n\nFor more information also see the [node-config docs](https://github.com/lorenwest/node-config/wiki/Configuration-Files).\n\n## Usage\n\n`app.configure(configuration())` loads the configuration from `node-config` and makes it available via `app.get()`.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport configuration from '@feathersjs/configuration'\n\n// Use the application root and `config/` as the configuration folder\nconst app = feathers().configure(configuration())\n\n// Will return 3030 with  `{ \"port\": 3030 }` in config/default.json\napp.get('port')\n```\n\n<BlockQuote type=\"warning\" label=\"Important\">\n\nDirect access to nested config properties is not supported via `app.get()`. To access a nested config property (e.g. `Customer.dbConfig.host`, use `app.get('Customer').dbConfig.host`.\n\n</BlockQuote>\n\n## Configuration validation\n\n`app.configure(configuration(validator))` loads the configuration from `node-config`, makes it available via `app.get()` and validates the original configuration against a [Feathers schema](./schema/) validator when [app.setup](./application.md#setup-server) (or [app.listen](./application.md#listen-port)) is called.\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport { Ajv } from '@feathersjs/schema'\nimport { Type, getValidator } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\nimport configuration from '@feathersjs/configuration'\n\nconst configurationSchema = Type.Object(\n  {\n    port: Type.Number(),\n    host: Type.String()\n  },\n  { $id: 'Configuration', additionalProperties: false }\n)\n\nconst configurationValidator = getValidator(configurationSchema, new Ajv())\n\ntype ServiceTypes = {}\n// Use the schema type for typed `app.get` and `app.set` calls\ntype Configuration = Static<typeof configurationSchema>\n\n// Use the application root and `config/` as the configuration folder\nconst app = feathers<ServiceTypes, Configuration>().configure(configuration(configurationValidator))\n\n// Configuration will only be validated now\napp\n  .listen()\n  .then(() => console.lo",
    "version": "v5",
    "tokens": [
      "configuration",
      "---",
      "outline",
      "deep",
      "---",
      "configuration",
      "badges",
      "npm",
      "version",
      "https",
      "img",
      "shields",
      "npm",
      "feathersjs",
      "configuration",
      "svg",
      "style",
      "flat-square",
      "https",
      "www",
      "npmjs",
      "com",
      "package",
      "feathersjs",
      "configuration",
      "changelog",
      "https",
      "img",
      "shields",
      "badge",
      "changelog-",
      "md-blue",
      "svg",
      "style",
      "flat-square",
      "https",
      "github",
      "com",
      "feathersjs",
      "feathers",
      "blob",
      "dove",
      "packages",
      "configuration",
      "changelog",
      "badges",
      "npm",
      "install",
      "feathersjs",
      "configuration",
      "--save",
      "feathersjs",
      "configuration",
      "wrapper",
      "for",
      "node-config",
      "https",
      "github",
      "com",
      "lorenwest",
      "node-config",
      "make",
      "configuration",
      "values",
      "available",
      "via",
      "app",
      "get",
      "application",
      "get-name",
      "which",
      "can",
      "then",
      "used",
      "configure",
      "application",
      "default",
      "will",
      "look",
      "config",
      "for",
      "default",
      "json",
      "will",
      "merged",
      "with",
      "other",
      "configuration",
      "files",
      "the",
      "config",
      "folder",
      "using",
      "the",
      "node_env",
      "environment",
      "variable",
      "setting",
      "node_env",
      "production",
      "will",
      "merge",
      "config",
      "default",
      "json",
      "with",
      "config",
      "production",
      "json",
      "for",
      "more",
      "information",
      "also",
      "see",
      "the",
      "node-config",
      "docs"
    ],
    "category": "configuration"
  },
  {
    "id": "v5-express",
    "title": "Express",
    "content": "---\noutline: deep\n---\n\n# Express\n\n<Badges>\n\n[![npm version](https://img.shields.io/npm/v/@feathersjs/express.svg?style=flat-square)](https://www.npmjs.com/package/@feathersjs/express)\n[![Changelog](https://img.shields.io/badge/changelog-.md-blue.svg?style=flat-square)](https://github.com/feathersjs/feathers/blob/dove/packages/express/CHANGELOG.md)\n\n</Badges>\n\n```\nnpm install @feathersjs/express --save\n```\n\nThe `@feathersjs/express` module contains [Express](http://expressjs.com/) framework integrations for Feathers:\n\n- The [Express framework bindings](#expressapp) to make a Feathers application Express compatible\n- An Express based transport to expose services through a [REST API](#expressrest)\n- An [Express error handler](#expresserrorhandler) for [Feathers errors](./errors.md)\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport express from '@feathersjs/express'\n\nconst app = express(feathers())\n```\n\n<BlockQuote type=\"warning\" label=\"Important\">\n\nAs of Feathers v5, [Koa](./koa.md) is the recommended framework integration since it is more modern, faster and easier to use. When chosen explicitly, you should already be familiar with [Express](http://expressjs.com/en/guide/routing.html).\n\n</BlockQuote>\n\n## express(app)\n\n`express(app) -> app` is a function that turns a [Feathers application](./application.md) into a fully Express (4+) compatible application that additionally to Feathers functionality also lets you use the [Express API](http://expressjs.com/en/4x/api.html).\n\n```ts\nimport { feathers } from '@feathersjs/feathers'\nimport express from '@feathersjs/express'\n\nconst app = express(feathers())\n```\n\nNote that `@feathersjs/express` also exposes the Express [built-in middleware](#built-ins)\n\n## express(app, expressApp)\n\n`express(app, expressApp) -> app` allows to extend an existing Express application with the Feathers application `app`.\n\n## express()\n\nIf no Feathers application is passed, `express() -> app` returns a plain Express application just like a normal call to Express would.\n\n## app.use(path, service|mw|\\[mw\\])\n\n`app.use(path, service|mw|[mw]) -> app` registers either a [service object](./services.md), an [Express middleware](http://expressjs.com/en/guide/writing-middleware.html) or an array of [Express middleware](http://expressjs.com/en/guide/writing-middleware.html) on the given path. If [a service object](./services.md) is passed it will use Feathers registration mechanism, for a middleware function Express.\n\n```ts\n// Register a service\napp.use('todos', {\n  async get(id) {\n    return { id }\n  }\n})\n\n// Register an Express middleware\napp.use('/test', (req, res) => {\n  res.json({\n    message: 'Hello world from Express middleware'\n  })\n})\n\n// Register multiple Express middleware functions\napp.use(\n  '/test',\n  (req, res, next) => {\n    res.data = 'Step 1 worked'\n    next()\n  },\n  (req, res) => {\n    res.json({\n      message: `Hello world from Express middleware ${res.data}`\n    })\n  }\n)\n```\n\n## app.listen(port)\n\n`app.listen(po",
    "version": "v5",
    "tokens": [
      "express",
      "---",
      "outline",
      "deep",
      "---",
      "express",
      "badges",
      "npm",
      "version",
      "https",
      "img",
      "shields",
      "npm",
      "feathersjs",
      "express",
      "svg",
      "style",
      "flat-square",
      "https",
      "www",
      "npmjs",
      "com",
      "package",
      "feathersjs",
      "express",
      "changelog",
      "https",
      "img",
      "shields",
      "badge",
      "changelog-",
      "md-blue",
      "svg",
      "style",
      "flat-square",
      "https",
      "github",
      "com",
      "feathersjs",
      "feathers",
      "blob",
      "dove",
      "packages",
      "express",
      "changelog",
      "badges",
      "npm",
      "install",
      "feathersjs",
      "express",
      "--save",
      "the",
      "feathersjs",
      "express",
      "module",
      "contains",
      "express",
      "http",
      "expressjs",
      "com",
      "framework",
      "integrations",
      "for",
      "feathers",
      "the",
      "express",
      "framework",
      "bindings",
      "expressapp",
      "make",
      "feathers",
      "application",
      "express",
      "compatible",
      "express",
      "based",
      "transport",
      "expose",
      "services",
      "through",
      "rest",
      "api",
      "expressrest",
      "express",
      "error",
      "handler",
      "expresserrorhandler",
      "for",
      "feathers",
      "errors",
      "errors",
      "import",
      "feathers",
      "from",
      "feathersjs",
      "feathers",
      "import",
      "express",
      "from",
      "feathersjs",
      "express",
      "const",
      "app",
      "express",
      "feathers",
      "blockquote",
      "type",
      "warning",
      "label",
      "important",
      "feathers",
      "koa"
    ],
    "category": "express"
  },
  {
    "id": "v5-client",
    "title": "Feathers Client",
    "content": "---\noutline: deep\n---\n\n# Feathers Client\n\nOne of the most notable features of Feathers is that it can also be used as the client. In contrast with most other frameworks, it isn't a separate library; instead you get the exact same functionality with a client and on a server. This means you can use [services](./services.md) and [hooks](./hooks.md) and configure plugins. By default, a Feathers client automatically creates services that talk to a Feathers server.\n\nIn order to connect to a Feathers server, a client creates [Services](./services.md) that use a REST or websocket connection to relay method calls and - for a real-time transport like Socket.io - allow listening to [events](./events.md) on the server. This means the [Feathers application instance](./application.md) is usable the exact same way as on the server.\n\nModules most relevant on the client are:\n\n- `@feathersjs/feathers` to initialize a new Feathers [application](./application.md)\n- [@feathersjs/rest-client](./client/rest.md) to connect to services through REST HTTP provided by [Koa](./koa.md) or [Express](./express.md).\n- [@feathersjs/socketio-client](./client/socketio.md) to connect to services through [Socket.io](./socketio.md).\n- [@feathersjs/authentication-client](./authentication/client.md) to authenticate a client\n\n<BlockQuote type=\"warning\" label=\"Important\">\n\nYou do not have to use Feathers on the client to connect to a Feathers server. The client [REST client](./client/rest.md) and [Socket.io client](./client/socketio.md) chapters also describe how to use the connection directly without Feathers on the client side.\n\n</BlockQuote>\n\nThis chapter describes how to set up Feathers as the client in Node, React Native and in the browser with a module loader like Webpack or Parcel or through a `<script>` tag. The examples are using [the Socket.io client](./client/socketio.md). For other connection methods see the chapters linked above.\n\n## Typed client\n\nA Feathers application generated with Feathers v5 or later now exports a client file, including the types you defined in [schemas](./schema/index.md) on the server. For more information see the [CLI guide](../guides/cli/client.md)\n\n## Node\n\nTo connect to a Feathers server in NodeJS, install the desired client connection library (here, `socket.io-client`), alongside the Feathers core library, and the connection-specific library:\n\n```\nnpm install @feathersjs/feathers @feathersjs/socketio-client socket.io-client --save\n```\n\nThen initialize like this:\n\n```ts\nimport io from 'socket.io-client'\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\n\nconst socket = io('http://api.my-feathers-server.com')\nconst client = feathers()\n\nclient.configure(socketio(socket))\n\nconst messageService = client.service('messages')\n\nmessageService.on('created', (message: Message) => console.log('Created a message', message))\n\n// Use the messages service from the server\nmessageService.create({\n  text: 'Message from",
    "version": "v5",
    "tokens": [
      "feathers",
      "client",
      "---",
      "outline",
      "deep",
      "---",
      "feathers",
      "client",
      "one",
      "the",
      "most",
      "notable",
      "features",
      "feathers",
      "that",
      "can",
      "also",
      "used",
      "the",
      "client",
      "contrast",
      "with",
      "most",
      "other",
      "frameworks",
      "isn",
      "separate",
      "library",
      "instead",
      "you",
      "get",
      "the",
      "exact",
      "same",
      "functionality",
      "with",
      "client",
      "and",
      "server",
      "this",
      "means",
      "you",
      "can",
      "use",
      "services",
      "services",
      "and",
      "hooks",
      "hooks",
      "and",
      "configure",
      "plugins",
      "default",
      "feathers",
      "client",
      "automatically",
      "creates",
      "services",
      "that",
      "talk",
      "feathers",
      "server",
      "order",
      "connect",
      "feathers",
      "server",
      "client",
      "creates",
      "services",
      "services",
      "that",
      "use",
      "rest",
      "websocket",
      "connection",
      "relay",
      "method",
      "calls",
      "and",
      "for",
      "real-time",
      "transport",
      "like",
      "socket",
      "allow",
      "listening",
      "events",
      "events",
      "the",
      "server",
      "this",
      "means",
      "the",
      "feathers",
      "application",
      "instance",
      "application",
      "usable",
      "the",
      "exact",
      "same",
      "way",
      "the",
      "server",
      "modules",
      "most",
      "relevant",
      "the",
      "client",
      "are",
      "feathersjs",
      "feathers",
      "initialize",
      "new",
      "feathers",
      "application",
      "application",
      "feathersjs",
      "rest-client",
      "client",
      "rest"
    ],
    "category": "client"
  },
  {
    "id": "v4-api-services",
    "title": "Services",
    "content": "# Services \"Services\" are the heart of every Feathers application. Services are JavaScript objects (or instances of ES6 classes (opens new window) ) that implement certain methods . Feathers itself will also add some additional methods and functionality to its services. # Service methods Service methods are pre-defined CRUD (opens new window) methods that your service object can implement (or that have already been implemented by one of the database adapters ). Below is an example of a Feathers service using async/await (opens new window) as a JavaScript object and a JavaScript or Typescript class (opens new window) : const myService = { async find ( params ) { return [ ] ; } , async get ( id , params ) { } , async create ( data , params ) { } , async update ( id , data , params ) { } , async patch ( id , data , params ) { } , async remove ( id , params ) { } , setup ( app , path ) { } } app . use ( '/my-service' , myService ) ;",
    "version": "v4",
    "tokens": [
      "services",
      "are",
      "the",
      "heart",
      "every",
      "feathers",
      "application",
      "javascript",
      "objects",
      "instances",
      "classes",
      "opens",
      "new",
      "window",
      "that",
      "implement",
      "certain",
      "methods",
      "itself",
      "will",
      "also",
      "add",
      "some",
      "additional",
      "and",
      "functionality",
      "its",
      "service",
      "pre",
      "defined",
      "crud",
      "your",
      "object",
      "can",
      "have",
      "already",
      "been",
      "implemented",
      "one",
      "database",
      "adapters",
      "below",
      "example",
      "using",
      "async",
      "await",
      "typescript",
      "class",
      "const",
      "myservice",
      "find",
      "params",
      "return",
      "get",
      "create",
      "data",
      "update",
      "patch",
      "remove",
      "setup",
      "app",
      "path",
      "use"
    ],
    "category": "services"
  },
  {
    "id": "v4-api-databases-common",
    "title": "Common API",
    "content": "# Common API All database adapters implement a common interface for initialization, pagination, extending and querying. This chapter describes the common adapter initialization and options, how to enable and use pagination, the details on how specific service methods behave and how to extend an adapter with custom functionality. Important: Every database adapter is an implementation of the Feathers service interface . We recommend being familiar with services, service events and hooks before using a database adapter. # Initialization # new Service(options) Each adapter exports a Service class that can be exported and extended. const { Service } = require ( 'feathers-<adaptername>' ) ; app . use ( '/messages' , new Service ( ) ) ; app . use ( '/messages' , new Service ( { id , events , paginate } ) ) ;",
    "version": "v4",
    "tokens": [
      "common",
      "api",
      "all",
      "database",
      "adapters",
      "implement",
      "interface",
      "for",
      "initialization",
      "pagination",
      "extending",
      "and",
      "querying",
      "this",
      "chapter",
      "describes",
      "the",
      "adapter",
      "options",
      "how",
      "enable",
      "use",
      "details",
      "specific",
      "service",
      "methods",
      "behave",
      "extend",
      "with",
      "custom",
      "functionality",
      "important",
      "every",
      "implementation",
      "feathers",
      "recommend",
      "being",
      "familiar",
      "services",
      "events",
      "hooks",
      "before",
      "using",
      "new",
      "each",
      "exports",
      "class",
      "that",
      "can",
      "exported",
      "extended",
      "const",
      "require",
      "adaptername",
      "app",
      "messages",
      "paginate"
    ],
    "category": "services"
  },
  {
    "id": "v4-api-databases-querying",
    "title": "Querying",
    "content": "# Querying All official database adapters support a common way for querying, sorting, limiting and selecting find method calls as part of params.query . Querying also applies update , patch and remove method calls if the id is set to null . Important : When used via REST URLs all query values are strings. Depending on the service the values in params.query might have to be converted to the right type in a before hook . # Equality All fields that do not contain special query parameters are compared directly for equality. // Find all unread messages in room #2 app . service ( 'messages' ) . find ( { query : { read : false , roomId : 2 } } ) ;",
    "version": "v4",
    "tokens": [
      "querying",
      "all",
      "official",
      "database",
      "adapters",
      "support",
      "common",
      "way",
      "for",
      "sorting",
      "limiting",
      "and",
      "selecting",
      "find",
      "method",
      "calls",
      "part",
      "params",
      "query",
      "also",
      "applies",
      "update",
      "patch",
      "remove",
      "the",
      "set",
      "null",
      "important",
      "when",
      "used",
      "via",
      "rest",
      "urls",
      "values",
      "are",
      "strings",
      "depending",
      "service",
      "might",
      "have",
      "converted",
      "right",
      "type",
      "before",
      "hook",
      "equality",
      "fields",
      "that",
      "not",
      "contain",
      "special",
      "parameters",
      "compared",
      "directly",
      "unread",
      "messages",
      "room",
      "app",
      "read",
      "false",
      "roomid"
    ],
    "category": "services"
  },
  {
    "id": "v4-guides-basics-services",
    "title": "Services",
    "content": "# Services Services are the heart of every Feathers application. You probably remember the service we created in the getting started chapter to create and find messages. In this chapter we will dive more into services and update the existing user service in our chat application to include an avatar image. # Feathers services In general, a service is an object or instance of a class (opens new window) that implements certain methods. Services provide a uniform, protocol independent interface for how to interact with any kind of data like: Reading and/or writing from a database Interacting with the file system Call another API Call other services like Sending an email Processing a payment Returning the current weather for a location, etc. Protocol independent means that to a Feathers service it does not matter if it has been called through a REST API, websockets, internally in our application or any other way. # Service methods Service methods are CRUD (opens new window) methods that a service can implement. Feathers service methods are: find - Find all data (potentially matching a query) get - Get a single data entry by its unique identifier create - Create new data update - Update an existing data entry by completely replacing it patch - Update one or more data entries by merging with the new data remove - Remove one or more existing data entries Below is an example of Feathers service interface as a class and a normal object: class MyService { async find ( params ) { } async get ( id , params ) { } async create ( data , params ) { } async update ( id , data , params ) { } async patch ( id , data , params ) { } async remove ( id , params ) { } } app . use ( '/my-service' , new MyService ( ) ) ;",
    "version": "v4",
    "tokens": [
      "services",
      "are",
      "the",
      "heart",
      "every",
      "feathers",
      "application",
      "you",
      "probably",
      "remember",
      "service",
      "created",
      "getting",
      "started",
      "chapter",
      "create",
      "and",
      "find",
      "messages",
      "this",
      "will",
      "dive",
      "more",
      "into",
      "update",
      "existing",
      "user",
      "our",
      "chat",
      "include",
      "avatar",
      "image",
      "general",
      "object",
      "instance",
      "class",
      "opens",
      "new",
      "window",
      "that",
      "implements",
      "certain",
      "methods",
      "provide",
      "uniform",
      "protocol",
      "independent",
      "interface",
      "for",
      "how",
      "interact",
      "with",
      "any",
      "kind",
      "data",
      "like",
      "reading",
      "writing",
      "from",
      "database",
      "interacting",
      "file",
      "system",
      "call",
      "another",
      "api",
      "other",
      "sending",
      "email",
      "processing",
      "payment",
      "returning",
      "current",
      "weather",
      "location",
      "etc",
      "means",
      "does",
      "not",
      "matter",
      "has",
      "been",
      "called",
      "through",
      "rest",
      "websockets",
      "internally",
      "way",
      "crud"
    ],
    "category": "services"
  }
]
