[
  {
    "id": "v5-guides-basics-hooks",
    "title": "Hooks",
    "content": "Hooks | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Hooks ​\nWhen we created our messages service in the services chapter, we saw that Feathers services are a great way to implement data storage and modification. Technically, we could write our entire app with services but very often we need similar functionality across multiple services. For example, we might want to check for all services if a user is allowed to access it. With just services, we would have to write this every time.This is where Feathers hooks come in. Hooks are pluggable middleware functions that can be registered around, before, after or on errors of a service method without changing the original code.Just like services themselves, hooks are transport independent. They are usually also service independent, meaning they can be used with ​any​ service. This pattern keeps your application logic flexible, composable, and much easier to trace through and debug. Hooks are commonly used to handle things like validation, authorization, logging, sending emails and more.tipA full overview of the hook API can be found in the hooks API documentation. For the general design pattern behind hooks see this blog post.\n## Generating a hook ​\nLet's generate a hook that logs the total runtime of a service method to the console.sh\n```\nnpx feathers generate hook\n```\nWe call our hook `log-runtime` and confirm the type with enter to make it an `around` hook.Now update `src/hooks/log-runtime.ts` as follows:Now update `src/hooks/log-runtime.js` as follows:ts\n```\nimport type { HookContext, NextFunction } from '../declarations'\nimport { logger } from '../logger'\n\nexport const logRuntime = async (context: HookContext, next: NextFunction) => {\n  const startTime = Date.now()\n  // Run everything else (other hooks and service call)\n  await next()\n\n  const duration = Date.now() - startTime\n  logger.info(`Calling ${context.method} on ${context.path} took ${duration}ms`)\n}\n```\nIn this hook, we store the start time and then run all other hooks and the service method by calling `await next()`. After that we can calculate the duration in milliseconds by subtracting the start time from the current time and log the information using the application logger.\n## Hook functions ​\nA hook function is an `async` function that takes the hook `context` and a `next` function as the parameter. If the hook should only run on error, before or after the service method, it does not need a `next` function. However since we need to do both, get the start time before and the end time after, we created an `around` hook.Hooks run in the order they are registered and if a hook function throws an error, all remaining hooks (and the service call if it didn't run yet) will be skipped and the error will be returned.\n## Hook context ​\nThe hook `context` is an object which contains information about the service method call. It has read-only and writable properties.Read-only properties are:`context.app` - The Feathers application object. This commonly used to call other services\n• `context.service` - The service object this hook is currently running on\n• `context.path` - The path (name) of the service\n• `context.method` - The name of the service method being called\n• `context.type` - The hook type (around, before, etc)\n\nWriteable properties are:\n• `context.params` - The service method call `params`. For external calls, `params` usually contains: `context.params.query` - The query filter (e.g. from the REST query string) for the service call\n• `context.params.provider` - The name of the transport the call has been made through. Usually `\"rest\"` or `\"socketio\"`. Will be `undefined` for internal calls.\n• `context.params.user` - If authenticated, the data of the user making the service method call.\n• `context.id` - The `id` of the record if the service method call is a `get`, `remove`, `update` or `patch`\n• `context.data` - The `data` sent by the user in a `create`, `update` and `patch` and custom service method call\n• `context.error` - The error that was thrown (in `error` hooks)\n• `context.result` - The result of the service method call (available after calling `await next()` or in `after` hooks)\n\ntip\n\nFor more information about the hook context see the hooks API documentation.\n\n## Registering hooks ​\n\nIn a Feathers application, hooks are being registered in the <servicename> file. The hook registration object is an object with `{ around, before, after, error }` and a list of hooks per method like `{ all: [], find: [], create: [] }`.\n\nTo log the runtime of our `messages` service calls we can update `src/services/messages/messages.ts` like this:\n\nTo log the runtime of all `messages` service calls we can update `src/services/messages/messages.js` like this:\n\nts\n```\n// For more information about this file see https://dove.feathersjs.com/guides/cli/service.html\nimport { authenticate } from '@feathersjs/authentication'\n\nimport { hooks as schemaHooks } from '@feathersjs",
    "version": "v5",
    "tokens": [
      "hooks",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "when",
      "created",
      "our",
      "messages",
      "service",
      "the",
      "services",
      "chapter",
      "saw",
      "that",
      "are",
      "great",
      "way",
      "implement",
      "data",
      "storage",
      "and",
      "modification",
      "technically",
      "could",
      "write",
      "entire",
      "app",
      "with",
      "but",
      "very",
      "often",
      "need",
      "similar",
      "functionality",
      "across",
      "multiple",
      "for",
      "example",
      "might",
      "want",
      "check",
      "all",
      "user",
      "allowed",
      "access",
      "just",
      "would",
      "have",
      "this",
      "every",
      "time",
      "where",
      "come",
      "pluggable",
      "middleware",
      "functions",
      "can",
      "registered",
      "around",
      "before",
      "after",
      "errors",
      "method",
      "without",
      "changing",
      "original",
      "code",
      "like",
      "themselves",
      "transport",
      "independent",
      "they",
      "usually",
      "also",
      "meaning",
      "used",
      "any",
      "pattern",
      "keeps",
      "your",
      "application",
      "logic",
      "flexible",
      "composable",
      "much",
      "easier",
      "trace",
      "through",
      "debug",
      "commonly",
      "handle",
      "things",
      "validation",
      "authorization",
      "logging",
      "sending",
      "emails",
      "more",
      "tipa",
      "full",
      "overview",
      "hook",
      "api",
      "found",
      "documentation",
      "general",
      "design",
      "behind",
      "see",
      "blog",
      "post",
      "generating",
      "let",
      "generate",
      "logs",
      "total",
      "runtime",
      "console",
      "npx",
      "call",
      "log",
      "confirm",
      "type",
      "enter",
      "make",
      "now",
      "update",
      "src",
      "follows",
      "import",
      "hookcontext",
      "nextfunction",
      "from",
      "declarations",
      "logger",
      "export",
      "const",
      "logruntime",
      "async",
      "context",
      "next",
      "starttime",
      "date",
      "run",
      "everything",
      "else",
      "other",
      "await",
      "duration",
      "info",
      "calling",
      "path",
      "took"
    ],
    "category": "hooks"
  },
  {
    "id": "v5-guides-cli-hook",
    "title": "Hooks",
    "content": "Hooks | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Hooks ​\n\n## Generating a hook ​\nA new hook can be generated via\n```\nnpx feathers generate hook\n```\n\n## Hook name ​\nThe hook generator will first ask for a name. Based on the name it will create a kebab-cased filename in the `hooks/` folder that exports a camelCased hook function. For example a name of `my fancy Hook` will create a `src/my-fancy-hook.ts` file that exports a `myFancyHook` hook function.\n## Hook types ​\nThere are two hook types that can be generated.tipFor more information see the hooks API documentation.\n### Around hooks ​\nAround hooks allow to control the entire `before`, `after` and `error` flow in a single function. An `around` hook is an `async` function that accepts two arguments:The hook context\n• An asynchronous `next` function. Somewhere in the body of the hook function, there is a call to `await next()`, which calls the `next` hooks OR the original function if all other hooks have run.\n\nts\n```\nimport type { HookContext, NextFunction } from '../declarations'\n\nexport const myFancyHook = async (context: HookContext, next: NextFunction) => {\n  console.log(`Running hook ${name} on ${context.path}.${context.method}`)\n  await next()\n  // Do things after here\n}\n```\n\nYou can wrap the `await next()` in a `try/catch` block to also handle errors.\n\n### Before, after, error ​\n\nBefore, after or error hooks are `async` functions that take the hook context as the parameter.\n\nts\n```\nimport type { HookContext } from '../declarations'\n\nexport const myFancyHook = async (context: HookContext) => {\n  console.log(`Running hook ${name} on ${context.path}.${context.method}`)\n}\n```\n\n## Context types ​\n\nIf the hook is for a specific service, you can pass the service as a generic to the HookContext type which will give you the correct types for context.data, context.result and context.params:\n\nts\n```\nimport type { UserService } from '../services/users/users'\nimport type { HookContext } from '../declarations'\n\nexport const myFancyUserHook = async (context: HookContext) => {\n  console.log(`Running hook ${name} on ${context.path}.${context.method}`)\n}\n```\n\n## Registering hooks ​\n\nA generated hook can be registered as an application hook or as a service hook. Also see the hook registration API documentation.\n\n## Profiling example ​\n\nTo log some basic profiling information like which method was called and how long it took to run you can create a new around hook called `profiler` via\n\n```\nnpx feathers generate hook\n```\n\nThen update `src/hooks/profiler.ts` as follows:\n\nts\n```\nimport type { HookContext, NextFunction } from '../declarations'\nimport { logger } from '../logger'\n\nexport const profiler = async (context: HookContext, next: NextFunction) => {\n  const startTime = Date.now()\n\n  await next()\n\n  const runtime = Date.now() - startTime\n\n  console.log(`Calling ${context.method} on service ${context.path} took ${runtime}ms`)\n}\n```\n\nAnd add it in `src/app.ts` as an application hook after the `logError` hook as follows:\n\nts\n```\nimport { profiler } from './hooks/profiler'\n\n//...\n\n// Register hooks that run on all service methods\napp.hooks({\n  around: {\n    all: [ logError, profiler ]\n  },\n  before: {},\n  after: {},\n  error: {}\n})\n```\n\n Suggest changes to this page\n\nLast updated: \n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors\n\n feathers \n\n• About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "hooks",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "generating",
      "hook",
      "new",
      "can",
      "generated",
      "via",
      "npx",
      "generate",
      "name",
      "the",
      "generator",
      "will",
      "first",
      "ask",
      "for",
      "based",
      "create",
      "kebab",
      "cased",
      "filename",
      "folder",
      "that",
      "exports",
      "camelcased",
      "function",
      "example",
      "fancy",
      "src",
      "file",
      "myfancyhook",
      "types",
      "there",
      "are",
      "two",
      "tipfor",
      "more",
      "information",
      "see",
      "api",
      "documentation",
      "around",
      "allow",
      "control",
      "entire",
      "before",
      "after",
      "and",
      "error",
      "flow",
      "single",
      "async",
      "accepts",
      "arguments",
      "context",
      "asynchronous",
      "next",
      "somewhere",
      "body",
      "call",
      "await",
      "which",
      "calls",
      "original",
      "all",
      "other",
      "have",
      "run",
      "import",
      "type",
      "hookcontext",
      "nextfunction",
      "from",
      "declarations",
      "export",
      "const",
      "console",
      "log",
      "running",
      "path",
      "method",
      "things",
      "here",
      "you",
      "wrap",
      "try",
      "catch",
      "block",
      "also",
      "handle",
      "errors",
      "functions",
      "take",
      "parameter",
      "specific",
      "service",
      "pass",
      "generic",
      "give",
      "correct",
      "data",
      "result",
      "params",
      "userservice",
      "services",
      "users"
    ],
    "category": "hooks"
  },
  {
    "id": "v5-guides-cli-log-error",
    "title": "Error logging hook",
    "content": "Error logging hook | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Error logging hook ​\nThe `src/hooks/log-error.ts` file exports a `logError` hook that uses the logger to log any error for a service method, including validation error details (when they are available). It is registered as an application hook `all` hook, meaning it will log errors for any service method. Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "error",
      "logging",
      "hook",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "the",
      "src",
      "hooks",
      "log",
      "file",
      "exports",
      "logerror",
      "that",
      "uses",
      "logger",
      "any",
      "for",
      "service",
      "method",
      "including",
      "validation",
      "details",
      "when",
      "they",
      "are",
      "available",
      "registered",
      "application",
      "all",
      "meaning",
      "will",
      "errors",
      "suggest",
      "changes",
      "this",
      "pagelast",
      "updated",
      "released",
      "under",
      "mit",
      "license",
      "copyright",
      "feathersjs",
      "contributors",
      "about",
      "philosophy",
      "comparison",
      "ecosystem",
      "learn",
      "guides",
      "api",
      "blog",
      "become",
      "backer",
      "find",
      "help",
      "github",
      "issues"
    ],
    "category": "hooks"
  },
  {
    "id": "v5-api-hooks",
    "title": "Hooks",
    "content": "Hooks | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Hooks ​\nHooks are pluggable middleware functions that can be registered around, before, after or on error(s) of a service method. Multiple hook functions can be chained to create complex work-flows. A hook is transport independent, which means it does not matter if it has been called internally on the server, through HTTP(S) (REST), websockets or any other transport Feathers supports. They are also service agnostic, meaning they can be used with ​any​ service regardless of whether they use a database or not.Hooks are commonly used to handle things like permissions, validation, logging, authentication, data schemas and resolvers, sending notifications and more. This pattern keeps your application logic flexible, composable, and easier to trace through and debug. For more information about the design patterns behind hooks see this blog post.\n## Quick Example ​\nThe following example logs the runtime of any service method on the `messages` service and adds `createdAt` property before saving the data to the database:ts\n```\nimport { feathers, type HookContext, type NextFunction } from '@feathersjs/feathers'\n\nconst app = feathers()\n\napp.service('messages').hooks({\n  around: {\n    all: [\n      // A hook that wraps around all other hooks and the service method\n      // logging the total runtime of a successful call\n      async (context: HookContext, next: NextFunction) => {\n        const startTime = Date.now()\n\n        await next()\n\n        console.log(`Method ${context.method} on ${context.path} took ${Date.now() - startTime}ms`)\n      }\n    ]\n  },\n  before: {\n    create: [\n      async (context: HookContext) => {\n        context.data = {\n          ...context.data,\n          createdAt: Date.now()\n        }\n      }\n    ]\n  }\n})\n```\ninfoWhile it is always possible to add properties like `createdAt` in the above example via hooks, the preferred way to make data modifications like this in Feathers 5 is via schemas and resolvers.\n## Hook functions ​\n\n### before, after and error ​\n`before`, `after` and `error` hook functions are functions that are `async` or return a promise and take the hook context as the parameter and return nothing or throw an error.ts\n```\nimport { HookContext } from '../declarations'\n\nexport const hookFunction = async (context: HookContext) => {\n  // Do things here\n}\n```\nFor more information see the hook flow section.\n### around ​\n`around` hooks are a special kind of hook that allow to control the entire `before`, `after` and `error` flow in a single function. They are a Feathers specific version of the generic @feathersjs/hooks. An `around` hook is an `async` function that accepts two arguments:The hook context\n• An asynchronous `next` function. Somewhere in the body of the hook function, there is a call to `await next()`, which calls the `next` hooks OR the original function if all other hooks have run.\n\nIn its simplest form, an around hook looks like this:\n\njs\n```\nimport { HookContext, NextFunction } from '../declarations'\n\nexport const myAfoundHook = async (context: HookContext, next: NextFunction) => {\n  try {\n    // Code before `await next()` runs before the main function\n    await next()\n    // Code after `await next()` runs after the main function.\n  } catch (error) {\n    // Do things on error\n  } finally {\n    // Do things always\n  }\n}\n```\n\nAny around hook can be wrapped around another function. Calling `await next()` will either call the next hook in the chain or the service method if all other hooks have run.\n\n## Hook flow ​\n\nIn general, hooks are executed in the order they are registered with `around` hooks running first:\n• `around` hooks (before `await next()`)\n• `before` hooks\n• service method\n• `after` hooks\n• `around` hooks (after `await next()`)\n\nNote that since `around` hooks wrap around everything, the first hook to run will be the last to execute its code after `await next()`. This is reverse of the order `after` hooks execute.\n\nThe hook flow can be affected as follows.\n\n### Throwing an error ​\n\nWhen an error is thrown (or the promise is rejected), all subsequent hooks - and the service method call if it didn't run already - will be skipped and only the error hooks will run.\n\nThe following example throws an error when the text for creating a new message is empty. You can also create very similar hooks to use your Node validation library of choice.\n\nts\n```\napp.service('messages').hooks({\n  before: {\n    create: [\n      async (context: HookContext) => {\n        if (context.data.text.trim() === '') {\n          throw new Error('Message text can not be empty')\n        }\n      }\n    ]\n  }\n})\n```\n\n### Setting `context.result` ​\n\nWhen `context.result` is set in an `around` hook before calling `await next()` or in a `before` hook, the original service method call will be skipped. All other hooks will still execute in their normal order. The following example always returns the currently authent",
    "version": "v5",
    "tokens": [
      "hooks",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "are",
      "pluggable",
      "middleware",
      "functions",
      "that",
      "can",
      "registered",
      "around",
      "before",
      "after",
      "error",
      "service",
      "method",
      "multiple",
      "hook",
      "chained",
      "create",
      "complex",
      "work",
      "flows",
      "transport",
      "independent",
      "which",
      "means",
      "does",
      "not",
      "matter",
      "has",
      "been",
      "called",
      "internally",
      "the",
      "server",
      "through",
      "http",
      "rest",
      "websockets",
      "any",
      "other",
      "supports",
      "they",
      "also",
      "agnostic",
      "meaning",
      "used",
      "with",
      "regardless",
      "whether",
      "use",
      "database",
      "commonly",
      "handle",
      "things",
      "like",
      "permissions",
      "validation",
      "logging",
      "authentication",
      "data",
      "schemas",
      "and",
      "resolvers",
      "sending",
      "notifications",
      "more",
      "this",
      "pattern",
      "keeps",
      "your",
      "application",
      "logic",
      "flexible",
      "composable",
      "easier",
      "trace",
      "debug",
      "for",
      "information",
      "about",
      "design",
      "patterns",
      "behind",
      "see",
      "blog",
      "post",
      "quick",
      "example",
      "following",
      "logs",
      "runtime",
      "messages",
      "adds",
      "createdat",
      "property",
      "saving",
      "import",
      "type",
      "hookcontext",
      "nextfunction",
      "from",
      "feathersjs",
      "const",
      "app",
      "all",
      "wraps",
      "total",
      "successful",
      "call",
      "async",
      "context",
      "next",
      "starttime",
      "date",
      "now",
      "await",
      "console",
      "log",
      "path",
      "took",
      "infowhile",
      "always",
      "possible",
      "add",
      "properties",
      "above",
      "via",
      "preferred",
      "way",
      "make",
      "modifications"
    ],
    "category": "hooks"
  },
  {
    "id": "v4-api-hooks",
    "title": "Hooks",
    "content": "# Hooks Hooks are pluggable middleware functions that can be registered before , after or on error (s) of a service method . You can register a single hook function or create a chain of them to create complex work-flows. Most of the time multiple hooks are registered so the examples show the \"hook chain\" array style registration. A hook is transport independent , which means it does not matter if it has been called through HTTP(S) (REST), Socket.io, Primus or any other transport Feathers may support in the future. They are also service agnostic, meaning they can be used with ​ any ​ service regardless of whether they have a model or not. Hooks are commonly used to handle things like validation, logging, populating related entities, sending notifications and more. This pattern keeps your application logic flexible, composable, and much easier to trace through and debug. For more information about the design patterns behind hooks see this blog post (opens new window) . # Quick Example The following example adds a createdAt and updatedAt property before saving the data to the database and logs any errors on the service: const feathers = require ( '@feathersjs/feathers' ) ; const app = feathers ( ) ; app . service ( 'messages' ) . hooks ( { before : { create : [ async context => { context . data . createdAt = new Date ( ) ; return context ; } ] , update : [ async context => { context . data . updatedAt = new Date ( ) ; return context ; } ] , patch : [ async context => { context . data . updatedAt = new Date ( ) ; return context ; } ] } , error : { all : [ async context => { console . error ( ` Error in ${ context . path } calling ${ context . method } method ` , context . error ) ; return context ; } ] } ) ;",
    "version": "v4",
    "tokens": [
      "hooks",
      "are",
      "pluggable",
      "middleware",
      "functions",
      "that",
      "can",
      "registered",
      "before",
      "after",
      "error",
      "service",
      "method",
      "you",
      "register",
      "single",
      "hook",
      "function",
      "create",
      "chain",
      "them",
      "complex",
      "work",
      "flows",
      "most",
      "the",
      "time",
      "multiple",
      "examples",
      "show",
      "array",
      "style",
      "registration",
      "transport",
      "independent",
      "which",
      "means",
      "does",
      "not",
      "matter",
      "has",
      "been",
      "called",
      "through",
      "http",
      "rest",
      "socket",
      "primus",
      "any",
      "other",
      "feathers",
      "may",
      "support",
      "future",
      "they",
      "also",
      "agnostic",
      "meaning",
      "used",
      "with",
      "regardless",
      "whether",
      "have",
      "model",
      "commonly",
      "handle",
      "things",
      "like",
      "validation",
      "logging",
      "populating",
      "related",
      "entities",
      "sending",
      "notifications",
      "and",
      "more",
      "this",
      "pattern",
      "keeps",
      "your",
      "application",
      "logic",
      "flexible",
      "composable",
      "much",
      "easier",
      "trace",
      "debug",
      "for",
      "information",
      "about",
      "design",
      "patterns",
      "behind",
      "see",
      "blog",
      "post",
      "opens",
      "new",
      "window",
      "quick",
      "example"
    ],
    "category": "hooks"
  },
  {
    "id": "v4-guides-basics-hooks",
    "title": "Hooks",
    "content": "# Hooks As we have seen in the services chapter , Feathers services are a great way to implement data storage and modification. Technically, we could implement our entire app with services but very often we need similar functionality across multiple services. For example, we might want to check for all services if a user is allowed to even use it or add the current date to all data that we are saving. With just using services we would have to implement this again every time. This is where Feathers hooks come in. Hooks are pluggable middleware functions that can be registered before , after or on errors of a service method. You can register a single hook function or create a chain of them to create complex work-flows. In this chapter we will learn more about hooks and create workflows to process new chat messages. Just like services themselves, hooks are transport independent . They are usually also service agnostic, meaning they can be used with ​ any ​ service. This pattern keeps your application logic flexible, composable, and much easier to trace through and debug. Note: A full overview of the hook API can be found in the hooks API documentation . Hooks are commonly used to handle things like validation, authorization, logging, populating related entities, sending notifications and more. Pro tip: For the general design pattern behind hooks see this blog post (opens new window) . A more Feathers specific overview can be found here (opens new window) . # Quick example Here is a quick example for a hook that adds a createdAt property to the data before calling the actual create service method: const createdAt = async context => { context . data . createdAt = new Date ( ) ; return context ; } ; app . service ( 'messages' ) . hooks ( { before : { create : [ createdAt ] } } ) ;",
    "version": "v4",
    "tokens": [
      "hooks",
      "have",
      "seen",
      "the",
      "services",
      "chapter",
      "feathers",
      "are",
      "great",
      "way",
      "implement",
      "data",
      "storage",
      "and",
      "modification",
      "technically",
      "could",
      "our",
      "entire",
      "app",
      "with",
      "but",
      "very",
      "often",
      "need",
      "similar",
      "functionality",
      "across",
      "multiple",
      "for",
      "example",
      "might",
      "want",
      "check",
      "all",
      "user",
      "allowed",
      "even",
      "use",
      "add",
      "current",
      "date",
      "that",
      "saving",
      "just",
      "using",
      "would",
      "this",
      "again",
      "every",
      "time",
      "where",
      "come",
      "pluggable",
      "middleware",
      "functions",
      "can",
      "registered",
      "before",
      "after",
      "errors",
      "service",
      "method",
      "you",
      "register",
      "single",
      "hook",
      "function",
      "create",
      "chain",
      "them",
      "complex",
      "work",
      "flows",
      "will",
      "learn",
      "more",
      "about",
      "workflows",
      "process",
      "new",
      "chat",
      "messages",
      "like",
      "themselves",
      "transport",
      "independent",
      "they",
      "usually",
      "also",
      "agnostic",
      "meaning",
      "used",
      "any",
      "pattern",
      "keeps",
      "your"
    ],
    "category": "hooks"
  },
  {
    "id": "v4-api-authentication-hook",
    "title": "Hook",
    "content": "# Hook The authenticate hook will use params.authentication of the service method call and run authenticationService.authenticate() . # authenticate(... strategies) # authenticate(options) It should be used as a before hook and either takes a list of strategy names (using app.service('authentication') as the authentication service) or an object with service set to the authentication service name and strategies set to a list of strategy names to authenticate with: const { authenticate } = require ( '@feathersjs/authentication' ) ; // Authenticate with `jwt` and `api-key` strategy // using app.service('authentication') as the authentication service app . service ( 'messages' ) . hooks ( { before : authenticate ( 'jwt' , 'api-key' ) } ) ; // Authenticate with `jwt` and `api-key` strategy // using app.service('v1/authentication') as the authentication service app . service ( 'messages' ) . hooks ( { before : authenticate ( { service : 'v1/authentication' , strategies : [ 'jwt' , 'api-key' ] } ) } ) ;",
    "version": "v4",
    "tokens": [
      "hook",
      "the",
      "authenticate",
      "will",
      "use",
      "params",
      "authentication",
      "service",
      "method",
      "call",
      "and",
      "run",
      "authenticationservice",
      "strategies",
      "options",
      "should",
      "used",
      "before",
      "either",
      "takes",
      "list",
      "strategy",
      "names",
      "using",
      "app",
      "object",
      "with",
      "set",
      "name",
      "const",
      "require",
      "feathersjs",
      "jwt",
      "api",
      "key",
      "messages",
      "hooks"
    ],
    "category": "hooks"
  },
  {
    "id": "v4-cookbook-express-file-uploading",
    "title": "File uploads in FeathersJS",
    "content": "# File uploads in FeathersJS Over the last months we at ciancoders.com (opens new window) have been working in a new SPA project using Feathers and React, the combination of those two turns out to be just amazing . Recently we were struggling to find a way to upload files without having to write a separate Express middleware or having to (re)write a complex Feathers service. # Our Goals We want to implement an upload service to accomplish a few important things: It has to handle large files (+10MB). It needs to work with the app's authentication and authorization. The files need to be validated. At the moment there is no third party storage service involved, but this will change in the near future, so it has to be prepared. It has to show the upload progress. The plan is to upload the files to a feathers service so we can take advantage of hooks for authentication, authorization and validation, and for service events. Fortunately, there exists a file storage service: feathers-blob (opens new window) . With it we can meet our goals, but (spoiler alert) it isn't an ideal solution. We discuss some of its problems below. # Basic upload with feathers-blob and feathers-client For the sake of simplicity, we will be working over a very basic feathers server, with just the upload service. Lets look at the server code: /* --- server.js --- */ const feathers = require ( '@feathersjs/feathers' ) ; const express = require ( '@feathersjs/express' ) ; const socketio = require ( '@feathersjs/socketio' ) ; // feathers-blob service const blobService = require ( 'feathers-blob' ) ; // Here we initialize a FileSystem storage, // but you can use feathers-blob with any other // storage service like AWS or Google Drive. const fs = require ( 'fs-blob-store' ) ; const blobStorage = fs ( __dirname + '/uploads' ) ; // Feathers app const app = express ( feathers ( ) ) ; // Parse HTTP JSON bodies app . use ( express . json ( ) ) ; // Parse URL-encoded params app . use ( express . urlencoded ( { extended : true } ) ) ; // Add REST API support app . configure ( express . rest ( ) ) ; // Configure Socket.io real-time APIs app . configure ( socketio ( ) ) ; // Upload Service app . use ( '/uploads' , blobService ( { Model : blobStorage } ) ) ; // Register a nicer error handler than the default Express one app . use ( express . errorHandler ( ) ) ; // Start the server app . listen ( 3030 , function ( ) { console . log ( 'Feathers app started at localhost:3030' ) } ) ;",
    "version": "v4",
    "tokens": [
      "file",
      "uploads",
      "feathersjs",
      "over",
      "the",
      "last",
      "months",
      "ciancoders",
      "com",
      "opens",
      "new",
      "window",
      "have",
      "been",
      "working",
      "spa",
      "project",
      "using",
      "feathers",
      "and",
      "react",
      "combination",
      "those",
      "two",
      "turns",
      "out",
      "just",
      "amazing",
      "recently",
      "were",
      "struggling",
      "find",
      "way",
      "upload",
      "files",
      "without",
      "having",
      "write",
      "separate",
      "express",
      "middleware",
      "complex",
      "service",
      "our",
      "goals",
      "want",
      "implement",
      "accomplish",
      "few",
      "important",
      "things",
      "has",
      "handle",
      "large",
      "needs",
      "work",
      "with",
      "app",
      "authentication",
      "authorization",
      "need",
      "validated",
      "moment",
      "there",
      "third",
      "party",
      "storage",
      "involved",
      "but",
      "this",
      "will",
      "change",
      "near",
      "future",
      "prepared",
      "show",
      "progress",
      "plan",
      "can",
      "take",
      "advantage",
      "hooks",
      "for",
      "validation",
      "events",
      "fortunately",
      "exists",
      "blob",
      "ope"
    ],
    "category": "hooks"
  },
  {
    "id": "v4-guides-security",
    "title": "Security",
    "content": "# Security We take security very seriously at Feathers. We welcome any peer review of our 100% open source code to ensure nobody's Feathers app is ever compromised or hacked. However, as a web application developer, you are responsible for the security of your application. We do our very best to make sure Feathers is as secure as possible. # Reporting security issues In order to give the community time to respond and upgrade, we strongly urge you report all security issues to us. Send us a PM in Slack (opens new window) or email us at hello@feathersjs.com with details, and we will respond ASAP. Security issues always take precedence over bug fixes and feature work; so, we'll work with you to come up with a resolution and plan and document the issue on Github in the appropriate repo. Issuing releases is typically very quick. Once an issue is resolved it is usually released immediately with the appropriate semantic version. # Security considerations Here are some things that you should be aware of when writing your app to make sure it is secure. Make sure to set up proper event channels so that only clients that are allowed to see them can see real-time updates Use hooks to check security roles to make sure users can only access data they should be permitted to. You can find useful hook utilities in feathers-hooks-common (opens new window) and feathers-authentication-hooks (opens new window) . Restrict the allowed database queries to only the use cases your application requires by sanitizing params.query in a hook. When you explicitly allow multiple element changes, make sure queries are secured properly to limit the items that can be changed. Escape any HTML and JavaScript to avoid XSS attacks. Escape any SQL (typically done by the SQL library) to avoid SQL injection. JSON Web Tokens (JWT's) are only signed. They are not encrypted. Therefore, the payload can be examined on the client. This is by design. DO NOT put anything that should be private in the JWT payload unless you encrypt it first. Don't use a weak secret for your token service. The generator creates a strong one for you automatically. No need to change it. # Technologies used Password storage inside @feathers/authentication-local uses bcrypt (opens new window) . We don't store the salts separately since they are included in the bcrypt hashes. By default, JWT (opens new window) 's are stored in Local Storage (instead of cookies) to avoid CSRF attacks. For JWT, we use the HS256 algorithm by default (HMAC using SHA-256 hash algorithm). If you choose to store JWT's in cookies, your app may have CSRF vulnerabilities. # XSS attacks As with any web application you need to guard against XSS attacks. Since Feathers persists the JWT in localstorage in the browser, if your app falls victim to a XSS attack your JWT could be used by an attacker to make malicious requests on your behalf. This is far from ideal. Therefore you need to take extra care in preventing XSS attacks. Our stance on this parti",
    "version": "v4",
    "tokens": [
      "security",
      "take",
      "very",
      "seriously",
      "feathers",
      "welcome",
      "any",
      "peer",
      "review",
      "our",
      "open",
      "source",
      "code",
      "ensure",
      "nobody",
      "app",
      "ever",
      "compromised",
      "hacked",
      "however",
      "web",
      "application",
      "developer",
      "you",
      "are",
      "responsible",
      "for",
      "the",
      "your",
      "best",
      "make",
      "sure",
      "secure",
      "possible",
      "reporting",
      "issues",
      "order",
      "give",
      "community",
      "time",
      "respond",
      "and",
      "upgrade",
      "strongly",
      "urge",
      "report",
      "all",
      "send",
      "slack",
      "opens",
      "new",
      "window",
      "email",
      "hello",
      "feathersjs",
      "com",
      "with",
      "details",
      "will",
      "asap",
      "always",
      "precedence",
      "over",
      "bug",
      "fixes",
      "feature",
      "work",
      "come",
      "resolution",
      "plan",
      "document",
      "issue",
      "github",
      "appropriate",
      "repo",
      "issuing",
      "releases",
      "typically",
      "quick",
      "once",
      "resolved",
      "usually",
      "released",
      "immediately",
      "semantic",
      "version",
      "considerations",
      "here",
      "some",
      "things",
      "that",
      "should"
    ],
    "category": "hooks"
  },
  {
    "id": "v4-api-authentication-",
    "title": "Overview",
    "content": "# Overview The @feathersjs/authentication plugins provide a collection of tools for managing username/password, JWT and OAuth (GitHub, Facebook etc.) authentication as well as custom authentication mechanisms and for authenticating on the client. It consists of the following core modules: @feathersjs/authentication which includes The AuthenticationService that allows to register authentication strategies and create and manage access tokens The JWTStrategy to use JWTs to make authenticated requests The authenticate hook to limit service calls to an authentication strategy. Local authentication for local username/password authentication OAuth authentication for GitHub, Facebook etc. authentication The authentication client to use Feathers authentication on the client. Important: @feathersjs/authentication is an abstraction for different authentication mechanisms. It does not handle things like user verification or password reset functionality etc. This can be implemented manually, with the help of libraries like feathers-authentication-management (opens new window) or a platform like Auth0 (opens new window) .",
    "version": "v4",
    "tokens": [
      "overview",
      "the",
      "feathersjs",
      "authentication",
      "plugins",
      "provide",
      "collection",
      "tools",
      "for",
      "managing",
      "username",
      "password",
      "jwt",
      "and",
      "oauth",
      "github",
      "facebook",
      "etc",
      "well",
      "custom",
      "mechanisms",
      "authenticating",
      "client",
      "consists",
      "following",
      "core",
      "modules",
      "which",
      "includes",
      "authenticationservice",
      "that",
      "allows",
      "register",
      "strategies",
      "create",
      "manage",
      "access",
      "tokens",
      "jwtstrategy",
      "use",
      "jwts",
      "make",
      "authenticated",
      "requests",
      "authenticate",
      "hook",
      "limit",
      "service",
      "calls",
      "strategy",
      "local",
      "feathers",
      "important",
      "abstraction",
      "different",
      "does",
      "not",
      "handle",
      "things",
      "like",
      "user",
      "verification",
      "reset",
      "functionality",
      "this",
      "can",
      "implemented",
      "manually",
      "with"
    ],
    "category": "hooks"
  }
]
