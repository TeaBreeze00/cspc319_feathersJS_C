[
  {
    "id": "v5-doc-022",
    "title": "Hooks Overview",
    "content": "# Hooks\n\nHooks are pluggable middleware functions that can be registered **around**, **before**, **after** or on **error**(s) of a [service method](./services.md). Multiple hook functions can be chained to create complex work-flows. A hook is **transport independent**, which means it does not matter if it has been called internally on the server, through HTTP(S) (REST), websockets or any other transport Feathers supports. They are also service agnostic, meaning they can be used with ​**any**​ service regardless of whether they use a database or not.\n\nHooks are commonly used to handle things like permissions, validation, logging, [authentication](./authentication/hook.md), [data schemas and resolvers](./schema/index.md), sending notifications and more. This pattern keeps your application logic flexible, composable, and easier to trace through and debug. For more information about the design patterns behind hooks see [this blog post](https://blog.feathersjs.com/api-service-composition-with-hooks-47af13aa6c01).\n\n## Quick Example\n\nThe following example logs the runtime of any service method on the `messages` service and adds `createdAt` property before saving the data to the database:\n\n```ts\nimport { feathers, type HookContext, type NextFunction } from '@feathersjs/feathers'\n\nconst app = feathers()\n\napp.service('messages').hooks({\n  around: {\n    all: [\n      // A hook that wraps around all other hooks and the service method\n      // logging the total runtime of a successful call\n      async (context: HookContext, next: NextFunction) => {\n        const startTime = Date.now()\n\n        await next()\n\n        console.log(`Method ${context.method} on ${context.path} took ${Date.now() - startTime}ms`)\n      }\n    ]\n  },\n  before: {\n    create: [\n      async (context: HookContext) => {\n        context.data = {\n          ...context.data,\n          createdAt: Date.now()\n        }\n      }\n    ]\n  }\n})\n```\n\n\n\n## Hook functions\n\n### before, after and error\n\n`before`, `after` and `error` hook functions are functions that are `async` or return a promise and take the [hook context](#hook-context) as the parameter and return nothing or throw an error.\n\n```ts\nimport { HookContext } from '../declarations'\n\nexport const hookFunction = async (context: HookContext) => {\n  // Do things here\n}\n```\n\nFor more information see the [hook flow](#hook-flow) section.\n\n### around\n\n`around` hooks are a special kind of hook that allow to control the entire `before`, `after` and `error` flow in a single function. They are a Feathers specific version of the generic [@feathersjs/hooks](https://github.com/feathersjs/hooks). An `around` hook is an `async` function that accepts two arguments:\n\n- The [hook context](#hook-context)\n- An asynchronous `next` function. Somewhere in the body of the hook function, there is a call to `await next()`, which calls the `next` hooks OR the original function if all other hooks have run.\n\nIn its simplest form, an around hook looks like this:\n\n```js\nimport { HookContext, NextFunction } from '../declarations'\n\nexport const myAfoundHook = async (context: HookContext, next: NextFunction) => {\n  try {\n    // Code before `await next()` runs before the main function\n    await next()\n    // Code after `await next()` runs after the main function.\n  } catch (error) {\n    // Do things on error\n  } finally {\n    // Do things always\n  }\n}\n```\n\nAny around hook can be wrapped around another function. Calling `await next()` will either call the next hook in the chain or the service method if all other hooks have run.\n\n## Hook flow\n\nIn general, hooks are executed in the order [they are registered](#registering-hooks) with `around` hooks running first:\n\n- `around` hooks (before `await next()`)\n- `before` hooks\n- service method\n- `after` hooks\n- `around` hooks (after `await next()`)\n\nNote that since `around` hooks wrap **around** everything, the first hook to run will be the last to execute its code after `await next()`. This is reverse of the order `aft\n\n[... content truncated for knowledge base ...]",
    "version": "v5",
    "tokens": [
      "hooks",
      "overview",
      "pluggable",
      "middleware",
      "functions",
      "registered",
      "around",
      "error",
      "service",
      "method",
      "services",
      "md",
      "multiple",
      "hook",
      "chained",
      "create",
      "complex",
      "work",
      "flows",
      "transport",
      "independent",
      "means",
      "matter",
      "if",
      "called",
      "internally",
      "server",
      "http",
      "rest",
      "websockets",
      "feathers",
      "supports",
      "also",
      "agnostic",
      "meaning",
      "used",
      "regardless",
      "whether",
      "use",
      "database",
      "commonly",
      "handle",
      "things",
      "like",
      "permissions",
      "validation",
      "logging",
      "authentication",
      "data",
      "schemas",
      "resolvers",
      "schema",
      "index",
      "sending",
      "notifications",
      "pattern",
      "keeps",
      "application",
      "logic",
      "flexible",
      "composable",
      "easier",
      "trace",
      "debug",
      "information",
      "design",
      "patterns",
      "behind",
      "see",
      "blog",
      "post",
      "https",
      "feathersjs",
      "com",
      "api",
      "composition",
      "47af13aa6c01",
      "quick",
      "example",
      "following",
      "logs",
      "runtime",
      "messages",
      "adds",
      "createdat",
      "property",
      "saving",
      "ts",
      "import",
      "type",
      "hookcontext",
      "nextfunction",
      "const",
      "app",
      "wraps",
      "total",
      "successful",
      "call",
      "async",
      "context",
      "next",
      "starttime",
      "date",
      "now",
      "await",
      "console",
      "log",
      "path",
      "took",
      "ms",
      "return",
      "promise",
      "take",
      "parameter",
      "nothing",
      "throw",
      "declarations",
      "export",
      "hookfunction",
      "flow",
      "section",
      "special",
      "kind",
      "allow",
      "control",
      "entire",
      "single",
      "function",
      "specific",
      "version",
      "generic",
      "github",
      "accepts",
      "two",
      "arguments",
      "asynchronous",
      "somewhere",
      "body",
      "calls",
      "original",
      "run",
      "simplest",
      "form",
      "looks",
      "js",
      "myafoundhook",
      "try",
      "code",
      "runs",
      "main",
      "catch",
      "finally",
      "always",
      "wrapped",
      "another",
      "calling",
      "chain",
      "general",
      "executed",
      "order",
      "registering",
      "running",
      "first",
      "note",
      "since",
      "wrap",
      "everything",
      "last",
      "execute",
      "reverse",
      "aft",
      "content",
      "truncated",
      "knowledge",
      "base"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "before",
      "after",
      "around",
      "error",
      "middleware"
    ]
  },
  {
    "id": "v5-doc-023",
    "title": "Hooks: Hook functions",
    "content": "Hook functions\n\n### before, after and error\n\n`before`, `after` and `error` hook functions are functions that are `async` or return a promise and take the [hook context](#hook-context) as the parameter and return nothing or throw an error.\n\n```ts\nimport { HookContext } from '../declarations'\n\nexport const hookFunction = async (context: HookContext) => {\n  // Do things here\n}\n```\n\nFor more information see the [hook flow](#hook-flow) section.\n\n### around\n\n`around` hooks are a special kind of hook that allow to control the entire `before`, `after` and `error` flow in a single function. They are a Feathers specific version of the generic [@feathersjs/hooks](https://github.com/feathersjs/hooks). An `around` hook is an `async` function that accepts two arguments:\n\n- The [hook context](#hook-context)\n- An asynchronous `next` function. Somewhere in the body of the hook function, there is a call to `await next()`, which calls the `next` hooks OR the original function if all other hooks have run.\n\nIn its simplest form, an around hook looks like this:\n\n```js\nimport { HookContext, NextFunction } from '../declarations'\n\nexport const myAfoundHook = async (context: HookContext, next: NextFunction) => {\n  try {\n    // Code before `await next()` runs before the main function\n    await next()\n    // Code after `await next()` runs after the main function.\n  } catch (error) {\n    // Do things on error\n  } finally {\n    // Do things always\n  }\n}\n```\n\nAny around hook can be wrapped around another function. Calling `await next()` will either call the next hook in the chain or the service method if all other hooks have run.\n\n",
    "version": "v5",
    "tokens": [
      "hooks",
      "hook",
      "functions",
      "error",
      "async",
      "return",
      "promise",
      "take",
      "context",
      "parameter",
      "nothing",
      "throw",
      "ts",
      "import",
      "hookcontext",
      "declarations",
      "export",
      "const",
      "hookfunction",
      "things",
      "information",
      "see",
      "flow",
      "section",
      "around",
      "special",
      "kind",
      "allow",
      "control",
      "entire",
      "single",
      "function",
      "feathers",
      "specific",
      "version",
      "generic",
      "feathersjs",
      "https",
      "github",
      "com",
      "accepts",
      "two",
      "arguments",
      "asynchronous",
      "next",
      "somewhere",
      "body",
      "call",
      "await",
      "calls",
      "original",
      "if",
      "run",
      "simplest",
      "form",
      "looks",
      "like",
      "js",
      "nextfunction",
      "myafoundhook",
      "try",
      "code",
      "runs",
      "main",
      "catch",
      "finally",
      "always",
      "wrapped",
      "another",
      "calling",
      "chain",
      "service",
      "method"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "hook",
      "functions"
    ]
  },
  {
    "id": "v5-doc-024",
    "title": "Hooks: Hook flow",
    "content": "Hook flow\n\nIn general, hooks are executed in the order [they are registered](#registering-hooks) with `around` hooks running first:\n\n- `around` hooks (before `await next()`)\n- `before` hooks\n- service method\n- `after` hooks\n- `around` hooks (after `await next()`)\n\nNote that since `around` hooks wrap **around** everything, the first hook to run will be the last to execute its code after `await next()`. This is reverse of the order `after` hooks execute.\n\nThe hook flow can be affected as follows.\n\n### Throwing an error\n\nWhen an error is thrown (or the promise is rejected), all subsequent hooks - and the service method call if it didn't run already - will be skipped and only the error hooks will run.\n\nThe following example throws an error when the text for creating a new message is empty. You can also create very similar hooks to use your Node validation library of choice.\n\n```ts\napp.service('messages').hooks({\n  before: {\n    create: [\n      async (context: HookContext) => {\n        if (context.data.text.trim() === '') {\n          throw new Error('Message text can not be empty')\n        }\n      }\n    ]\n  }\n})\n```\n\n### Setting `context.result`\n\nWhen `context.result` is set in an `around` hook before calling `await next()` or in a `before` hook, the original [service method](./services.md) call will be skipped. All other hooks will still execute in their normal order. The following example always returns the currently [authenticated user](./authentication/service.md) instead of the actual user for all `get` method calls:\n\n```js\napp.service('users').hooks({\n  before: {\n    get: [\n      async (context: HookContext) => {\n        // Never call the actual users service\n        // just use the authenticated user\n        context.result = context.params.user\n      }\n    ]\n  }\n})\n```\n\n",
    "version": "v5",
    "tokens": [
      "hooks",
      "hook",
      "flow",
      "general",
      "executed",
      "order",
      "registered",
      "registering",
      "around",
      "running",
      "first",
      "await",
      "next",
      "service",
      "method",
      "note",
      "since",
      "wrap",
      "everything",
      "run",
      "last",
      "execute",
      "code",
      "reverse",
      "affected",
      "follows",
      "throwing",
      "error",
      "thrown",
      "promise",
      "rejected",
      "subsequent",
      "call",
      "if",
      "didn",
      "already",
      "skipped",
      "following",
      "example",
      "throws",
      "text",
      "creating",
      "new",
      "message",
      "empty",
      "also",
      "create",
      "similar",
      "use",
      "node",
      "validation",
      "library",
      "choice",
      "ts",
      "app",
      "messages",
      "async",
      "context",
      "hookcontext",
      "data",
      "trim",
      "throw",
      "setting",
      "result",
      "set",
      "calling",
      "original",
      "services",
      "md",
      "still",
      "normal",
      "always",
      "returns",
      "currently",
      "authenticated",
      "user",
      "authentication",
      "instead",
      "actual",
      "get",
      "calls",
      "js",
      "users",
      "never",
      "params"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "hook",
      "flow"
    ]
  },
  {
    "id": "v5-doc-025",
    "title": "Hooks: Hook context",
    "content": "Hook context\n\nThe hook `context` is passed to a hook function and contains information about the service method call. It has **read only** properties that should not be modified and **_writeable_** properties that can be changed for subsequent hooks.\n\n\n\n\n\n### `context.app`\n\n`context.app` is a _read only_ property that contains the [Feathers application object](./application.md). This can be used to retrieve other services (via `context.app.service('name')`) or configuration values.\n\n### `context.service`\n\n`context.service` is a _read only_ property and contains the service this hook currently runs on.\n\n### `context.path`\n\n`context.path` is a _read only_ property and contains the service name (or path) without leading or trailing slashes.\n\n### `context.method`\n\n`context.method` is a _read only_ property with the name of the [service method](./services.md) (`find`, `get`, `create`, `update`, `patch`, `remove`).\n\n### `context.type`\n\n`context.type` is a _read only_ property with the hook type (one of `around`, `before`, `after` or `error`).\n\n### `context.params`\n\n`context.params` is a **writeable** property that contains the [service method](./services.md) parameters (including `params.query`). For more information see the [service params documentation](./services.md#params).\n\n### `context.id`\n\n`context.id` is a **writeable** property and the `id` for a `get`, `remove`, `update` and `patch` service method call. For `remove`, `update` and `patch`, `context.id` can also be `null` when modifying multiple entries. In all other cases it will be `undefined`.\n\n### `context.data`\n\n`context.data` is a **writeable** property containing the data of a `create`, `update` and `patch` service method call.\n\n\n\n### `context.error`\n\n`context.error` is a **writeable** property with the error object that was thrown in a failed method call. It can be modified to change the error that is returned at the end.\n\n\n\n### `context.result`\n\n`context.result` is a **writeable** property containing the result of the successful service method call. It is only available in `after` hooks. `context.result` can also be set in\n\n- An `around` or `before` hook to skip the actual service method (database) call\n- An `error` hook to swallow the error and return a result instead\n\n\n\n### `context.dispatch`\n\n`context.dispatch` is a **writeable, optional** property and contains a \"safe\" version of the data that should be sent to any client. If `context.dispatch` has not been set `context.result` will be sent to the client instead. `context.dispatch` only affects the data sent through a Feathers Transport like [REST](./express.md) or [Socket.io](./socketio.md). An internal method call will still get the data set in `context.result`.\n\n\n\n### `context.http`\n\n`context.http` is a **writeable, optional** property that allows customizing HTTP response specific properties. The following properties can be set:\n\n- `context.http.status` - Sets the [HTTP status code](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) that should be returned. Usually the most appropriate status code will be picked automatically but there are cases where it needs to be customized.\n- `context.http.headers` - An object with additional HTTP response headers\n- `context.http.location` - Setting this property will trigger a redirect for HTTP requests.\n\n\n\n### `context.event`\n\n`context.event` is a **writeable, optional** property that allows service events to be skipped by setting it to `null`\n\n### `context.toJSON()`\n\n`context.toJSON()` returns a full object representation of the hook context and all its properties.\n\n",
    "version": "v5",
    "tokens": [
      "hooks",
      "hook",
      "context",
      "passed",
      "function",
      "contains",
      "information",
      "service",
      "method",
      "call",
      "read",
      "properties",
      "modified",
      "writeable",
      "changed",
      "subsequent",
      "app",
      "property",
      "feathers",
      "application",
      "object",
      "md",
      "used",
      "retrieve",
      "services",
      "via",
      "name",
      "configuration",
      "values",
      "currently",
      "runs",
      "path",
      "without",
      "leading",
      "trailing",
      "slashes",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "type",
      "one",
      "around",
      "error",
      "params",
      "parameters",
      "including",
      "query",
      "see",
      "documentation",
      "id",
      "also",
      "null",
      "modifying",
      "multiple",
      "entries",
      "cases",
      "undefined",
      "data",
      "containing",
      "thrown",
      "failed",
      "change",
      "returned",
      "end",
      "result",
      "successful",
      "available",
      "set",
      "skip",
      "actual",
      "database",
      "swallow",
      "return",
      "instead",
      "dispatch",
      "optional",
      "safe",
      "version",
      "sent",
      "client",
      "if",
      "affects",
      "transport",
      "like",
      "rest",
      "express",
      "socket",
      "io",
      "socketio",
      "internal",
      "still",
      "http",
      "allows",
      "customizing",
      "response",
      "specific",
      "following",
      "status",
      "sets",
      "code",
      "https",
      "www",
      "w3",
      "org",
      "protocols",
      "rfc2616",
      "sec10",
      "html",
      "usually",
      "appropriate",
      "picked",
      "automatically",
      "needs",
      "customized",
      "headers",
      "additional",
      "location",
      "setting",
      "trigger",
      "redirect",
      "requests",
      "event",
      "events",
      "skipped",
      "tojson",
      "returns",
      "full",
      "representation"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "hook",
      "context"
    ]
  },
  {
    "id": "v5-doc-026",
    "title": "Hooks: Registering hooks",
    "content": "Registering hooks\n\nHook functions are registered on a service through the `app.service(<servicename>).hooks(hooks)` method. The most commonly used registration format is\n\n```js\n{\n  [type]: { // around, before, after or error\n    all: [\n      // list of hooks that should run for every method here\n    ],\n    [methodName]: [\n      // list of method hooks here\n    ]\n  }\n}\n```\n\nThis means usual hook registration looks like this:\n\n```ts\n// The standard all at once way (also used by the generator)\n// an array of functions per service method name (and for `all` methods)\napp.service('servicename').hooks({\n  around: {\n    all: [\n      async (context: HookContext, next: NextFunction) => {\n        console.log('around all hook ran')\n        await next()\n      }\n    ],\n    find: [\n      /* other hook functions here */\n    ],\n    get: [],\n    create: [],\n    update: [],\n    patch: [],\n    remove: [],\n    // Custom methods use hooks as well\n    myCustomMethod: []\n  },\n  before: {\n    all: [async (context: HookContext) => console.log('before all hook ran')],\n    find: [\n      /* other hook functions here */\n    ],\n    get: []\n    // ...etc\n  },\n  after: {\n    find: [async (context: HookContext) => console.log('after find hook ran')]\n  },\n  error: {}\n})\n```\n\n\n\nSince around hooks offer the same functionality as `before`, `after` and `error` hooks at the same time they can also be registered without a nested object:\n\n```ts\nimport { HookContext, NextFunction } from './declarations'\n\n// Passing an array of around hooks that run for every method\napp.service('servicename').hooks([\n  async (context: HookContext, next: NextFunction) => {\n    console.log('around all hook ran')\n    await next()\n  }\n])\n\n// Passing an object with method names and a list of around hooks\napp.service('servicename').hooks({\n  get: [\n    async (context: HookContext, next: NextFunction) => {\n      console.log('around get hook ran')\n      await next()\n    }\n  ],\n  create: [],\n  update: [],\n  patch: [],\n  remove: [],\n  myCustomMethod: []\n})\n```\n\n",
    "version": "v5",
    "tokens": [
      "hooks",
      "registering",
      "hook",
      "functions",
      "registered",
      "service",
      "app",
      "servicename",
      "method",
      "commonly",
      "used",
      "registration",
      "format",
      "js",
      "type",
      "around",
      "error",
      "list",
      "run",
      "methodname",
      "means",
      "usual",
      "looks",
      "like",
      "ts",
      "standard",
      "way",
      "also",
      "generator",
      "array",
      "per",
      "name",
      "methods",
      "async",
      "context",
      "hookcontext",
      "next",
      "nextfunction",
      "console",
      "log",
      "ran",
      "await",
      "find",
      "get",
      "create",
      "update",
      "patch",
      "remove",
      "custom",
      "use",
      "well",
      "mycustommethod",
      "etc",
      "since",
      "offer",
      "functionality",
      "time",
      "without",
      "nested",
      "object",
      "import",
      "declarations",
      "passing",
      "names"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "registering",
      "hooks"
    ]
  },
  {
    "id": "v5-doc-027",
    "title": "Hooks: Application hooks",
    "content": "Application hooks\n\n### Service hooks\n\nTo add hooks to every service `app.hooks(hooks)` can be used. Application hooks are [registered in the same format as service hooks](#registering-hooks) and also work exactly the same. Note when application hooks will be executed:\n\n- `around` application hook will run around all other hooks\n- `before` application hooks will always run _before_ all service `before` hooks\n- `after` application hooks will always run _after_ all service `after` hooks\n- `error` application hooks will always run _after_ all service `error` hooks\n\nHere is an example for a very useful application hook that logs every service method error with the service and method name as well as the error stack.\n\n```ts\nimport { HookContext } from './declarations'\n\napp.hooks({\n  error: {\n    all: [\n      async (context: HookContext) => {\n        console.error(`Error in '${context.path}' service method '${context.method}'`, context.error.stack)\n      }\n    ]\n  }\n})\n```\n\n### Setup and teardown\n\nA special kind of application hooks are [app.setup](./application.md#setupserver) and [app.teardown](./application.md#teardownserver) hooks. They are around hooks that can be used to initialize database connections etc. and only run once when the application starts or shuts down. Setup and teardown hooks only have `context.app` and `context.server` available in the hook context.\n\n```ts\nimport { MongoClient } from 'mongodb'\n\napp.hooks({\n  setup: [\n    async (context: HookContext, next: NextFunction) => {\n      // E.g. wait for MongoDB connection to complete\n      await context.app.get('mongoClient').connect()\n      await next()\n    }\n  ],\n  teardown: [\n    async (context: HookContext, next: NextFunction) => {\n      // Close MongoDB connection\n      await context.app.get('mongoClient').close()\n      await next()\n    }\n  ]\n})\n```",
    "version": "v5",
    "tokens": [
      "hooks",
      "application",
      "service",
      "add",
      "app",
      "used",
      "registered",
      "format",
      "registering",
      "also",
      "work",
      "exactly",
      "note",
      "executed",
      "around",
      "hook",
      "run",
      "always",
      "error",
      "example",
      "useful",
      "logs",
      "method",
      "name",
      "well",
      "stack",
      "ts",
      "import",
      "hookcontext",
      "declarations",
      "async",
      "context",
      "console",
      "path",
      "setup",
      "teardown",
      "special",
      "kind",
      "md",
      "setupserver",
      "teardownserver",
      "initialize",
      "database",
      "connections",
      "etc",
      "starts",
      "shuts",
      "server",
      "available",
      "mongoclient",
      "mongodb",
      "next",
      "nextfunction",
      "wait",
      "connection",
      "complete",
      "await",
      "get",
      "connect",
      "close"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "application",
      "hooks"
    ]
  },
  {
    "id": "v5-doc-028",
    "title": "Hooks: before, after and error",
    "content": "before, after and error\n\n`before`, `after` and `error` hook functions are functions that are `async` or return a promise and take the [hook context](#hook-context) as the parameter and return nothing or throw an error.\n\n```ts\nimport { HookContext } from '../declarations'\n\nexport const hookFunction = async (context: HookContext) => {\n  // Do things here\n}\n```\n\nFor more information see the [hook flow](#hook-flow) section.\n\n",
    "version": "v5",
    "tokens": [
      "hooks",
      "error",
      "hook",
      "functions",
      "async",
      "return",
      "promise",
      "take",
      "context",
      "parameter",
      "nothing",
      "throw",
      "ts",
      "import",
      "hookcontext",
      "declarations",
      "export",
      "const",
      "hookfunction",
      "things",
      "information",
      "see",
      "flow",
      "section"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "error"
    ]
  },
  {
    "id": "v5-doc-029",
    "title": "Hooks: around",
    "content": "around\n\n`around` hooks are a special kind of hook that allow to control the entire `before`, `after` and `error` flow in a single function. They are a Feathers specific version of the generic [@feathersjs/hooks](https://github.com/feathersjs/hooks). An `around` hook is an `async` function that accepts two arguments:\n\n- The [hook context](#hook-context)\n- An asynchronous `next` function. Somewhere in the body of the hook function, there is a call to `await next()`, which calls the `next` hooks OR the original function if all other hooks have run.\n\nIn its simplest form, an around hook looks like this:\n\n```js\nimport { HookContext, NextFunction } from '../declarations'\n\nexport const myAfoundHook = async (context: HookContext, next: NextFunction) => {\n  try {\n    // Code before `await next()` runs before the main function\n    await next()\n    // Code after `await next()` runs after the main function.\n  } catch (error) {\n    // Do things on error\n  } finally {\n    // Do things always\n  }\n}\n```\n\nAny around hook can be wrapped around another function. Calling `await next()` will either call the next hook in the chain or the service method if all other hooks have run.\n\n## Hook flow\n\nIn general, hooks are executed in the order [they are registered](#registering-hooks) with `around` hooks running first:\n\n- `around` hooks (before `await next()`)\n- `before` hooks\n- service method\n- `after` hooks\n- `around` hooks (after `await next()`)\n\nNote that since `around` hooks wrap **around** everything, the first hook to run will be the last to execute its code after `await next()`. This is reverse of the order `after` hooks execute.\n\nThe hook flow can be affected as follows.\n\n",
    "version": "v5",
    "tokens": [
      "hooks",
      "around",
      "special",
      "kind",
      "hook",
      "allow",
      "control",
      "entire",
      "error",
      "flow",
      "single",
      "function",
      "feathers",
      "specific",
      "version",
      "generic",
      "feathersjs",
      "https",
      "github",
      "com",
      "async",
      "accepts",
      "two",
      "arguments",
      "context",
      "asynchronous",
      "next",
      "somewhere",
      "body",
      "call",
      "await",
      "calls",
      "original",
      "if",
      "run",
      "simplest",
      "form",
      "looks",
      "like",
      "js",
      "import",
      "hookcontext",
      "nextfunction",
      "declarations",
      "export",
      "const",
      "myafoundhook",
      "try",
      "code",
      "runs",
      "main",
      "catch",
      "things",
      "finally",
      "always",
      "wrapped",
      "another",
      "calling",
      "chain",
      "service",
      "method",
      "general",
      "executed",
      "order",
      "registered",
      "registering",
      "running",
      "first",
      "note",
      "since",
      "wrap",
      "everything",
      "last",
      "execute",
      "reverse",
      "affected",
      "follows"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "around"
    ]
  },
  {
    "id": "v5-doc-030",
    "title": "Hooks: `context.data`",
    "content": "`context.data`\n\n`context.data` is a **writeable** property containing the data of a `create`, `update` and `patch` service method call.\n\n\n\n",
    "version": "v5",
    "tokens": [
      "hooks",
      "context",
      "data",
      "writeable",
      "property",
      "containing",
      "create",
      "update",
      "patch",
      "service",
      "method",
      "call"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "context",
      "data"
    ]
  },
  {
    "id": "v5-doc-031",
    "title": "Hooks: `context.result`",
    "content": "`context.result`\n\n`context.result` is a **writeable** property containing the result of the successful service method call. It is only available in `after` hooks. `context.result` can also be set in\n\n- An `around` or `before` hook to skip the actual service method (database) call\n- An `error` hook to swallow the error and return a result instead\n\n\n\n",
    "version": "v5",
    "tokens": [
      "hooks",
      "context",
      "result",
      "writeable",
      "property",
      "containing",
      "successful",
      "service",
      "method",
      "call",
      "available",
      "also",
      "set",
      "around",
      "hook",
      "skip",
      "actual",
      "database",
      "error",
      "swallow",
      "return",
      "instead"
    ],
    "category": "hooks",
    "source": {
      "path": "api/hooks.md"
    },
    "tags": [
      "hooks",
      "context",
      "result"
    ]
  }
]