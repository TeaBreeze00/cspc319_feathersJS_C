[
  {
    "id": "v5-guides-cli-default.json",
    "title": "Application configuration",
    "content": "Application configuration | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Application configuration ​\nA generated application uses the configuration module to load configuration information based on the environment. It is based on the battle-tested and widely used node-config and loads configuration settings so that they are available via app.get(). On application startup, the configuration will be validated against the configuration schema.ImportantFor more information on application configuration and schemas see the configuration API documentation.\n## Environments ​\nThe `NODE_ENV` environment variable determines which configuration file is used. For example, setting `NODE_ENV=development` (in a single command e.g. as `NODE_ENV=development npm run dev`) will first load `config/default.json` and then merge it with `config/development.json`. If no environment is set, `config/default.json` will be used.\n## Default configuration ​\nThe application uses the following configuration values.\n### host, port, public ​\nThese options are used directly in the generated application`host` - Is the hostname of the API server\n• `port` - The port it listens on\n• `public` - The name of the folder static assets are hosted in\n\n### paginate ​\n\n`paginate` sets the default and maximum page size when using pagination with a database service.\n\njson\n```\n{\n  \"paginate\": {\n    \"default\": 10,\n    \"max\": 100\n  }\n}\n```\n\n### origins ​\n\n`origins` contains a list of frontend URLs that requests can be made from. This is used to configure cross origin (CORS) policies and oAuth (Twitter, Facebook etc.) login redirects. For example to develop locally with a create-react-app frontend and deploy to `app.feathersjs.com`:\n\njson\n```\n{\n  \"origins\": [\"http://localhost:3030\", \"http://localhost:5000\", \"https://app.feathersjs.com\"]\n}\n```\n\n### authentication ​\n\n`authentication` contains the configuration for the authentication service and strategies. See the authentication service configuration for more information. For strategy specific settings refer to the jwt, local and oAuth API documentation.\n\n### Databases ​\n\nDepending on the SQL database selected the `` setting contains a `connection` with the database driver package name and a `client` option with the database connection string.\n\njson\n```\n{\n  \"postgresql\": {\n    \"connection\": \"pg\",\n    \"client\": \"postgres://postgres:@localhost:5432/feathers-chat\"\n  }\n}\n```\n\nFor additional configuration see the database connection guide.\n\nWhen selecting MongoDB, the `mongodb` setting contains the MongoDB connection string.\n\n Suggest changes to this page\n\nLast updated: \n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors\n\n feathers \n\n• About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "application",
      "configuration",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "generated",
      "uses",
      "the",
      "module",
      "load",
      "information",
      "based",
      "environment",
      "battle",
      "tested",
      "and",
      "widely",
      "used",
      "node",
      "config",
      "loads",
      "settings",
      "that",
      "they",
      "are",
      "available",
      "via",
      "app",
      "get",
      "startup",
      "will",
      "validated",
      "against",
      "schema",
      "importantfor",
      "more",
      "schemas",
      "see",
      "api",
      "documentation",
      "environments",
      "variable",
      "determines",
      "which",
      "file",
      "for",
      "example",
      "setting",
      "development",
      "single",
      "command",
      "npm",
      "run",
      "dev",
      "first",
      "default",
      "json",
      "then",
      "merge",
      "with",
      "set",
      "following",
      "values",
      "host",
      "port",
      "public",
      "these",
      "options",
      "directly",
      "hostname",
      "server",
      "listens",
      "name",
      "folder",
      "static",
      "assets",
      "hosted",
      "paginate",
      "sets",
      "maximum",
      "page",
      "size",
      "when",
      "using",
      "pagination",
      "database",
      "service",
      "max",
      "origins",
      "contains",
      "list",
      "frontend",
      "urls",
      "requests",
      "can",
      "made",
      "from",
      "this",
      "configure",
      "cross",
      "origin",
      "cors",
      "policies",
      "oauth",
      "twitter",
      "facebook",
      "etc",
      "login",
      "redirects",
      "develop",
      "locally",
      "create",
      "react",
      "deploy",
      "feathersjs",
      "com",
      "http",
      "localhost",
      "https",
      "authentication",
      "strategi"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-guides-cli-custom-environment-variables",
    "title": "Custom Environment Variables",
    "content": "Custom Environment Variables | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Custom Environment Variables ​\nWhile `node-config` used for application configuration recommends to pass environment based configuration as a JSON string in a single `NODE_CONFIG` environment variable, it is also possible to use other environment variables via the `config/custom-environment-variables.json` file which looks like this by default:json\n```\n{\n  \"port\": {\n    \"__name\": \"PORT\",\n    \"__format\": \"number\"\n  },\n  \"host\": \"HOSTNAME\",\n  \"authentication\": {\n    \"secret\": \"FEATHERS_SECRET\"\n  }\n}\n```\nThis sets `app.get('port')` using the `PORT` environment variable (if it is available) parsing it as a number and `app.get('host')` from the `HOSTNAME` environment variable and the authentication secret to the `FEATHERS_SECRET` environment variable.tipSee the node-config custom environment variable documentation for more information.\n## Dotenv ​\nTo add support for dotenv `.env` files run\n```\nnpm install dotenv --save\n```\nAnd update `src/app.ts` as follows:ts\n```\n// dotenv replaces all environmental variables from ~/.env in ~/config/custom-environment-variables.json\nimport * as dotenv from 'dotenv'\ndotenv.config()\n\n// or for ES6\n\nimport 'dotenv/config';\n\nimport configuration from '@feathersjs/configuration'\n```\nimportant`dotenv.config()` needs to run before `import configuration from '@feathersjs/configuration'` Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "custom",
      "environment",
      "variables",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "while",
      "node",
      "config",
      "used",
      "for",
      "application",
      "configuration",
      "recommends",
      "pass",
      "based",
      "json",
      "string",
      "single",
      "variable",
      "also",
      "possible",
      "use",
      "other",
      "via",
      "the",
      "file",
      "which",
      "looks",
      "like",
      "this",
      "default",
      "port",
      "number",
      "host",
      "hostname",
      "authentication",
      "secret",
      "sets",
      "app",
      "get",
      "using",
      "available",
      "parsing",
      "and",
      "from",
      "tipsee",
      "documentation",
      "more",
      "information",
      "dotenv",
      "add",
      "support",
      "env",
      "files",
      "run",
      "npm",
      "install",
      "save",
      "update",
      "src",
      "follows",
      "replaces",
      "all",
      "environmental",
      "import",
      "es6",
      "feathersjs",
      "important",
      "needs",
      "before",
      "suggest",
      "changes",
      "pagelast",
      "updated",
      "released",
      "under",
      "mit",
      "license",
      "copyright",
      "contributors",
      "about",
      "philosophy",
      "comparison",
      "ecosystem",
      "learn",
      "guides",
      "api",
      "blog",
      "become",
      "backer",
      "find",
      "help",
      "github",
      "issues"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-guides-cli-app",
    "title": "Application",
    "content": "Application | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Application ​\nThe `src/app.ts` file is the main file where the Feathers application gets initialized and wired up with a Feathers transport.\n## Transports ​\nThe available transports are Koa or Express for HTTP and Socket.io for real-time functionality. For both, Koa and Express, the Feathers application (`app` object) will also be fully compatible with the respective framework. For both frameworks, additional required middleware will be registered in the application file. More information can be found in the linked API documentation.\n## Configure functions ​\nThe Feathers application does not use a complicated dependency injection mechanism. Instead, the application is wired together using configure functions to split things up into individual files. They are functions that are exported from a file and that take the Feathers app object and then use it to e.g. register services. Those functions are then passed to app.configure.For example, have a look at the following files:`src/services/index.ts` looks like this:ts\n```\nimport type { Application } from '../declarations'\nimport { user } from './users/users'\n\nexport const services = (app: Application) => {\n  app.configure(user)\n  // All services will be registered here\n}\n```\nIt uses another configure function exported from `src/services/users/users.ts`. The export from `src/services/index.js` is in turn used in `src/app.ts` as:ts\n```\n// ...\nimport { services } from './services'\n\n// ...\napp.configure(authentication)\napp.configure(services)\n// ...\n```\nThis is how the generator splits things up into separate files and any documentation example that uses the `app` object can be used in a configure function. You can create your own files that export a configure function and `require`/`import` and `app.configure` them.infoKeep in mind that the order in which configure functions are called might matter, e.g. if it is using a service, that service has to be registered first. Configure functions are not asynchronous. Any asynchronous operations should be done in application setup hooks.\n## Application hooks ​\nThe application file also includes a section to set up application hooks which are hooks that run for every service. In our case, the `logErrorHook` to log any service errors has already been registered:ts\n```\n// Register hooks that run on all service methods\napp.hooks({\n  around: {\n    all: [logErrorHook]\n  },\n  before: {},\n  after: {},\n  error: {}\n})\n```\nFollowing that is the special setup and teardown hook section to register hooks that run once when the application starts or shuts down. This can be used to e.g. set dynamic configuration values.ts\n```\n// Register application setup and teardown hooks here\napp.hooks({\n  setup: [],\n  teardown: []\n})\n```\n\n## Tests, jobs and SSR ​\nThe `app` file can be imported like any other Node module. This means it can be used directly in tests, scheduled jobs or server side rendering without having to start a separate server instance. For example, the unit tests import the application like this:ts\n```\nimport assert from 'assert'\nimport { app } from '../../src/app'\n\ndescribe('messages service', () => {\n  it('registered the service', () => {\n    const service = app.service('messages')\n\n    assert.ok(service, 'Registered the service')\n  })\n})\n```\n Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "application",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "the",
      "src",
      "app",
      "file",
      "main",
      "where",
      "gets",
      "initialized",
      "and",
      "wired",
      "with",
      "transport",
      "transports",
      "available",
      "are",
      "koa",
      "express",
      "for",
      "http",
      "socket",
      "real",
      "time",
      "functionality",
      "both",
      "object",
      "will",
      "also",
      "fully",
      "compatible",
      "respective",
      "framework",
      "frameworks",
      "additional",
      "required",
      "middleware",
      "registered",
      "more",
      "information",
      "can",
      "found",
      "linked",
      "api",
      "documentation",
      "configure",
      "functions",
      "does",
      "not",
      "use",
      "complicated",
      "dependency",
      "injection",
      "mechanism",
      "instead",
      "together",
      "using",
      "split",
      "things",
      "into",
      "individual",
      "files",
      "they",
      "that",
      "exported",
      "from",
      "take",
      "then",
      "register",
      "services",
      "those",
      "passed",
      "example",
      "have",
      "look",
      "following",
      "index",
      "looks",
      "like",
      "this",
      "import",
      "type",
      "declarations",
      "user",
      "users",
      "export",
      "const",
      "all",
      "here",
      "uses",
      "another",
      "function",
      "turn",
      "used",
      "authentication",
      "how",
      "generator",
      "splits",
      "separate",
      "any",
      "you",
      "create",
      "your",
      "own",
      "require",
      "them",
      "infokeep",
      "mind",
      "order",
      "which",
      "called",
      "might",
      "matter"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-guides-cli-client",
    "title": "Client",
    "content": "Client | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Client ​\nA generated application can be used as an npm module that provides a Feathers client. It gives you a fully typed client that can be installed in any TypeScript (e.g. React, VueJS, React Native etc.) application.\n## Local installation ​\nThe application can be linked into a client application by running\n```\nnpm run bundle:client\nnpm link\n```\nThen go to your client side app\n```\ncd path/to/client\nnpm link my-app\n```\n\n## Creating a package ​\nTo create an installable SDK package that does not include any of the server code (other than the shared types) you can run\n```\nnpm run bundle:client\n```\nBy default this will create an `appname-x.x.x.tgz` npm package in the `public/` folder. This package can be installed from a running server via\n```\nnpm install https://myapp.com/appname-x.x.x.tgz\n```\n\n## Usage ​\nOnce installed, the application can be used as follows with Socket.io:ts\n```\nimport io from 'socket.io-client'\nimport socketio from '@feathersjs/socketio-client'\nimport { createClient } from 'my-app'\n\nconst connection = socketio(io('https://myapp.com'))\n\nconst client = createClient(connection)\n```\nAnd like this with a REST client:ts\n```\nimport rest from '@feathersjs/rest-client'\nimport { createClient } from 'my-app'\n\nconst connection = rest('https://myapp.com').fetch(window.fetch.bind(window))\n\nconst client = createClient(connection)\n```\n Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "client",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "generated",
      "application",
      "can",
      "used",
      "npm",
      "module",
      "that",
      "provides",
      "gives",
      "you",
      "fully",
      "typed",
      "installed",
      "any",
      "typescript",
      "react",
      "vuejs",
      "native",
      "etc",
      "local",
      "installation",
      "the",
      "linked",
      "into",
      "running",
      "run",
      "bundle",
      "link",
      "then",
      "your",
      "side",
      "app",
      "path",
      "creating",
      "package",
      "create",
      "installable",
      "sdk",
      "does",
      "not",
      "include",
      "server",
      "code",
      "other",
      "than",
      "shared",
      "types",
      "default",
      "this",
      "will",
      "appname",
      "tgz",
      "public",
      "folder",
      "from",
      "via",
      "install",
      "https",
      "myapp",
      "com",
      "usage",
      "once",
      "follows",
      "with",
      "socket",
      "import",
      "socketio",
      "feathersjs",
      "createclient",
      "const",
      "connection",
      "and",
      "like",
      "rest",
      "fetch",
      "window",
      "bind",
      "suggest",
      "changes",
      "pagelast",
      "updated",
      "released",
      "under",
      "mit",
      "license",
      "copyright",
      "contributors",
      "about",
      "philosophy",
      "comparison",
      "ecosystem",
      "learn",
      "guides",
      "api",
      "blog",
      "become",
      "backer",
      "find",
      "help",
      "github",
      "issues"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-guides-cli-configuration",
    "title": "feathers",
    "content": "feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n### Configuration Schemas ​\nA generated application comes with a schema that validates the initial configuration when the application is started. This makes it much easier to catch configuration errors early which can otherwise be especially difficult to debug in remote environments.The configuration schema definition can be found in `configuration.ts`. It is used as a configuration schema and loads some default schemas for authentication and database connection configuration and adds values for `host`, `port` and the `public` hosted file folder. The types of this schema are also used for `app.get()` and `app.set()` typings. The initial configuration schema will be validated on application startup when calling `app.listen()` or `app.setup()`. Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "configuration",
      "schemas",
      "generated",
      "application",
      "comes",
      "with",
      "schema",
      "that",
      "validates",
      "the",
      "initial",
      "when",
      "started",
      "this",
      "makes",
      "much",
      "easier",
      "catch",
      "errors",
      "early",
      "which",
      "can",
      "otherwise",
      "especially",
      "difficult",
      "debug",
      "remote",
      "environments",
      "definition",
      "found",
      "used",
      "and",
      "loads",
      "some",
      "default",
      "for",
      "authentication",
      "database",
      "connection",
      "adds",
      "values",
      "host",
      "port",
      "public",
      "hosted",
      "file",
      "folder",
      "types",
      "are",
      "also",
      "app",
      "get",
      "set",
      "typings",
      "will",
      "validated",
      "startup",
      "calling",
      "listen",
      "setup",
      "suggest",
      "changes",
      "pagelast",
      "updated",
      "released",
      "under",
      "mit",
      "license",
      "copyright",
      "feathersjs",
      "contributors",
      "about",
      "philosophy",
      "comparison",
      "ecosystem",
      "learn",
      "guides",
      "api",
      "blog",
      "become",
      "backer",
      "find",
      "help",
      "github",
      "issues"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-guides-cli-declarations",
    "title": "TypeScript",
    "content": "TypeScript | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# TypeScript ​\nThe main file for application specific TypeScript declarations can be found at `src/declarations.ts`.\n## Compilation ​\nIn order to compile and start the application use\n```\nnpm run compile\nnpm start\n```\nFor development with live reload use\n```\nnpm run dev\n```\nImportantTo get the latest types in the client and any time before `npm start`, `npm run compile` needs to run.\n## Configuration Types ​\nThe `Configuration` interface defines the types for app.get and app.set. It is extended from the type inferred from the configuration schema. Since you can store anything global to the application in `app.get` and `app.set`, you can add additional types that are not part of the initial application configuration here.ts\n```\n// The types for app.get(name) and app.set(name)\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Configuration extends ApplicationConfiguration {\n  startupTime: Date\n}\n```\nImportantBoth `Configuration` and `ServiceTypes` need to be declared as an `interface` (even if it is empty) so they can be extended via `declare module` in other files. Do not remove the `eslint-disable-next-line` comments.\n## Service Types ​\nThe `ServiceTypes` interface contains a mapping of all service paths to their service type so that app.use and app.service use the correct type.ts\n```\n// A mapping of service names to types. Will be extended in service files.\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ServiceTypes {}\n```\nUsually the `ServiceTypes` interface is not modified directly in this file but instead extended via `declare module` in the files where the services are registered. This usually looks like this:ts\n```\n// Add this service to the service type index\ndeclare module '../../declarations' {\n  interface ServiceTypes {\n    users: UserService\n  }\n}\n```\n\n## Application ​\nThe `Application` interface is the type for the main app object using the ServiceTypes interface as the service index and ConfigurationTypes for `app.get` and `app.set`.ts\n```\n// The application instance type that will be used everywhere else\nexport type Application = FeathersApplication\n```\nImportantAlways use `import { Application } from './declarations'` to get the proper service and configuration typings. You normally do not need to use `import { Application } from '@feathersjs/feathers'` directly.\n## Hook Context ​\nThe `HookContext` type exports a hook context type with the `Application` and a generic service type `S`.ts\n```\n// The context for hook functions - can be typed with a service class\nexport type HookContext = FeathersHookContext\n```\nUse `HookContext` to get the full hook context for a service.\n## Services and Params ​\nSee the services chapter for more information on service and parameter typings.dangerPlease pick TypeScript as the Code language in the main menu dropdown. Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "typescript",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "the",
      "main",
      "file",
      "for",
      "application",
      "specific",
      "declarations",
      "can",
      "found",
      "src",
      "compilation",
      "order",
      "compile",
      "and",
      "start",
      "use",
      "npm",
      "run",
      "development",
      "with",
      "live",
      "reload",
      "dev",
      "importantto",
      "get",
      "latest",
      "types",
      "client",
      "any",
      "time",
      "before",
      "needs",
      "configuration",
      "interface",
      "defines",
      "app",
      "set",
      "extended",
      "from",
      "type",
      "inferred",
      "schema",
      "since",
      "you",
      "store",
      "anything",
      "global",
      "add",
      "additional",
      "that",
      "are",
      "not",
      "part",
      "initial",
      "here",
      "name",
      "eslint",
      "disable",
      "next",
      "line",
      "empty",
      "export",
      "extends",
      "applicationconfiguration",
      "startuptime",
      "date",
      "importantboth",
      "servicetypes",
      "need",
      "declared",
      "even",
      "they",
      "via",
      "declare",
      "module",
      "other",
      "files",
      "remove",
      "comments",
      "service",
      "contains",
      "mapping",
      "all",
      "paths",
      "their",
      "correct",
      "names",
      "will",
      "usually",
      "modified",
      "directly",
      "this",
      "but",
      "instead",
      "where",
      "services",
      "registered",
      "looks",
      "like",
      "index",
      "users",
      "userservice",
      "appl"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-guides-cli-logger",
    "title": "Logging",
    "content": "Logging | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Logging ​\n\n## Logger ​\nThe `src/logger.ts` file initialises the widely used Winston logger library, by default with the `info` log level, logging to the console.ts\n```\nimport { createLogger, format, transports } from 'winston'\n\n// Configure the Winston logger. For the complete documentation see https://github.com/winstonjs/winston\nexport const logger = createLogger({\n  // To see more detailed errors, change this to 'debug'\n  level: 'info',\n  format: format.combine(format.splat(), format.simple()),\n  transports: [new transports.Console()]\n})\n```\nYou can import the logger directly in any file where you want to add logging information.ts\n```\nimport { logger } from './logger'\n\nlogger.info('Log some information here')\n```\n Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "logging",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "logger",
      "the",
      "src",
      "file",
      "initialises",
      "widely",
      "used",
      "winston",
      "library",
      "default",
      "with",
      "info",
      "log",
      "level",
      "console",
      "import",
      "createlogger",
      "format",
      "transports",
      "from",
      "configure",
      "for",
      "complete",
      "documentation",
      "see",
      "https",
      "github",
      "com",
      "winstonjs",
      "export",
      "const",
      "more",
      "detailed",
      "errors",
      "change",
      "this",
      "debug",
      "combine",
      "splat",
      "simple",
      "new",
      "you",
      "can",
      "directly",
      "any",
      "where",
      "want",
      "add",
      "information",
      "some",
      "here",
      "suggest",
      "changes",
      "pagelast",
      "updated",
      "released",
      "under",
      "mit",
      "license",
      "copyright",
      "feathersjs",
      "contributors",
      "about",
      "philosophy",
      "comparison",
      "ecosystem",
      "learn",
      "guides",
      "api",
      "blog",
      "become",
      "backer",
      "find",
      "help",
      "issues"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-guides-cli-validators",
    "title": "Validators",
    "content": "Validators | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Validators ​\nFor all currently supported schema types, AJV is used as the default validator. See the validators API documentation for more information.\n## AJV validators ​\nThe `src/validators.ts` file sets up two Ajv instances for data and querys (for which string types will be coerced automatically). It also sets up a collection of additional formats using ajv-formats. The validators in this file can be customized according to the Ajv documentation and its plugins. You can find the available Ajv options in the Ajs class API docs.ts\n```\nimport { Ajv, addFormats } from '@feathersjs/schema'\nimport type { FormatsPluginOptions } from '@feathersjs/schema'\n\nconst formats: FormatsPluginOptions = [\n  'date-time',\n  'time',\n  'date',\n  'email',\n  'hostname',\n  'ipv4',\n  'ipv6',\n  'uri',\n  'uri-reference',\n  'uuid',\n  'uri-template',\n  'json-pointer',\n  'relative-json-pointer',\n  'regex'\n]\n\nexport const dataValidator = addFormats(new Ajv({}), formats)\n\nexport const queryValidator = addFormats(\n  new Ajv({\n    coerceTypes: true\n  }),\n  formats\n)\n```\n\n## MongoDB ObjectIds ​\nWhen choosing MongoDB, the validators file will also register the `objectid` keyword to convert strings to MongoDB Object ids. Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "validators",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "for",
      "all",
      "currently",
      "supported",
      "schema",
      "types",
      "ajv",
      "used",
      "the",
      "default",
      "validator",
      "see",
      "api",
      "documentation",
      "more",
      "information",
      "src",
      "file",
      "sets",
      "two",
      "instances",
      "data",
      "and",
      "querys",
      "which",
      "string",
      "will",
      "coerced",
      "automatically",
      "also",
      "collection",
      "additional",
      "formats",
      "using",
      "this",
      "can",
      "customized",
      "according",
      "its",
      "plugins",
      "you",
      "find",
      "available",
      "options",
      "ajs",
      "class",
      "docs",
      "import",
      "addformats",
      "from",
      "feathersjs",
      "type",
      "formatspluginoptions",
      "const",
      "date",
      "time",
      "email",
      "hostname",
      "ipv4",
      "ipv6",
      "uri",
      "reference",
      "uuid",
      "template",
      "json",
      "pointer",
      "relative",
      "regex",
      "export",
      "datavalidator",
      "new",
      "queryvalidator",
      "coercetypes",
      "true",
      "mongodb",
      "objectids",
      "when",
      "choosing",
      "register",
      "objectid",
      "keyword",
      "convert",
      "strings",
      "object",
      "ids",
      "suggest",
      "changes",
      "pagelast",
      "updated",
      "released",
      "under",
      "mit",
      "license",
      "copyright",
      "contributors",
      "about",
      "philosophy",
      "comparison",
      "ecosystem",
      "learn",
      "guides",
      "blog",
      "become",
      "backer",
      "help",
      "github",
      "issues"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-guides-cli-package",
    "title": "package.json",
    "content": "package.json | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# package.json ​\n\n## Folders ​\nThe source and test folders to which files are generated is set in the `package.json`. To change them, rename the `src/` or `test/` folder to what you want it to and then update `package.json` `directories` section accordingly:json\n```\n{\n  \"directories\": {\n    \"lib\": \"api/src\",\n    \"test\": \"api/test\"\n  }\n}\n```\n Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "package",
      "json",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "folders",
      "the",
      "source",
      "and",
      "test",
      "which",
      "files",
      "are",
      "generated",
      "set",
      "change",
      "them",
      "rename",
      "src",
      "folder",
      "what",
      "you",
      "want",
      "then",
      "update",
      "directories",
      "section",
      "accordingly",
      "lib",
      "api",
      "suggest",
      "changes",
      "this",
      "pagelast",
      "updated",
      "released",
      "under",
      "mit",
      "license",
      "copyright",
      "feathersjs",
      "contributors",
      "about",
      "philosophy",
      "comparison",
      "ecosystem",
      "learn",
      "guides",
      "blog",
      "become",
      "backer",
      "find",
      "help",
      "github",
      "issues"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api",
    "title": "API",
    "content": "API | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# API ​\nThis section describes all the individual modules and APIs of Feathers.\n## Core ​\nFeathers core functionality that works on the client and the serverApplication - The main Feathers application API\n• Services - Service objects and their methods and Feathers specific functionality\n• Hooks - Pluggable middleware for service methods\n• Events - Events sent by Feathers service methods\n• Errors - A collection of error classes used throughout Feathers\n\n## Transports ​\n\nExpose a Feathers application as an API server\n• Configuration - A node-config wrapper to initialize configuration of a server side application.\n• Koa - Feathers KoaJS framework bindings, REST API provider and error middleware.\n• Express - Feathers Express framework bindings, REST API provider and error middleware.\n• Socket.io - The Socket.io real-time transport provider\n• Channels - Channels are used to send real-time events to clients\n\n## Authentication ​\n\nFeathers authentication mechanism\n• Service - The main authentication service configuration\n• Hook - The hook used to authenticate service method calls\n• Strategies - More about authentication strategies\n• Local - Local email/password authentication\n• JWT - JWT authentication\n• OAuth - Using OAuth logins (Facebook, Twitter etc.)\n\n## Client ​\n\nMore details on how to use Feathers on the client\n• Usage - Feathers client usage in Node, React Native and the browser (also with Webpack and Browserify)\n• REST - Feathers client and direct REST API server usage\n• Socket.io - Feathers client and direct Socket.io API server usage\n• Authentication - A client for Feathers authentication\n\n## Schema ​\n\nModel definitions for validating and resolving data.\n• TypeBox - Integration for TypeBox, a JSON schema type builder\n• JSON schema - JSON schema integration\n• Validators - Schema validators and validation hooks\n• Resolvers - Dynamic data resolvers\n\n## Databases ​\n\nFeathers common database adapter API and querying mechanism\n• Adapters - A list of supported database adapters\n• Common API - Database adapter common initialization and configuration API\n• Querying - The common querying mechanism\n• MongoDB - The adapter for MongoDB databases\n• SQL - The adapter for SQL databases using KnexJS\n• Memory - The adapter for in-memory data storage\n\n Suggest changes to this page\n\nLast updated: \n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors\n\n feathers \n\n• About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "api",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "this",
      "section",
      "describes",
      "all",
      "the",
      "individual",
      "modules",
      "and",
      "apis",
      "core",
      "functionality",
      "that",
      "works",
      "client",
      "serverapplication",
      "main",
      "application",
      "services",
      "service",
      "objects",
      "their",
      "methods",
      "specific",
      "hooks",
      "pluggable",
      "middleware",
      "for",
      "events",
      "sent",
      "errors",
      "collection",
      "error",
      "classes",
      "used",
      "throughout",
      "transports",
      "expose",
      "server",
      "configuration",
      "node",
      "config",
      "wrapper",
      "initialize",
      "side",
      "koa",
      "koajs",
      "framework",
      "bindings",
      "rest",
      "provider",
      "express",
      "socket",
      "real",
      "time",
      "transport",
      "channels",
      "are",
      "send",
      "clients",
      "authentication",
      "mechanism",
      "hook",
      "authenticate",
      "method",
      "calls",
      "strategies",
      "more",
      "about",
      "local",
      "email",
      "password",
      "jwt",
      "oauth",
      "using",
      "logins",
      "facebook",
      "twitter",
      "etc",
      "details",
      "how",
      "use",
      "usage",
      "react",
      "native",
      "browser",
      "also",
      "with",
      "webpack",
      "browserify",
      "direct",
      "schema",
      "model",
      "definitions",
      "validating",
      "resolving",
      "data",
      "typebox",
      "integration",
      "json",
      "type",
      "builder",
      "validators",
      "validation",
      "resolvers",
      "dynamic",
      "databases",
      "feath"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-application",
    "title": "Application",
    "content": "Application | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Application ​\n\n```\nnpm install @feathersjs/feathers --save\n```\nThe core `@feathersjs/feathers` module provides the ability to initialize a new Feathers application instance. It works in Node, React Native and the browser (see the client chapter for more information). Each instance allows for registration and retrieval of services, hooks, plugin configuration, and getting and setting configuration options. An initialized Feathers application is referred to as the app object.ts\n```\nimport { feathers } from '@feathersjs/feathers'\n\ntype ServiceTypes = {\n  // Add registered services here\n}\n\n// Types for `app.set(name, value)` and `app.get(name)`\ntype Configuration = {\n  port: number\n}\n\nconst app = feathers()\n```\n\n## .use(path, service [, options]) ​\n`app.use(path, service [, options]) -> app` allows registering a service object on a given `path`.ts\n```\nimport { feathers, type Id } from '@feathersjs/feathers'\n\nclass MessageService {\n  async get(id: Id) {\n    return {\n      id,\n      text: `This is the ${id} message!`\n    }\n  }\n}\n\ntype ServiceTypes = {\n  // Add services path to type mapping here\n  messages: MessageService\n}\n\nconst app = feathers()\n\n// Register a service instance on the app\napp.use('messages', new MessageService())\n\n// Get the service and call the service method with the correct types\nconst message = await app.service('messages').get('test')\n```\n\n### path ​\nThe `path` is a string that should be URL friendly and may contain `/` as a separator. `path` can also be `/` to register a service at the root level. A path may contain placeholders in the form of `:userId/messages` which will be included in `params.route` by a transport.\n### options ​\nThe following options are available:`methods` (default: `['find', 'get', 'create', 'patch', 'update','remove']`) - A list of official and custom service methods that should be available to clients. When using this option all method names that should be available externally must be passed. Those methods will automatically be available for use with hooks.\n• `events` - A list of public custom events sent by this service\n\nts\n```\nimport { EventEmitter } from 'events'\nimport { feathers, type Id } from '@feathersjs/feathers'\n\n// Feathers services will always be event emitters\n// but we can also extend it for better type consistency\nclass MessageService extends EventEmitter {\n  async doSomething(data: { message: string }, params: Params) {\n    this.emit('something', 'I did something')\n    return data\n  }\n\n  async get(id: Id) {\n    return {\n      id,\n      text: `This is the ${id} message!`\n    }\n  }\n}\n\ntype ServiceTypes = {\n  // Add services path to type mapping here\n  messages: MessageService\n}\n\nconst app = feathers()\n\n// Register a service with options\napp.use('messages', new MessageService(), {\n  methods: ['get', 'doSomething'],\n  events: ['something']\n})\n```\n\nImportant\n\nIf the `methods` property is `undefined`, all standard methods will be enabled and accessible externally.\n\n## .unuse(path) ​\n\n`app.unuse(path)` unregisters an existing service on `path` and calls the services .teardown method if it is implemented.\n\n## .service(path) ​\n\n`app.service(path) -> service` returns the service object for the given path. Feathers internally creates a new object from each registered service. This means that the object returned by `app.service(path)` will provide the same methods and functionality as your original service object but also functionality added by Feathers and its plugins like service events and additional methods.\n\nts\n```\nconst messageService = app.service('messages')\n\nconst message = await messageService.get('test')\n\nconsole.log(message)\n\nmessageService.on('created', (message: Message) => {\n  console.log('Created a todo')\n})\n```\n\nNote\n\nNote that a server side `app.service(path)` only allows the original service name (e.g. `app.service(':userId/messages')`) and does not parse placeholders. To get a service with route paramters use .lookup\n\n## .lookup(path) ​\n\n`app.lookup(path)` allows to look up a full path and will return the `data` (route parameters) and `service` on the server.\n\nts\n```\nconst lookup = app.lookup('messages/4321')\n\n// lookup.service -> app.service('messages')\n// lookup.data -> { __id: '4321' }\n\n// `lookup.dta` needs to be passed as `params.route`\nlookup.service.find({\n  route: lookup.data\n})\n```\n\nCase insensitive lookups can be enabled in the `app` file like this:\n\nts\n```\napp.routes.caseSensitive = false\n```\n\n## .hooks(hooks) ​\n\n`app.hooks(hooks) -> app` allows registration of application-level hooks. For more information see the application hooks section in the hooks chapter.\n\n## .publish([event, ] publisher) ​\n\n`app.publish([event, ] publisher) -> app` registers a global event publisher. For more information see the channels publishing chapter.\n\n## .configure(callback) ​\n\n`app.configure(callback) -> app` runs a `callback` function that gets pass",
    "version": "v5",
    "tokens": [
      "application",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "npm",
      "install",
      "feathersjs",
      "save",
      "the",
      "core",
      "module",
      "provides",
      "ability",
      "initialize",
      "new",
      "instance",
      "works",
      "node",
      "react",
      "native",
      "and",
      "browser",
      "see",
      "client",
      "chapter",
      "for",
      "more",
      "information",
      "each",
      "allows",
      "registration",
      "retrieval",
      "services",
      "hooks",
      "plugin",
      "configuration",
      "getting",
      "setting",
      "options",
      "initialized",
      "referred",
      "app",
      "object",
      "import",
      "from",
      "type",
      "servicetypes",
      "add",
      "registered",
      "here",
      "types",
      "set",
      "name",
      "value",
      "get",
      "port",
      "number",
      "const",
      "use",
      "path",
      "service",
      "registering",
      "given",
      "class",
      "messageservice",
      "async",
      "return",
      "text",
      "this",
      "message",
      "mapping",
      "messages",
      "register",
      "call",
      "method",
      "with",
      "correct",
      "await",
      "test",
      "string",
      "that",
      "should",
      "url",
      "friendly",
      "may",
      "contain",
      "separator",
      "can",
      "also",
      "root",
      "level",
      "placeholders",
      "form",
      "userid",
      "which",
      "will",
      "included",
      "params",
      "route",
      "transport",
      "following",
      "are",
      "available",
      "methods",
      "default",
      "find",
      "create",
      "patch",
      "update",
      "remove",
      "list",
      "official",
      "custom",
      "clients",
      "when",
      "using"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-events",
    "title": "Events",
    "content": "Events | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Events ​\nEvents are the key part of Feathers real-time functionality. All events in Feathers are provided through the NodeJS EventEmitter interface. This section describesA quick overview of the NodeJS EventEmitter interface\n• The standard service events\n• How to allow sending custom events from the server to the client\n\nImportant\n\nFor more information on how to safely send real-time events to clients, see the Channels chapter.\n\n## EventEmitters ​\n\nOnce registered, any service gets turned into a standard NodeJS EventEmitter and can be used accordingly.\n\nts\n```\nconst messages = app.service('messages')\n\n// Listen to a normal service event\nmessages.on('patched', (message: Message) => console.log('message patched', message))\n\n// Only listen to an event once\nmesssages.once('removed', (message: Message) => console.log('First time a message has been removed', message))\n\n// A reference to a handler\nconst onCreatedListener = (message: Message) => console.log('New message created', message)\n\n// Listen `created` with a handler reference\nmessages.on('created', onCreatedListener)\n\n// Unbind the `created` event listener\nmessages.removeListener('created', onCreatedListener)\n\n// Send a custom event\nmessages.emit('customEvent', {\n  anything: 'Data can be anything'\n})\n```\n\n## Service Events ​\n\nAny service automatically emits `created`, `updated`, `patched` and `removed` events when the respective service method returns successfully. This works on the client as well as on the server. Events are not fired until all hooks have executed. When the client is using Socket.io, events will be pushed automatically from the server to all connected clients. This is how Feathers does real-time.\n\ntip\n\nTo disable sending of events e.g. when updating a large amount of data, set context.event to `null` in a hook.\n\nAdditionally to the event `data`, all events also get the hook context from their method call passed as the second parameter.\n\n### created ​\n\nThe `created` event will fire with the result data when a service `create` returns successfully.\n\nts\n```\nimport { feathers, type Params, type HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async create(data: Message) {\n    return data\n  }\n}\n\nconst app = feathers()\n\napp.use('messages', new MessageService())\n\n// Retrieve the wrapped service object which is also an EventEmitter\nconst messages = app.service('messages')\n\nmessages.on('created', (message: Message, contexHookContext) => console.log('created', message))\n\nmessages.create({\n  text: 'We have to do something!'\n})\n```\n\n### updated, patched ​\n\nThe `updated` and `patched` events will fire with the callback data when a service `update` or `patch` method calls back successfully.\n\nts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport type { Id, Params, HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async update(id: Id, data: Message) {\n    return data\n  }\n\n  async patch(id: Id, data: Message) {\n    return data\n  }\n}\n\nconst app = feathers()\n\napp.use('messages', new MessageService())\n\nconst messages = app.service('my/messages')\n\nmessages.on('updated', (message: Message, context: HookContext) => console.log('updated', message))\nmessages.on('patched', (message: Message) => console.log('patched', message))\n\nmessages.update(0, {\n  text: 'updated message'\n})\n\nmessages.patch(0, {\n  text: 'patched message'\n})\n```\n\n### removed ​\n\nThe `removed` event will fire with the callback data when a service `remove` calls back successfully.\n\nts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport type { Id, Params, HookContext } from '@feathersjs/feathers'\n\ntype Message = { text: string }\n\nclass MessageService {\n  async remove(id: Id, params: Params) {\n    return { id }\n  }\n}\n\nconst app = feathers()\n\napp.use('messages', new MessageService())\n\nconst messages = app.service('messages')\n\nmessages.on('removed', (message: Message, context: HookContext) => console.log('removed', message))\nmessages.remove(1)\n```\n\n## Custom events ​\n\nBy default, real-time clients will only receive the standard events. However, it is possible to define a list of custom events that should also be sent to the client when registering the service with app.use, when `service.emit('customevent', data)` is called on the server. The `context` for custom events won't be a full hook context but just an object containing `{ app, service, path, result }`.\n\nimportant\n\nCustom events can only be sent from the server to the client, not the other way (client to server). A custom service should be used for those cases.\n\nFor example, a payment service that sends status events to the client while processing a payment could look like this:\n\nts\n```\nclass PaymentService {\n  async create(data: any, params: Params) {\n    const customer = await createStripeCustomer(params.user)\n    this.emit('status',",
    "version": "v5",
    "tokens": [
      "events",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "are",
      "the",
      "key",
      "part",
      "real",
      "time",
      "functionality",
      "all",
      "provided",
      "through",
      "nodejs",
      "eventemitter",
      "interface",
      "this",
      "section",
      "describesa",
      "quick",
      "overview",
      "standard",
      "service",
      "how",
      "allow",
      "sending",
      "custom",
      "from",
      "server",
      "client",
      "important",
      "for",
      "more",
      "information",
      "safely",
      "send",
      "clients",
      "see",
      "channels",
      "chapter",
      "eventemitters",
      "once",
      "registered",
      "any",
      "gets",
      "turned",
      "into",
      "and",
      "can",
      "used",
      "accordingly",
      "const",
      "messages",
      "app",
      "listen",
      "normal",
      "event",
      "patched",
      "message",
      "console",
      "log",
      "only",
      "messsages",
      "removed",
      "first",
      "has",
      "been",
      "reference",
      "handler",
      "oncreatedlistener",
      "new",
      "created",
      "with",
      "unbind",
      "listener",
      "removelistener",
      "emit",
      "customevent",
      "anything",
      "data",
      "automatically",
      "emits",
      "updated",
      "when",
      "respective",
      "method",
      "returns",
      "successfully",
      "works",
      "well",
      "not",
      "fired",
      "until",
      "hooks",
      "have",
      "executed",
      "using",
      "socket",
      "will",
      "pushed",
      "connected",
      "does",
      "tip",
      "disable",
      "updating",
      "large",
      "amount",
      "set",
      "context",
      "null",
      "hook",
      "additionally",
      "also",
      "get",
      "their"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-errors",
    "title": "Errors",
    "content": "Errors | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Errors ​\n\n```\nnpm install @feathersjs/errors --save\n```\nThe `@feathersjs/errors` module contains a set of standard error classes used by all other Feathers modules.\n## Examples ​\nHere are a few ways that you can use them:ts\n```\nimport { NotFound, GeneralError, BadRequest } from '@feathersjs/errors'\n\n// If you were to create an error yourself.\nconst notFound = new NotFound('User does not exist')\n\n// You can wrap existing errors\nconst existing = new GeneralError(new Error('I exist'))\n\n// You can also pass additional data\nconst data = new BadRequest('Invalid email', {\n  email: '[email protected]'\n})\n\n// You can also pass additional data without a message\nconst dataWithoutMessage = new BadRequest({\n  email: '[email protected]'\n})\n\n// If you need to pass multiple errors\nconst validationErrors = new BadRequest('Invalid Parameters', {\n  errors: { email: 'Email already taken' }\n})\n\n// You can also omit the error message and we'll put in a default one for you\nconst validationErrors = new BadRequest({\n  errors: {\n    email: 'Invalid Email'\n  }\n})\n```\n\n## Feathers errors ​\nThe following error types, all of which are instances of `FeathersError`, are available:400: `BadRequest`\n• 401: `NotAuthenticated`\n• 402: `PaymentError`\n• 403: `Forbidden`\n• 404: `NotFound`\n• 405: `MethodNotAllowed`\n• 406: `NotAcceptable`\n• 408: `Timeout`\n• 409: `Conflict`\n• 411: `LengthRequired`\n• 422: `Unprocessable`\n• 429: `TooManyRequests`\n• 500: `GeneralError`\n• 501: `NotImplemented`\n• 502: `BadGateway`\n• 503: `Unavailable`\n\ntip\n\nAll of the Feathers core modules and most plugins and database adapters automatically emit the appropriate Feathers errors for you. For example, most of the database adapters will already send `Conflict` or `Unprocessable` errors on validation errors.\n\nFeathers errors contain the following fields:\n• `name` - The error name (e.g. \"BadRequest\", \"ValidationError\", etc.)\n• `message` - The error message string\n• `code` - The HTTP status code\n• `className` - A CSS class name that can be handy for styling errors based on the error type. (e.g. \"bad-request\" , etc.)\n• `data` - An object containing anything you passed to a Feathers error except for the `errors` object and `message`.\n• `errors` - An object containing whatever was passed to a Feathers error inside `errors`. This is typically validation errors or if you want to group multiple errors together.\n\nImportant\n\nTo convert a Feathers error back to an object call `error.toJSON()`. A normal `console.log` of a JavaScript Error object will not automatically show those additional properties described above (even though they can be accessed directly).\n\n## Custom errors ​\n\nYou can create custom errors by extending from the `FeathersError` class and calling its constructor with `(message, name, code, className, data)`:\n• `message` - The error message\n• `name` - The error name (e.g. `MyError`)\n• `code` - An HTTP error code\n• `className` - The full name of the error class (e.g. `my-error`)\n• `data` - Additional data to include in the error\n\nts\n```\nimport { FeathersError } from '@feathersjs/errors'\n\nclass UnsupportedMediaType extends FeathersError {\n  constructor(message: string, data: any) {\n    super(message, 'UnsupportedMediaType', 415, 'unsupported-media-type', data)\n  }\n}\n\nconst error = new UnsupportedMediaType('Not supported')\n\nconsole.log(error.toJSON())\n```\n\n## Error Handling ​\n\nIt is important to make sure that errors get cleaned up before they go back to the client. Express error handling middleware works only for REST calls. If you want to make sure that ws errors are handled as well, you need to use application error hooks which are called on any service call error.\n\nHere is an example error handler you can add to app.hooks errors.\n\njs\n```\nconst errors = require('@feathersjs/errors')\nconst errorHandler = (ctx) => {\n  if (ctx.error) {\n    const error = ctx.error\n    if (!error.code) {\n      const newError = new errors.GeneralError('server error')\n      ctx.error = newError\n      return ctx\n    }\n    if (error.code === 404 || process.env.NODE_ENV === 'production') {\n      error.stack = null\n    }\n    return ctx\n  }\n}\n```\n\nthen add it as an application level error hook\n\nts\n```\napp.hooks({\n  //...\n  error: {\n    all: [errorHandler]\n  }\n})\n```\n\n Suggest changes to this page\n\nLast updated: \n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors\n\n feathers \n\n• About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "errors",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "npm",
      "install",
      "feathersjs",
      "save",
      "the",
      "module",
      "contains",
      "set",
      "standard",
      "error",
      "classes",
      "used",
      "all",
      "other",
      "modules",
      "examples",
      "here",
      "are",
      "few",
      "ways",
      "that",
      "you",
      "can",
      "use",
      "them",
      "import",
      "notfound",
      "generalerror",
      "badrequest",
      "from",
      "were",
      "create",
      "yourself",
      "const",
      "new",
      "user",
      "does",
      "not",
      "exist",
      "wrap",
      "existing",
      "also",
      "pass",
      "additional",
      "data",
      "invalid",
      "email",
      "protected",
      "without",
      "message",
      "datawithoutmessage",
      "need",
      "multiple",
      "validationerrors",
      "parameters",
      "already",
      "taken",
      "omit",
      "and",
      "put",
      "default",
      "one",
      "for",
      "following",
      "types",
      "which",
      "instances",
      "featherserror",
      "available",
      "notauthenticated",
      "paymenterror",
      "forbidden",
      "methodnotallowed",
      "notacceptable",
      "timeout",
      "conflict",
      "lengthrequired",
      "unprocessable",
      "toomanyrequests",
      "notimplemented",
      "badgateway",
      "unavailable",
      "tip",
      "core",
      "most",
      "plugins",
      "database",
      "adapters",
      "automatically",
      "emit",
      "appropriate",
      "example",
      "will",
      "send",
      "validation",
      "contain",
      "fields",
      "name",
      "validationerror",
      "etc",
      "mes"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-configuration",
    "title": "Configuration",
    "content": "Configuration | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Configuration ​\n\n```\nnpm install @feathersjs/configuration --save\n```\n`@feathersjs/configuration` is a wrapper for node-config to make configuration values available via app.get which can then be used to configure an application.By default it will look in `config/*` for `default.json`. It will be merged with other configuration files in the `config/` folder using the `NODE_ENV` environment variable. So setting `NODE_ENV=production` will merge `config/default.json` with `config/production.json`.For more information also see the node-config docs.\n## Usage ​\n`app.configure(configuration())` loads the configuration from `node-config` and makes it available via `app.get()`.ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport configuration from '@feathersjs/configuration'\n\n// Use the application root and `config/` as the configuration folder\nconst app = feathers().configure(configuration())\n\n// Will return 3030 with  `{ \"port\": 3030 }` in config/default.json\napp.get('port')\n```\nImportantDirect access to nested config properties is not supported via `app.get()`. To access a nested config property (e.g. `Customer.dbConfig.host`, use `app.get('Customer').dbConfig.host`.\n## Configuration validation ​\n`app.configure(configuration(validator))` loads the configuration from `node-config`, makes it available via `app.get()` and validates the original configuration against a Feathers schema validator when app.setup (or app.listen) is called.ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport { Ajv } from '@feathersjs/schema'\nimport { Type, getValidator } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\nimport configuration from '@feathersjs/configuration'\n\nconst configurationSchema = Type.Object(\n  {\n    port: Type.Number(),\n    host: Type.String()\n  },\n  { $id: 'Configuration', additionalProperties: false }\n)\n\nconst configurationValidator = getValidator(configurationSchema, new Ajv())\n\ntype ServiceTypes = {}\n// Use the schema type for typed `app.get` and `app.set` calls\ntype Configuration = Static\n\n// Use the application root and `config/` as the configuration folder\nconst app = feathers().configure(configuration(configurationValidator))\n\n// Configuration will only be validated now\napp\n  .listen()\n  .then(() => console.log('Server started'))\n  .catch((error) => {\n    // Configuration validation errors will show up here\n    console.log(error.data)\n  })\n```\n\n## Environment variables ​\nAs recommended by node-config, it is possible to override the configuration with custom variables by passing a JSON object in the `NODE_CONFIG` environment variable:\n```\n$ export NODE_CONFIG='{ \"port\":  8080, \"host\": \"production.app\" }'\n$ node myapp.js\n```\nIndividual environment variables can be used through Custom Environment Variables by creating a `config/custom-environment-variables.json` like this:js\n```\n{\n  \"port\": \"PORT\",\n  \"mongodb\": \"MONGOHQ_URL\"\n}\n```\n\n## Configuration directory ​\nBy default, Feathers will use the `config/` directory in the root of your project’s source directory. To change this, e.g., if you have Feathers installed under the `server/` directory and you want your configuration at `server/config/`, you have to set the `NODE_CONFIG_DIR` environment variable in `app.js` before importing `@feathersjs/configuration`:\n```\n$ export NODE_CONFIG_DIR=server/config\n$ node myapp.js\n```\nNoteThe NODE_CONFIG_DIR environment variable isn’t used directly by @feathersjs/configuration but by the node-config module that it uses. For more information on configuring node-config settings, see the Configuration Files Wiki page. Suggest changes to this pageLast updated: Released under the MIT License.Copyright © 2012-2026 FeathersJS contributors feathers About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "configuration",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "npm",
      "install",
      "feathersjs",
      "save",
      "wrapper",
      "for",
      "node",
      "config",
      "make",
      "values",
      "available",
      "via",
      "app",
      "get",
      "which",
      "can",
      "then",
      "used",
      "configure",
      "application",
      "default",
      "will",
      "look",
      "json",
      "merged",
      "with",
      "other",
      "files",
      "the",
      "folder",
      "using",
      "environment",
      "variable",
      "setting",
      "production",
      "merge",
      "more",
      "information",
      "also",
      "see",
      "docs",
      "usage",
      "loads",
      "from",
      "and",
      "makes",
      "import",
      "use",
      "root",
      "const",
      "return",
      "port",
      "importantdirect",
      "access",
      "nested",
      "properties",
      "not",
      "supported",
      "property",
      "customer",
      "dbconfig",
      "host",
      "validation",
      "validator",
      "validates",
      "original",
      "against",
      "schema",
      "when",
      "setup",
      "listen",
      "called",
      "ajv",
      "type",
      "getvalidator",
      "typebox",
      "static",
      "configurationschema",
      "object",
      "number",
      "string",
      "additionalproperties",
      "false"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-koa",
    "title": "Koa",
    "content": "Koa | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Koa ​\n\n```\nnpm install @feathersjs/koa --save\n```\nThe `@feathersjs/koa` module contains the KoaJS framework integrations for Feathers. It will turn the Feathers app into a fully compatible KoaJS application.\n## koa(app) ​\n`koa(app) -> app` is a function that turns a Feathers application into a fully KoaJS compatible application that additionally to Feathers functionality also lets you use the KoaJS API.ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport { koa, errorHandler, bodyParser, rest } from '@feathersjs/koa'\n\nconst app = koa(feathers())\n\napp.use(errorHandler())\napp.use(authentication())\napp.use(bodyParser())\napp.configure(rest())\n```\nAlso see the additional middleware that `@feathersjs/koa` exposes.\n## koa(app, koaApp) ​\n`koa(app, koaApp) -> app` allows to extend an existing Koa application with the Feathers application `app`.\n## koa() ​\nIf no Feathers application is passed, `koa() -> app` returns a plain Koa application (`new Koa()`).\n## app.use(location|mw[, service]) ​\n`app.use(location|mw[, service]) -> app` registers either a service object, or a Koa middleware. If a path and service object is passed it will use Feathers registration mechanism, for a middleware function Koa.\n## app.listen(port) ​\n`app.listen(port) -> HttpServer` will first call Koa app.listen and then internally also call the Feathers app.setup(server).js\n```\n// Listen on port 3030\nconst server = await app.listen(3030)\n```\n\n## app.setup(server) ​\n`app.setup(server) -> app` is usually called internally by `app.listen` but in the cases described below needs to be called explicitly.\n### HTTPS ​\nHTTPS requires creating a separate server in which case `app.setup(server)` also has to be called explicitly. In a generated application `src/index.js` should look like this:ts\n```\nimport https from 'https'\nimport { app } from './app'\n\nconst port = app.get('port')\nconst server = https\n  .createServer(\n    {\n      key: fs.readFileSync('privatekey.pem'),\n      cert: fs.readFileSync('certificate.pem')\n    },\n    app.callback()\n  )\n  .listen(443)\n\n// Call app.setup to initialize all services and SocketIO\napp.setup(server)\n\nserver.on('listening', () => logger.info('Feathers application started'))\n```\n\n## params ​\nIn a Koa middleware, `ctx.feathers` is an object which will be extended as `params` in a service method call.ts\n```\nimport { rest } from '@feathersjs/koa'\nimport type { NextFunction } from '@feathersjs/koa'\nimport type { Id, Params } from '@feathersjs/feathers'\n\nclass TodoService {\n  async get(id: Id, params: Params & { fromMiddleware: string }) {\n    const { fromMiddleware } = params\n\n    return { id, fromMiddleware }\n  }\n}\n\n// Register Koa middleware\napp.use(async (ctx: any, next: NextFunction) => {\n  ctx.feathers = {\n    ...ctx.feathers,\n    fromMiddleware: 'Hello from Koa middleware'\n  }\n\n  await next()\n})\napp.configure(rest())\n\n// Register a service\napp.use('todos', new TodoService())\n```\nImportantNote that `app.configure(rest())` has to happen after any custom middleware.\n### params.query ​\n`params.query` will contain the URL query parameters sent from the client parsed using koa-qs.importantOnly `params.query` is passed between the server and the client, other parts of `params` are not. This is for security reasons so that a client can't set things like `params.user` or the database options. You can always map from `params.query` to other `params` properties in a hook.To increase the array limit in query strings, `koa-qs` can be reinitalized with the options for the qs module:ts\n```\n// app.ts\nimport koaQs from 'koa-qs'\n\n// ...\nkoaQs(app, 'extended', {\n  arrayLimit: 200\n})\n```\n\n### params.provider ​\nFor any service method call made through REST `params.provider` will be set to `rest`.\n### params.route ​\nRoute placeholders in a service URL will be added to the services `params.route`. See the FAQ entry on nested routes for more details on when and when not to use nested routes.ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport { koa, errorHandler, bodyParser, rest } from '@feathersjs/koa'\n\nconst app = koa(feathers())\n\napp.use('users/:userId/messages', {\n  async get(id, params) {\n    console.log(params.query) // -> ?query\n    console.log(params.provider) // -> 'rest'\n    console.log(params.fromMiddleware) // -> 'Hello world'\n    console.log(params.route) // will be `{ userId: '1' }` for GET /users/1/messages\n\n    return {\n      id,\n      params,\n      read: false,\n      text: `Feathers is great!`,\n      createdAt: new Date().getTime()\n    }\n  }\n})\n\napp.listen(3030)\n```\n\n## Service middleware ​\nWhen registering a service, it is also possible to pass custom Koa middleware that should run `before` the specific service method in the `koa` service option:ts\n```\napp.use('/todos', new TodoService(), {\n  koa: {\n    before: [\n      async (ctx, next) => {\n        ctx.feathers // data that will be merged into sevice `params`\n\n    ",
    "version": "v5",
    "tokens": [
      "koa",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "npm",
      "install",
      "feathersjs",
      "save",
      "the",
      "module",
      "contains",
      "koajs",
      "framework",
      "integrations",
      "for",
      "will",
      "turn",
      "app",
      "into",
      "fully",
      "compatible",
      "application",
      "function",
      "that",
      "turns",
      "additionally",
      "functionality",
      "also",
      "lets",
      "you",
      "use",
      "api",
      "import",
      "from",
      "errorhandler",
      "bodyparser",
      "rest",
      "const",
      "authentication",
      "configure",
      "see",
      "additional",
      "middleware",
      "exposes",
      "koaapp",
      "allows",
      "extend",
      "existing",
      "with",
      "passed",
      "returns",
      "plain",
      "new",
      "location",
      "service",
      "registers",
      "either",
      "object",
      "path",
      "and",
      "registration",
      "mechanism",
      "listen",
      "port",
      "httpserver",
      "first",
      "call",
      "then",
      "internally",
      "setup",
      "server",
      "await",
      "usually",
      "called",
      "but",
      "cases",
      "described",
      "below",
      "needs",
      "explicitly",
      "https",
      "requires",
      "creating",
      "separate",
      "which",
      "case",
      "has",
      "generated",
      "src",
      "index",
      "should",
      "look",
      "like",
      "this",
      "get",
      "creat"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-express",
    "title": "Express",
    "content": "Express | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Express ​\n\n```\nnpm install @feathersjs/express --save\n```\nThe `@feathersjs/express` module contains Express framework integrations for Feathers:The Express framework bindings to make a Feathers application Express compatible\n• An Express based transport to expose services through a REST API\n• An Express error handler for Feathers errors\n\nts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport express from '@feathersjs/express'\n\nconst app = express(feathers())\n```\n\nImportant\n\nAs of Feathers v5, Koa is the recommended framework integration since it is more modern, faster and easier to use. When chosen explicitly, you should already be familiar with Express.\n\n## express(app) ​\n\n`express(app) -> app` is a function that turns a Feathers application into a fully Express (4+) compatible application that additionally to Feathers functionality also lets you use the Express API.\n\nts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport express from '@feathersjs/express'\n\nconst app = express(feathers())\n```\n\nNote that `@feathersjs/express` also exposes the Express built-in middleware\n\n## express(app, expressApp) ​\n\n`express(app, expressApp) -> app` allows to extend an existing Express application with the Feathers application `app`.\n\n## express() ​\n\nIf no Feathers application is passed, `express() -> app` returns a plain Express application just like a normal call to Express would.\n\n## app.use(path, service|mw|[mw]) ​\n\n`app.use(path, service|mw|[mw]) -> app` registers either a service object, an Express middleware or an array of Express middleware on the given path. If a service object is passed it will use Feathers registration mechanism, for a middleware function Express.\n\nts\n```\n// Register a service\napp.use('todos', {\n  async get(id) {\n    return { id }\n  }\n})\n\n// Register an Express middleware\napp.use('/test', (req, res) => {\n  res.json({\n    message: 'Hello world from Express middleware'\n  })\n})\n\n// Register multiple Express middleware functions\napp.use(\n  '/test',\n  (req, res, next) => {\n    res.data = 'Step 1 worked'\n    next()\n  },\n  (req, res) => {\n    res.json({\n      message: `Hello world from Express middleware ${res.data}`\n    })\n  }\n)\n```\n\n## app.listen(port) ​\n\n`app.listen(port) -> Promise` will first call Express app.listen and then internally also call the app.setup(server).\n\nts\n```\n// Listen on port 3030\nconst server = await app.listen(3030)\n```\n\n## app.setup(server) ​\n\n`app.setup(server) -> app` is usually called internally by `app.listen` but in the cases described below needs to be called explicitly.\n\n### Sub-Apps ​\n\nWhen registering an application as a sub-app, `app.setup(server)` has to be called to initialize the sub-apps services.\n\nts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport express from '@feathersjs/express'\n\nconst api = feathers()\n\napi.use('service', myService)\n\nconst mainApp = express(feathers()).use('/api/v1', api)\n\nconst server = await mainApp.listen(3030)\n\n// Now call setup on the Feathers app with the server\nawait api.setup(server)\n```\n\n### HTTPS ​\n\nHTTPS requires creating a separate server in which case `app.setup(server)` also has to be called explicitly. In a generated application `src/index.js` should look like this:\n\nts\n```\nimport https from 'https'\nimport { app } from './app'\n\nconst port = app.get('port')\nconst server = https\n  .createServer(\n    {\n      key: fs.readFileSync('privatekey.pem'),\n      cert: fs.readFileSync('certificate.pem')\n    },\n    app\n  )\n  .listen(443)\n\n// Call app.setup to initialize all services and SocketIO\napp.setup(server)\n\nserver.on('listening', () => logger.info('Feathers application started'))\n```\n\n### Virtual Hosts ​\n\nThe vhost Express middleware can be used to run a Feathers application on a virtual host but again requires `app.setup(server)` to be called explicitly.\n\nts\n```\nimport vhost from 'vhost'\nimport { feathers } from '@feathersjs/feathers'\nimport express from '@feathersjs/express'\n\nconst app = express(feathers())\n\napp.use('/todos', todoService)\n\nconst host = express().use(vhost('foo.com', app))\nconst server = await host.listen(8080)\n\n// Here we need to call app.setup because .listen on our virtual hosted\n// app is never called\napp.setup(server)\n```\n\n## rest() ​\n\nRegisters a Feathers transport mechanism that allows you to expose and consume services through a RESTful API. This means that you can call a service method through the `GET`, `POST`, `PUT`, `PATCH` and `DELETE` HTTP methods:\n\nService methodHTTP methodPath\n\n.find()GET/messages\n\n.get()GET/messages/1\n\n.create()POST/messages\n\n.update()PUT/messages/1\n\n.patch()PATCH/messages/1\n\n.remove()DELETE/messages/1\n\n### app.configure(rest()) ​\n\nConfigures the transport provider with a standard formatter sending JSON response via res.json.\n\nts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport express, { json, urlencoded, rest } from '@feathersjs/express'\n\n// Create ",
    "version": "v5",
    "tokens": [
      "express",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "npm",
      "install",
      "feathersjs",
      "save",
      "the",
      "module",
      "contains",
      "framework",
      "integrations",
      "for",
      "bindings",
      "make",
      "application",
      "compatible",
      "based",
      "transport",
      "expose",
      "services",
      "through",
      "rest",
      "api",
      "error",
      "handler",
      "errors",
      "import",
      "from",
      "const",
      "app",
      "important",
      "koa",
      "recommended",
      "integration",
      "since",
      "more",
      "modern",
      "faster",
      "and",
      "easier",
      "use",
      "when",
      "chosen",
      "explicitly",
      "you",
      "should",
      "already",
      "familiar",
      "with",
      "function",
      "that",
      "turns",
      "into",
      "fully",
      "additionally",
      "functionality",
      "also",
      "lets",
      "note",
      "exposes",
      "built",
      "middleware",
      "expressapp",
      "allows",
      "extend",
      "existing",
      "passed",
      "returns",
      "plain",
      "just",
      "like",
      "normal",
      "call",
      "would",
      "path",
      "service",
      "registers",
      "either",
      "object",
      "array",
      "given",
      "will",
      "registration",
      "mechanism",
      "register",
      "todos",
      "async",
      "get",
      "return",
      "test",
      "req",
      "res",
      "json",
      "message",
      "hel"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-socketio",
    "title": "Socket.io",
    "content": "Socket.io | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Socket.io ​\n\n```\nnpm install @feathersjs/socketio --save\n```\nThe @feathersjs/socketio module allows to call service methods and receive real-time events via Socket.io, a NodeJS library which enables real-time bi-directional, event-based communication.ImportantThis page describes how to set up a Socket.io server. The Socket.io client chapter shows how to connect to this server on the client and the message format for service calls and real-time events.\n## Configuration ​\n`@feathersjs/socketio` can be used standalone or together with a Feathers framework integration like Express.\n### socketio() ​\n`app.configure(socketio())` sets up the Socket.io transport with the default configuration using either the server provided by app.listen or passed in app.setup(server).ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio'\n\nconst app = feathers()\n\napp.configure(socketio())\n\napp.listen(3030)\n```\nImportantOnce the server has been started with `app.listen()` or `app.setup(server)` the Socket.io object is available as `app.io`. Usually you should not have to send or listen to events on `app.io` directly.\n### socketio(callback) ​\n`app.configure(socketio(callback))` sets up the Socket.io transport with the default configuration and call `callback` with the Socket.io server object.ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio'\n\nconst app = feathers()\n\napp.configure(\n  socketio((io) => {\n    io.on('connection', (socket) => {\n      // Do something here\n    })\n\n    // Registering Socket.io middleware\n    io.use(function (socket, next) {\n      // Exposing a request property to services and hooks\n      socket.feathers.referrer = socket.request.referrer\n      next()\n    })\n  })\n)\n\napp.listen(3030)\n```\ndangerTry to avoid listening and sending events on the `socket` directly since it circumvents Feathers secure dispatch mechanisms available through channels and hooks.\n#### Using uWebSockets.js ​\nuWS can be used as a drop in replacement for socket handling. As a result you'll see lower latencies, a better memory footprint and even slightly less overall resource usage. You will on the other hand need to install the following extra package to get things working.\n```\nnpm install uNetworking/uWebSockets.js#20.31.0 --save\n```\nNow you can use the `io.attachApp` function to attach uWS as a replacement.ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio'\nimport { App } from 'uWebSockets.js'\n\nconst app = feathers()\n\napp.configure(\n  socketio((io) => {\n    io.attachApp(App())\n  })\n)\n\napp.listen(3030)\n```\n\n### socketio(options [, callback]) ​\n`app.configure(socketio(options [, callback]))` sets up the Socket.io transport with the given Socket.io options object and optionally calls the callback described above.This can be used to e.g. configure the path where Socket.io is initialize (`socket.io/` by default). The following changes the path to `ws/`:ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio'\n\nconst app = feathers()\n\napp.configure(\n  socketio(\n    {\n      path: '/ws/'\n    },\n    (io) => {\n      // Do something here\n      // This function is optional\n    }\n  )\n)\n\napp.listen(3030)\n```\n\n### socketio(port, [options], [callback]) ​\n`app.configure(socketio(port, [options], [callback]))` creates a new Socket.io server on a separate port. Options and a callback are optional and work as described above.ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio'\n\nconst app = feathers()\n\napp.configure(socketio(3031))\napp.listen(3030)\n```\n\n## params ​\nSocket.io middleware can modify the `feathers` property on the `socket` which will then be used as the service call `params`:ts\n```\napp.configure(\n  socketio((io) => {\n    io.use((socket, next) => {\n      socket.feathers.user = { name: 'David' }\n      next()\n    })\n  })\n)\n\napp.use('messages', {\n  async create(data, params, callback) {\n    // When called via SocketIO:\n    params.provider // -> socketio\n    params.user // -> { name: 'David' }\n    return data\n  }\n})\n```\ninfo`socket.feathers` is the same object as the `connection` in a channel. `socket.request` and `socket.handshake` contains information the HTTP request that initiated the connection (see the Socket.io documentation).\n### params.provider ​\nFor any service method call made through Socket.io `params.provider` will be set to `socketio`. In a hook this can for example be used to prevent external users from making a service method call:js\n```\napp.service('users').hooks({\n  before: {\n    remove(context) {\n      // check for if(context.params.provider) to prevent any external call\n      if (context.params.provider === 'socketio') {\n        throw new Error('You can not delete a user via Socket.io')\n      }\n    }\n  }\n})\n```\n",
    "version": "v5",
    "tokens": [
      "socket",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "npm",
      "install",
      "feathersjs",
      "socketio",
      "save",
      "the",
      "module",
      "allows",
      "call",
      "service",
      "methods",
      "and",
      "receive",
      "real",
      "time",
      "events",
      "via",
      "nodejs",
      "library",
      "which",
      "enables",
      "directional",
      "event",
      "based",
      "communication",
      "importantthis",
      "page",
      "describes",
      "how",
      "set",
      "server",
      "client",
      "chapter",
      "shows",
      "connect",
      "this",
      "message",
      "format",
      "for",
      "calls",
      "configuration",
      "can",
      "used",
      "standalone",
      "together",
      "with",
      "framework",
      "integration",
      "like",
      "express",
      "app",
      "configure",
      "sets",
      "transport",
      "default",
      "using",
      "either",
      "provided",
      "listen",
      "passed",
      "setup",
      "import",
      "from",
      "const",
      "importantonce",
      "has",
      "been",
      "started",
      "object",
      "available",
      "usually",
      "you",
      "should",
      "not",
      "have",
      "send",
      "directly",
      "callback",
      "connection",
      "something",
      "here",
      "registering",
      "middleware",
      "use",
      "function",
      "next",
      "exposing",
      "request",
      "property",
      "services",
      "hooks",
      "referrer",
      "dangertry",
      "avoid",
      "listening",
      "sending",
      "since"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-channels",
    "title": "Channels",
    "content": "Channels | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Channels ​\nOn a Feathers server with a real-time transport (like Socket.io) configured, event channels determine which connected clients to send real-time events to and how the sent data should look.This chapter describes:Concepts of real-time communication\n• An example channels.js file\n• Real-time Connections and how to access them\n• Channel usage and how to retrieve, join and leave channels\n• Publishing events to channels\n\nImportant\n\nChannels functionality will not be available in the following two scenarios:\n• When you're making a rest-only API, not using a real-time adapter.\n• When you're using Feathers on the client. Only server-side Feathers has channel management.\n\nHere are some example logic conditions where channels are useful:\n• Real-time events should only be sent to authenticated users\n• Users should only get updates about messages from chat rooms they joined\n• Only users in the same organization should receive real-time updates about their data changes\n• Only admins should be notified when new users are created\n• When a user is created, modified or removed, non-admins should only receive a \"safe\" version of the user object (e.g. only `email`, `id` and `avatar`)\n\n## Concepts ​\n\nA channel is basically an array of connection objects. Each array is explicitly given a name. When using a real-time server transport and a new client connects, you can tell the server to explicitly add that client's connection object to any relevant channels. Any connection in a channel will receive all events that are sent to that channel. This allows clients to receive only their intended messages.\n\nWhen using a real-time transport, the server pushes events (such as \"created\", \"removed\" etc. for a particular service) down to its clients. Using channels allows customizing which clients should receive each event. The client doesn’t subscribe to individual channels, directly, but rather subscribes to specific events like `created`, `patched`, custom events, etc, in which they are interested. Those events will only fire for a client if the server pushes data to one a channel to which the client has been added.\n\nYou can have any number of channels. This helps to organise how data is sent and to control the volume of data, by not sending things that aren't relevant.\n\nThe server can also change connection channel membership from time to time, eg. before vs after login.\n\nThe server needs to explicitly publish channels it is interested in sharing with clients before they become available.\n\n## Example ​\n\nThe example below shows a `channels.js` file illustrating how the different parts fit together:\n\nts\n```\nimport type { RealTimeConnection, Params } from '@feathersjs/feathers'\nimport type { Application, HookContext } from './declarations'\n\nexport default function (app: any) {\n  if (typeof app.channel !== 'function') {\n    // If no real-time functionality has been configured just return\n    return\n  }\n\n  app.on('connection', (connection: RealTimeConnection) => {\n    // On a new real-time connection, add it to the anonymous channel\n    app.channel('anonymous').join(connection)\n  })\n\n  app.on('login', (AuthenticationResult: any, { connection }: Params) => {\n    // connection can be undefined if there is no\n    // real-time connection, e.g. when logging in via REST\n    if (connection) {\n      // The connection is no longer anonymous, remove it\n      app.channel('anonymous').leave(connection)\n\n      // Add it to the authenticated user channel\n      app.channel('authenticated').join(connection)\n    }\n  })\n\n  // eslint-disable-next-line no-unused-vars\n  app.publish((data: any, context: HookContext) => {\n    // Here you can add event publishers to channels set up in `channels.js`\n    // To publish only for a specific event use `app.publish(eventname, () => {})`\n    console.log(\n      'Publishing all events to all authenticated users. See `channels.js` and https://docs.feathersjs.com/api/channels.html for more information.'\n    )\n\n    // e.g. to publish all service events to all authenticated users use\n    return app.channel('authenticated')\n  })\n}\n```\n\n## Connections ​\n\nA connection is an object that represents a real-time connection. It is the same object as `socket.feathers` in a Socket.io middleware. You can add any kind of information to it but most notably, when using authentication, it will contain the authenticated user. By default it is located in `connection.user` once the client has authenticated on the socket (usually by calling `app.authenticate()` on the client).\n\nWe can get access to the `connection` object by listening to `app.on('connection', connection => {})` or `app.on('login', (payload, { connection }) => {})`.\n\nNote\n\nWhen a connection is terminated it will be automatically removed from all channels.\n\n### app.on('connection') ​\n\n`app.on('connection', connection => {})` is fired every time a new real-time connection is e",
    "version": "v5",
    "tokens": [
      "channels",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "server",
      "with",
      "real",
      "time",
      "transport",
      "like",
      "socket",
      "configured",
      "event",
      "determine",
      "which",
      "connected",
      "clients",
      "send",
      "events",
      "and",
      "how",
      "the",
      "sent",
      "data",
      "should",
      "look",
      "this",
      "chapter",
      "describes",
      "concepts",
      "communication",
      "example",
      "file",
      "connections",
      "access",
      "them",
      "channel",
      "usage",
      "retrieve",
      "join",
      "leave",
      "publishing",
      "important",
      "functionality",
      "will",
      "not",
      "available",
      "following",
      "two",
      "scenarios",
      "when",
      "you",
      "making",
      "rest",
      "only",
      "api",
      "using",
      "adapter",
      "client",
      "side",
      "has",
      "management",
      "here",
      "are",
      "some",
      "logic",
      "conditions",
      "where",
      "useful",
      "authenticated",
      "users",
      "get",
      "updates",
      "about",
      "messages",
      "from",
      "chat",
      "rooms",
      "they",
      "joined",
      "same",
      "organization",
      "receive",
      "their",
      "changes",
      "admins",
      "notified",
      "new",
      "created",
      "user",
      "modified",
      "removed",
      "non",
      "safe",
      "version",
      "object",
      "email",
      "avatar",
      "basically",
      "array",
      "connection",
      "objects",
      "each",
      "explicitly",
      "given",
      "name",
      "connects",
      "can",
      "tell",
      "add",
      "that",
      "any",
      "relevant",
      "all",
      "allows",
      "intended",
      "pushes",
      "such",
      "etc",
      "for",
      "particular",
      "service",
      "down",
      "its",
      "customizing",
      "doesn",
      "subscribe",
      "individual",
      "directl"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-client",
    "title": "Feathers Client",
    "content": "Feathers Client | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Feathers Client ​\nOne of the most notable features of Feathers is that it can also be used as the client. In contrast with most other frameworks, it isn't a separate library; instead you get the exact same functionality with a client and on a server. This means you can use services and hooks and configure plugins. By default, a Feathers client automatically creates services that talk to a Feathers server.In order to connect to a Feathers server, a client creates Services that use a REST or websocket connection to relay method calls and - for a real-time transport like Socket.io - allow listening to events on the server. This means the Feathers application instance is usable the exact same way as on the server.Modules most relevant on the client are:`@feathersjs/feathers` to initialize a new Feathers application\n• @feathersjs/rest-client to connect to services through REST HTTP provided by Koa or Express.\n• @feathersjs/socketio-client to connect to services through Socket.io.\n• @feathersjs/authentication-client to authenticate a client\n\nImportant\n\nYou do not have to use Feathers on the client to connect to a Feathers server. The client REST client and Socket.io client chapters also describe how to use the connection directly without Feathers on the client side.\n\nThis chapter describes how to set up Feathers as the client in Node, React Native and in the browser with a module loader like Webpack or Parcel or through a `` tag. The examples are using the Socket.io client. For other connection methods see the chapters linked above.\n\n## Typed client ​\n\nA Feathers application generated with Feathers v5 or later now exports a client file, including the types you defined in schemas on the server. For more information see the CLI guide\n\n## Node ​\n\nTo connect to a Feathers server in NodeJS, install the desired client connection library (here, `socket.io-client`), alongside the Feathers core library, and the connection-specific library:\n\n```\nnpm install @feathersjs/feathers @feathersjs/socketio-client socket.io-client --save\n```\n\nThen initialize like this:\n\nts\n```\nimport io from 'socket.io-client'\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\n\nconst socket = io('http://api.my-feathers-server.com')\nconst client = feathers()\n\nclient.configure(socketio(socket))\n\nconst messageService = client.service('messages')\n\nmessageService.on('created', (message: Message) => console.log('Created a message', message))\n\n// Use the messages service from the server\nmessageService.create({\n  text: 'Message from client'\n})\n```\n\n## React Native ​\n\nReact Native usage is the same as for the Node client. Install the required packages into your React Native project.\n\nbash\n```\nnpm install @feathersjs/feathers @feathersjs/socketio-client socket.io-client\n```\n\nThen in the main application file:\n\nts\n```\nimport io from 'socket.io-client'\nimport { AsyncStorage } from 'react-native'\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport authentication from '@feathersjs/authentication-client'\n\nconst socket = io('http://api.my-feathers-server.com', {\n  transports: ['websocket'],\n  forceNew: true\n})\nconst client = feathers()\n\nclient.configure(socketio(socket))\nclient.configure(\n  authentication({\n    storage: AsyncStorage\n  })\n)\n\nconst messageService = client.service('messages')\n\nmessageService.on('created', (message: Message) => console.log('Created a message', message))\n\n// Use the messages service from the server\nmessageService.create({\n  text: 'Message from client'\n})\n```\n\nSince React Native for Android doesn't handle timeouts exceeding one minute, consider setting lower values for `pingInterval` and `pingTimeout` of Socket.io on your server. This will stop warnings related to this issue. For example:\n\njs\n```\nimport socketio from '@feathersjs/socketio'\n\nconst app = feathers()\n\napp.configure(\n  socketio({\n    pingInterval: 10000,\n    pingTimeout: 50000\n  })\n)\n```\n\n## Module loaders ​\n\nFeathers client libraries work with the out-of-the-box configuration of all modern module loaders like Webpack, Parcel, Vite etc.\n\n### Webpack ​\n\nNo additional setup should be necessary to use the Feathers client modules in a standard configuration with Webpack.\n\n### create-react-app ​\n\ncreate-react-app uses Webpack and also no longer requires additional setup to load the individual Feathers client modules.\n\n### Others ​\n\nFor non-CommonJS formats (like AMD) version of Feathers and its client modules the @feathersjs/client module can be used.\n\n## @feathersjs/client ​\n\n```\nnpm install @feathersjs/client --save\n```\n\n`@feathersjs/client` is a module that bundles the separate Feathers client-side modules into one file which can be loaded directly in the browser through a `` tag and in most other JavaScript runtimes.\n\nImportant\n\nIf you are using a module loader like Webp",
    "version": "v5",
    "tokens": [
      "feathers",
      "client",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "one",
      "the",
      "most",
      "notable",
      "features",
      "that",
      "can",
      "also",
      "used",
      "contrast",
      "with",
      "other",
      "frameworks",
      "isn",
      "separate",
      "library",
      "instead",
      "you",
      "get",
      "exact",
      "same",
      "functionality",
      "and",
      "server",
      "this",
      "means",
      "use",
      "services",
      "hooks",
      "configure",
      "plugins",
      "default",
      "automatically",
      "creates",
      "talk",
      "order",
      "connect",
      "rest",
      "websocket",
      "connection",
      "relay",
      "method",
      "calls",
      "for",
      "real",
      "time",
      "transport",
      "like",
      "socket",
      "allow",
      "listening",
      "events",
      "application",
      "instance",
      "usable",
      "way",
      "modules",
      "relevant",
      "are",
      "feathersjs",
      "initialize",
      "new",
      "through",
      "http",
      "provided",
      "koa",
      "express",
      "socketio",
      "authentication",
      "authenticate",
      "important",
      "not",
      "have",
      "chapters",
      "describe",
      "how",
      "directly",
      "without",
      "side",
      "chapter",
      "describes",
      "set",
      "node",
      "react",
      "native",
      "browser",
      "module",
      "loader",
      "webpack",
      "parcel",
      "tag",
      "examples",
      "using",
      "methods",
      "see",
      "linked",
      "above",
      "typed",
      "generated",
      "later",
      "now",
      "exports",
      "file",
      "including",
      "types",
      "defined",
      "schemas",
      "more",
      "information",
      "cli",
      "guide",
      "nodejs",
      "install",
      "desired",
      "here"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-client-rest",
    "title": "REST Client",
    "content": "REST Client | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# REST Client ​\nThe following chapter describes the use of@feathersjs/rest-client as a client side Feathers HTTP API integration\n• Direct connection with any other HTTP client\n\n## rest-client ​\n\n```\nnpm install @feathersjs/rest-client --save\n```\n\n`@feathersjs/rest-client` allows to connect to a service exposed through a REST HTTP transport (e.g. with Koa or Express) using fetch, Superagent or Axios.\n\ninfo\n\nFor directly using a Feathers REST API (via HTTP) without using Feathers on the client see the HTTP API section.\n\ntip\n\nREST client services do emit `created`, `updated`, `patched` and `removed` events but only locally for their own instance. Real-time events from other clients can only be received by using a real-time transport like Socket.io.\n\nwarning\n\nA client application can only use a single transport (e.g. either REST or Socket.io). Using two transports in the same client application is not necessary.\n\n### rest([baseUrl]) ​\n\nREST client services can be initialized by loading `@feathersjs/rest-client` and initializing a client object with a base URL.\n\nts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\n\nconst app = feathers()\n\n// Connect to the same as the browser URL (only in the browser)\nconst restClient = rest()\n\n// Connect to a different URL\nconst restClient = rest('http://feathers-api.com')\n\n// Configure an AJAX library (see below) with that client\napp.configure(restClient.fetch(window.fetch.bind(window)))\n\n// Connect to the `http://feathers-api.com/messages` service\nconst messages = app.service('messages')\n```\n\nThe base URL is relative from where services are registered. That means that\n• A service at `http://api.feathersjs.com/api/v1/messages` with a base URL of `http://api.feathersjs.com` would be available as `app.service('api/v1/messages')`\n• A base URL of `http://api.feathersjs.com/api/v1` would be `app.service('messages')`.\n\nimportant\n\nIn the browser `window.fetch` (which the same as the global `fetch`) has to be passed as `window.fetch.bind(window)` otherwise it will be called with an incorrect context, causing a JavaScript error: `Failed to execute 'fetch' on 'Window': Illegal invocation`.\n\n### params.headers ​\n\nRequest specific headers can be through `params.headers` in a service call:\n\njs\n```\napp.service('messages').create(\n  {\n    text: 'A message from a REST client'\n  },\n  {\n    headers: { 'X-Requested-With': 'FeathersJS' }\n  }\n)\n```\n\n### params.connection ​\n\nAllows to pass additional options specific to the AJAX library. `params.connection.headers` will be merged with `params.headers`:\n\njs\n```\napp.configure(restClient.axios(axios))\n\napp.service('messages').get(1, {\n  connection: {\n    // Axios specific options here\n  }\n})\n```\n\n### app.rest ​\n\n`app.rest` contains a reference to the `connection` object passed to `rest().(connection)`.\n\n### Request libraries ​\n\nThe Feathers REST client can be used with several HTTP request libraries.\n\n#### Fetch ​\n\nThe Fetch API is the recommended way to make client connections since it does not require a third party library on most platforms:\n\njs\n```\n// In Node\napp.configure(restClient.fetch(fetch))\n\n// In modern browsers\napp.configure(restClient.fetch(window.fetch.bind(window)))\n```\n\nWhere supported, an AbortController can be used to abort fetch requests:\n\njs\n```\nconst controller = new AbortController()\n\napp.configure(restClient.fetch(fetch))\n\napp.service('messages').get(1, {\n  connection: {\n    signal: controller.signal\n  }\n})\n\ncontroller.abort()\n```\n\n#### Superagent ​\n\nSuperagent currently works with a default configuration:\n\nts\n```\nimport superagent from 'superagent'\n\napp.configure(restClient.superagent(superagent))\n```\n\n#### Axios ​\n\nAxios currently works with a default configuration:\n\njs\n```\nimport axios from 'axios'\n\napp.configure(restClient.axios(axios))\n```\n\nTo use default values for all requests, `axios.create` with the axios configuration can be used:\n\njs\n```\nimport axios from 'axios'\n\napp.configure(\n  restClient.axios(\n    axios.create({\n      headers: { 'X-Requested-With': 'My-Feathers-Frontend' }\n    })\n  )\n)\n```\n\n### Custom Methods ​\n\nOn the client, custom service methods registered using the `methods` option when registering the service via `restClient.service()`:\n\nts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params } from '@feathersjs/feathers'\nimport rest from '@feathersjs/rest-client'\nimport type { RestService } from '@feathersjs/rest-client'\n\n// `data` and return type of custom method\ntype CustomMethodData = { name: string }\ntype CustomMethodResponse = { acknowledged: boolean }\n\ntype ServiceTypes = {\n  // The type is a RestService extended with custom methods\n  myservice: RestService & {\n    myCustomMethod(data: CustomMethodData, params: Params): Promise\n  }\n}\n\nconst client = feathers()\n\n// Connect to the same as the browser URL (only in the browser)\nconst restCli",
    "version": "v5",
    "tokens": [
      "rest",
      "client",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "the",
      "following",
      "chapter",
      "describes",
      "use",
      "feathersjs",
      "side",
      "http",
      "api",
      "integration",
      "direct",
      "connection",
      "with",
      "any",
      "other",
      "npm",
      "install",
      "save",
      "allows",
      "connect",
      "service",
      "exposed",
      "through",
      "transport",
      "koa",
      "express",
      "using",
      "fetch",
      "superagent",
      "axios",
      "info",
      "for",
      "directly",
      "via",
      "without",
      "see",
      "section",
      "tip",
      "services",
      "emit",
      "created",
      "updated",
      "patched",
      "and",
      "removed",
      "events",
      "but",
      "only",
      "locally",
      "their",
      "own",
      "instance",
      "real",
      "time",
      "from",
      "clients",
      "can",
      "received",
      "like",
      "socket",
      "warning",
      "application",
      "single",
      "either",
      "two",
      "transports",
      "same",
      "not",
      "necessary",
      "baseurl",
      "initialized",
      "loading",
      "initializing",
      "object",
      "base",
      "url",
      "import",
      "const",
      "app",
      "browser",
      "restclient",
      "different",
      "com",
      "configure",
      "ajax",
      "library",
      "below",
      "that",
      "window",
      "bind",
      "messages",
      "relative",
      "where",
      "are",
      "registered",
      "means",
      "would",
      "available",
      "wou"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-client-socketio",
    "title": "Socket.io Client",
    "content": "Socket.io Client | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Socket.io Client ​\n\n## socketio-client ​\n\n```\nnpm install @feathersjs/socketio-client socket.io-client --save\n```\nThe `@feathersjs/socketio-client` module allows to connect to services exposed through the Socket.io transport via a Socket.io socket. We recommend using Feathers and the `@feathersjs/socketio-client` module on the client if possible since it can also handle reconnection and reauthentication. If however, you want to use a direct Socket.io connection without using Feathers on the client, see the Direct connection section.ImportantSocket.io is also used to call service methods. Using sockets for both calling methods and receiving real-time events is generally faster than using REST. There is therefore no need to use both REST and Socket.io in the same client application.\n### socketio(socket) ​\nInitialize the Socket.io client using a given socket and the default options.ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport io from 'socket.io-client'\n\nconst socket = io('http://api.feathersjs.com')\nconst app = feathers()\n\n// Set up Socket.io client with the socket\napp.configure(socketio(socket))\n\n// Receive real-time events through Socket.io\napp.service('messages').on('created', (message) => console.log('New message created', message))\n\n// Call the `messages` service\napp.service('messages').create({\n  text: 'A message from a REST client'\n})\n```\n\n### `app.io` ​\n`app.io` contains a reference to the `socket` object passed to `socketio(socket [, options])`ts\n```\napp.io.on('disconnect', (reason: any) => {\n  // Show offline message\n})\n```\n\n### Custom Methods ​\nOn the client, custom service methods are also registered using the `methods` option when registering the service via `socketClient.service()`:ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport type { Params } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport type { SocketService } from '@feathersjs/socketio-client'\nimport io from 'socket.io-client'\n\n// `data` and return type of custom method\ntype CustomMethodData = { name: string }\ntype CustomMethodResponse = { acknowledged: boolean }\n\ntype ServiceTypes = {\n  // The type is a Socket service extended with custom methods\n  myservice: SocketService & {\n    myCustomMethod(data: CustomMethodData, params: Params): Promise\n  }\n}\n\nconst socket = io('http://api.feathersjs.com')\nconst client = feathers()\nconst socketClient = socketio(socket)\n\n// Set up Socket.io client with the socket\nclient.configure(socketClient)\n\n// Register a socket client service with all methods listed\nclient.use('myservice', socketClient.service('myservice'), {\n  methods: ['find', 'get', 'create', 'update', 'patch', 'remove', 'myCustomMethod']\n})\n\n// Then it can be used like other service methods\nclient.service('myservice').myCustomMethod(data, params)\n```\ninfoJust like on the server all methods you want to use have to be listed in the `methods` option.\n### Route placeholders ​\nService URLs can have placeholders, e.g. `users/:userId/messages`. (see in express or koa)You can call the client with route placeholders in the `params.route` property:ts\n```\nimport { feathers } from '@feathersjs/feathers'\nimport socketio from '@feathersjs/socketio-client'\nimport io from 'socket.io-client'\n\nconst socket = io('http://api.feathersjs.com')\nconst app = feathers()\n\n// Set up Socket.io client with the socket\napp.configure(socketio(socket))\n\n// Call `users/2/messages`\napp.service('users/:userId/messages').find({\n  route: {\n    userId: 2\n  }\n})\n```\nThis can also be achieved by using the client bundled, sharing several `servicePath` variable exported in the service shared file file.ts\n```\nimport rest from '@feathersjs/rest-client'\n\nconst connection = rest('https://myapp.com').fetch(window.fetch.bind(window))\n\nconst client = createClient(connection)\n\n// Call the `https://myapp.com/users/2/messages` URL\nclient.service(usersMyMessagesPath).find({\n  route: {\n    userId: 2\n  }\n})\n\nimport io from 'socket.io-client'\nimport socketio from '@feathersjs/socketio-client'\nimport { createClient, usersMessagesPath } from 'my-app'\n\nconst socket = io('http://api.my-feathers-server.com')\nconst connection = socketio(socket)\n\nconst client = createClient(connection)\n\nconst messageService = client.service('users/:userId/messages')\n\n// Call `users/2/messages`\napp.service('users/:userId/messages').find({\n  route: {\n    userId: 2\n  }\n})\n```\n\n## Direct connection ​\nFeathers sets up a normal Socket.io server that you can connect to with any Socket.io compatible client, usually the Socket.io client either by loading the `socket.io-client` module or `/socket.io/socket.io.js` from the server. Query parameter types do not have to be converted from strings as they do for REST requests.ImportantThe socket connection URL has to point to the server root which is where Feathers ",
    "version": "v5",
    "tokens": [
      "socket",
      "client",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "socketio",
      "npm",
      "install",
      "feathersjs",
      "save",
      "the",
      "module",
      "allows",
      "connect",
      "services",
      "exposed",
      "through",
      "transport",
      "via",
      "recommend",
      "using",
      "and",
      "possible",
      "since",
      "can",
      "also",
      "handle",
      "reconnection",
      "reauthentication",
      "however",
      "you",
      "want",
      "use",
      "direct",
      "connection",
      "without",
      "see",
      "section",
      "importantsocket",
      "used",
      "call",
      "service",
      "methods",
      "sockets",
      "for",
      "both",
      "calling",
      "receiving",
      "real",
      "time",
      "events",
      "generally",
      "faster",
      "than",
      "rest",
      "there",
      "therefore",
      "need",
      "same",
      "application",
      "initialize",
      "given",
      "default",
      "options",
      "import",
      "from",
      "const",
      "http",
      "api",
      "com",
      "app",
      "set",
      "with",
      "configure",
      "receive",
      "messages",
      "created",
      "message",
      "console",
      "log",
      "new",
      "create",
      "text",
      "contains",
      "reference",
      "object",
      "passed",
      "disconnect",
      "reason",
      "any",
      "show",
      "offline",
      "custom",
      "are",
      "registered",
      "option",
      "when",
      "registering",
      "socketclient",
      "type",
      "params"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-schema",
    "title": "Schema Overview",
    "content": "Schema Overview | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Schema Overview ​\n`@feathersjs/schema` provides a way to define data models and to dynamically resolve them. It comes in in the following main parts:JSON schema using TypeBox or plain JSON schema to define a data model with TypeScript types and validations. This allows us to: Automatically get TypeScript types from schema definitions\n• Automatically generate API documentation\n• Create database adapter models without duplicating the data format\n• Validators take a TypeBox or JSON schema to validate data to Ensure data is valid and always in the right format\n• Validate query string queries and convert them to the right type\n• Resolvers - Resolve properties based on a context (usually the hook context). This can be used for many different things like: Adding default and computed values\n• Populating associations\n• Securing queries and e.g. limiting requests to a user\n• Removing protected properties for external requests\n• Ability to add read- and write permissions on the property level\n• Hashing passwords and validating dynamic password policies\n\n Suggest changes to this page\n\nLast updated: \n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors\n\n feathers \n\n• About\n• Philosophy\n• Comparison\n• Ecosystem\n• Learn\n• Guides\n• API\n• Blog\n• Ecosystem\n• Become a Backer\n• Find Help\n• Github Issues\n\nReleased under the MIT License.\n\nCopyright © 2012-2026 FeathersJS contributors",
    "version": "v5",
    "tokens": [
      "schema",
      "overview",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "feathersjs",
      "provides",
      "way",
      "define",
      "data",
      "models",
      "and",
      "dynamically",
      "resolve",
      "them",
      "comes",
      "the",
      "following",
      "main",
      "parts",
      "json",
      "using",
      "typebox",
      "plain",
      "model",
      "with",
      "typescript",
      "types",
      "validations",
      "this",
      "allows",
      "automatically",
      "get",
      "from",
      "definitions",
      "generate",
      "api",
      "documentation",
      "create",
      "database",
      "adapter",
      "without",
      "duplicating",
      "format",
      "validators",
      "take",
      "validate",
      "ensure",
      "valid",
      "always",
      "right",
      "query",
      "string",
      "queries",
      "convert",
      "type",
      "resolvers",
      "properties",
      "based",
      "context",
      "usually",
      "hook",
      "can",
      "used",
      "for",
      "many",
      "different",
      "things",
      "like",
      "adding",
      "default",
      "computed",
      "values",
      "populating",
      "associations",
      "securing",
      "limiting",
      "requests",
      "user",
      "removing",
      "protected",
      "external",
      "ability",
      "add",
      "read",
      "write",
      "permissions",
      "property",
      "level",
      "hashing",
      "passwords",
      "validating",
      "dynamic",
      "password",
      "policies",
      "suggest",
      "changes",
      "page",
      "last",
      "updated",
      "released",
      "under",
      "mit",
      "license",
      "copyright",
      "contributors",
      "about",
      "philosophy",
      "comparison",
      "ecosystem",
      "learn",
      "guides",
      "blog",
      "become",
      "backer",
      "find",
      "help",
      "github",
      "issues"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-schema-typebox",
    "title": "TypeBox",
    "content": "TypeBox | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# TypeBox ​\n`@feathersjs/typebox` allows to define JSON schemas with TypeBox, a JSON schema type builder with static type resolution for TypeScript.NoteFor additional information also see the TypeBox documentation.\n## Usage ​\nThe module exports all of TypeBox functionality with additional support for query schemas and validators. The following is an example for defining the message schema from the guide using TypeBox:ts\n```\nimport { Type } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\n\nconst messageSchema = Type.Object(\n  {\n    id: Type.Number(),\n    text: Type.String(),\n    createdAt: Type.Number(),\n    userId: Type.Number()\n  },\n  { $id: 'Message', additionalProperties: false }\n)\n\ntype Message = Static\n```\n\n## Result and data schemas ​\nA good approach to define schemas in a Feathers application is to create the main schema first. This is usually the properties that are in the database and things like associated entries. Then we can get the data schema by e.g. picking the properties a client submits using `Type.Pick`ts\n```\nimport { Type } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\n\nconst userSchema = Type.Object(\n  {\n    id: Type.Number(),\n    email: Type.String(),\n    password: Type.String(),\n    avatar: Type.Optional(Type.String())\n  },\n  { $id: 'User', additionalProperties: false }\n)\ntype User = Static\n\n// Pick the data for creating a new user\nconst userDataSchema = Type.Pick(userSchema, ['email', 'password'])\n\ntype UserData = Static\n\nconst messageSchema = Type.Object(\n  {\n    id: Type.Number(),\n    text: Type.String(),\n    createdAt: Type.Number(),\n    userId: Type.Number(),\n    // Reference the user\n    user: Type.Ref(userSchema)\n  },\n  { $id: 'Message', additionalProperties: false }\n)\n\ntype Message = Static\n\n// Pick the data for creating a new message\nconst messageDataSchema = Type.Pick(messageSchema, ['text'])\n\ntype MessageData = Static\n```\n\n## Query schemas ​\n\n### querySyntax ​\n`querySyntax(definition, extensions, options)` returns a schema to validate the Feathers query syntax for all properties in a TypeBox definition.ts\n```\nimport { querySyntax } from '@feathersjs/typebox'\n\n// Schema for allowed query properties\nconst messageQueryProperties = Type.Pick(messageSchema, ['id', 'text', 'createdAt', 'userId'], {\n  additionalProperties: false\n})\nconst messageQuerySchema = querySyntax(messageQueryProperties)\n\ntype MessageQuery = Static\n```\nAdditional special query properties that are not already included in the query syntax like `$ilike` can be added like this:ts\n```\nimport { querySyntax } from '@feathersjs/typebox'\n\n// Schema for allowed query properties\nconst messageQueryProperties = Type.Pick(messageSchema, ['id', 'text', 'createdAt', 'userId'], {\n  additionalProperties: false\n})\nconst messageQuerySchema = Type.Intersect(\n  [\n    // This will additionally allow querying for `{ name: { $ilike: 'Dav%' } }`\n    querySyntax(messageQueryProperties, {\n      name: {\n        $ilike: Type.String()\n      }\n    }),\n    // Add additional query properties here\n    Type.Object({})\n  ],\n  { additionalProperties: false }\n)\n```\nTo allow additional query properties outside of the query syntax use the intersection type:ts\n```\nimport { querySyntax } from '@feathersjs/typebox'\n\n// Schema for allowed query properties\nconst messageQueryProperties = Type.Pick(messageSchema, ['id', 'text', 'createdAt', 'userId'], {\n  additionalProperties: false\n})\nconst messageQuerySchema = Type.Intersect(\n  [\n    querySyntax(messageQueryProperties),\n    Type.Object({\n      isActive: Type.Boolean()\n    })\n  ],\n  { additionalProperties: false }\n)\n\ntype MessageQuery = Static\n```\n\n### queryProperty ​\n`queryProperty(definition)` returns a schema for the Feathers query syntax for a single property.\n## Validators ​\nThe following functions are available to get a validator function from a TypeBox schema.noteSee the validators chapter for more information on validators and validator functions.\n### getDataValidator ​\n`getDataValidator(definition, validator)` returns validators for the data of `create`, `update` and `patch` service methods. You can either pass a single definition in which case all properties of the `patch` schema will be optional or individual validators for `create`, `update` and `patch`.ts\n```\nimport { Ajv } from '@feathersjs/schema'\nimport { Type, getDataValidator } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\n\nconst userSchema = Type.Object(\n  {\n    id: Type.Number(),\n    email: Type.String(),\n    password: Type.String(),\n    avatar: Type.Optional(Type.String())\n  },\n  { $id: 'User', additionalProperties: false }\n)\ntype User = Static\n\n// Pick the data for creating a new user\nconst userDataSchema = Type.Pick(userSchema, ['email', 'password'])\n\nconst dataValidator = new Ajv()\n\nconst userDataValidator = getDataValidator(userDataSchema, dataVal",
    "version": "v5",
    "tokens": [
      "typebox",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "feathersjs",
      "allows",
      "define",
      "json",
      "schemas",
      "with",
      "schema",
      "type",
      "builder",
      "static",
      "resolution",
      "for",
      "typescript",
      "notefor",
      "additional",
      "information",
      "also",
      "see",
      "the",
      "documentation",
      "usage",
      "module",
      "exports",
      "all",
      "functionality",
      "support",
      "query",
      "and",
      "validators",
      "following",
      "example",
      "defining",
      "message",
      "from",
      "guide",
      "using",
      "import",
      "const",
      "messageschema",
      "object",
      "number",
      "text",
      "string",
      "createdat",
      "userid",
      "additionalproperties",
      "false",
      "result",
      "data",
      "good",
      "approach",
      "application",
      "create",
      "main",
      "first",
      "this",
      "usually",
      "properties",
      "that",
      "are",
      "database",
      "things",
      "like",
      "associated",
      "entries",
      "then",
      "can",
      "get",
      "picking",
      "client",
      "submits",
      "pick",
      "userschema",
      "email",
      "password",
      "avatar",
      "optional",
      "user",
      "creating",
      "new",
      "userdataschema",
      "userdata",
      "reference",
      "ref",
      "messagedataschema",
      "messa"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-schema-schema",
    "title": "JSON Schema",
    "content": "JSON Schema | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# JSON Schema ​\nAs an alternative to TypeBox, `@feathersjs/schema` also provides the ability to define plain JSON schemas as objects. It uses json-schema-to-ts to turn those schemas into TypeScript types.Need JSON Schema help?You can find an introduction in the JSON schema official getting started guide and a lot of type-specific JSON Schema examples in the json-schema-to-ts docs.\n## Creating Schemas ​\n\n### Definitions ​\nIf you are not familiar with JSON schema have a look at the official getting started guide. Here is an example for a possible user schema:ts\n```\nimport type { FromSchema } from '@feathersjs/schema'\n\nexport const userSchema = {\n  $id: 'User',\n  type: 'object',\n  additionalProperties: false,\n  required: ['email', 'password'],\n  properties: {\n    id: { type: 'number' },\n    email: { type: 'string' },\n    password: { type: 'string' }\n  }\n} as const\n\nexport type User = FromSchema\n```\n\n### Generating Correct Types ​\nFor correct TypeScript types, the definition always needs to be declared `as const`. This first example will not produce correct types because the definition is not immediately followed by `as const`:ts\n```\n// Will not produce correct types.\nconst definition = { type: 'object' } // `as const` is missing, here.\n```\nThis next example does declare `as const` after the `definition`, so the types will be generated correctly:ts\n```\n// Produces correct types.\nconst definition = { type: 'object' } as const\n```\n\n## Extending Schemas ​\nTo create a new schema that extends an existing one, combine the schema properties (and `schema.required`, if used) with the new properties:ts\n```\nimport type { FromSchema } from '@feathersjs/schema'\n\nexport const userDataSchema = {\n  $id: 'User',\n  type: 'object',\n  additionalProperties: false,\n  required: ['email', 'password'],\n  properties: {\n    email: { type: 'string' },\n    password: { type: 'string' }\n  }\n} as const\n\nexport type UserData = FromSchema\n\nexport const userSchema = {\n  $id: 'UserResult',\n  type: 'object',\n  additionalProperties: false,\n  required: [...userDataSchema.required, 'id'],\n  properties: {\n    ...userDataSchema.properties,\n    id: { type: 'number' }\n  }\n} as const\n\nexport type User = FromSchema\n```\n\n## References ​\nAssociated schemas can be initialized via the `$ref` keyword referencing the `$id` set during schema definition.In TypeScript, the referenced type needs to be added explicitly.ts\n```\nimport type { FromSchema } from '@feathersjs/schema'\n\nexport const userSchema = {\n  $id: 'User',\n  type: 'object',\n  additionalProperties: false,\n  required: ['email', 'password'],\n  properties: {\n    id: { type: 'number' },\n    email: { type: 'string' },\n    password: { type: 'string' }\n  }\n} as const\n\nexport type User = FromSchema\n\nexport const messageSchema = {\n  $id: 'Message',\n  type: 'object',\n  additionalProperties: false,\n  required: ['text'],\n  properties: {\n    text: { type: 'string' },\n    user: { $ref: 'User' }\n  }\n} as const\n\nexport type Message = FromSchema\n```\n\n## Query Helpers ​\nSchema ships with a few helpers to automatically create schemas that comply with the Feathers query syntax (like `$gt`, `$ne` etc.):\n### querySyntax ​\n`querySyntax(schema.properties, extensions)` initializes all properties the additional query syntax properties `$limit`, `$skip`, `$select` and `$sort`. `$select` and `$sort` will be typed so they only allow existing schema properties.ts\n```\nimport { querySyntax } from '@feathersjs/schema'\nimport type { FromSchema } from '@feathersjs/schema'\n\nexport const userQuerySchema = {\n  $id: 'UserQuery',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    ...querySyntax(userSchema.properties)\n  }\n} as const\n\nexport type UserQuery = FromSchema\n\nconst userQuery: UserQuery = {\n  $limit: 10,\n  $select: ['email', 'id'],\n  $sort: {\n    email: 1\n  }\n}\n```\nAdditional special query properties that are not already included in the query syntax like `$ilike` can be added like this:ts\n```\nimport { querySyntax } from '@feathersjs/schema'\nimport type { FromSchema } from '@feathersjs/schema'\n\nexport const userQuerySchema = {\n  $id: 'UserQuery',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    ...querySyntax(userSchema.properties, {\n      email: {\n        $ilike: {\n          type: 'string'\n        }\n      }\n    } as const)\n  }\n} as const\n\nexport type UserQuery = FromSchema\n\nconst userQuery: UserQuery = {\n  $limit: 10,\n  $select: ['email', 'id'],\n  $sort: {\n    email: 1\n  },\n  email: {\n    $ilike: '%@example.com'\n  }\n}\n```\n\n### queryProperty ​\n`queryProperty` helper takes a definition for a single property and returns a schema that allows the default query operators. This helper supports the operators listed, below. Learn what each one means in the common query operator documentation.`$gt`\n• `$gte`\n• `$lt`\n• `$lte`\n• `$ne`\n• `$in`\n• `$nin`\n\nThe `name` property in the example, below, shows how `query",
    "version": "v5",
    "tokens": [
      "json",
      "schema",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "alternative",
      "typebox",
      "feathersjs",
      "also",
      "provides",
      "the",
      "ability",
      "define",
      "plain",
      "schemas",
      "objects",
      "uses",
      "turn",
      "those",
      "into",
      "typescript",
      "types",
      "need",
      "help",
      "you",
      "can",
      "find",
      "introduction",
      "official",
      "getting",
      "started",
      "guide",
      "and",
      "lot",
      "type",
      "specific",
      "examples",
      "docs",
      "creating",
      "definitions",
      "are",
      "not",
      "familiar",
      "with",
      "have",
      "look",
      "here",
      "example",
      "for",
      "possible",
      "user",
      "import",
      "fromschema",
      "from",
      "export",
      "const",
      "userschema",
      "object",
      "additionalproperties",
      "false",
      "required",
      "email",
      "password",
      "properties",
      "number",
      "string",
      "generating",
      "correct",
      "definition",
      "always",
      "needs",
      "declared",
      "this",
      "first",
      "will",
      "produce",
      "because",
      "immediately",
      "followed",
      "missing",
      "next",
      "does",
      "declare",
      "after",
      "generated",
      "correctly",
      "produces",
      "extending",
      "create",
      "new",
      "that",
      "extends",
      "existing",
      "one",
      "combine",
      "used",
      "userdataschema"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-schema-validators",
    "title": "Validators",
    "content": "Validators | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Validators ​\nAjv is the default JSON Schema validator used by `@feathersjs/schema`. We chose it because it's fully compliant with the JSON Schema spec and it's the fastest JSON Schema validator because it has its own compiler. It pre-compiles code for each validator, instead of dynamically creating validators from schemas during runtime.ImportantAjv and most other validation libraries are only used for ensuring data is valid and are not designed to convert data to different types. Type conversions and populating data can be done using resolvers. This ensures a clean separation of concern between validating and populating data.\n## Usage ​\nThe following is the standard `validators.ts` file that sets up a validator for data and queries (for which string types will be coerced automatically). It also sets up a collection of additional formats using ajv-formats. The validators in this file can be customized according to the Ajv documentation and its plugins. You can find the available Ajv options in the Ajv class API docs.ts\n```\nimport { Ajv, addFormats } from '@feathersjs/schema'\nimport type { FormatsPluginOptions } from '@feathersjs/schema'\n\nconst formats: FormatsPluginOptions = [\n  'date-time',\n  'time',\n  'date',\n  'email',\n  'hostname',\n  'ipv4',\n  'ipv6',\n  'uri',\n  'uri-reference',\n  'uuid',\n  'uri-template',\n  'json-pointer',\n  'relative-json-pointer',\n  'regex'\n]\n\nexport const dataValidator = addFormats(new Ajv({}), formats)\n\nexport const queryValidator = addFormats(\n  new Ajv({\n    coerceTypes: true\n  }),\n  formats\n)\n```\n\n## Validation functions ​\nA validation function takes data and validates them against a schema using a validator. They can be used with any validation library. Currently the `getValidator` functions are available for:TypeBox schema to validate a TypeBox definition using an Ajv validator instance\n• JSON schema to validate a JSON schema object using an Ajv validator instance\n\n## Hooks ​\n\nThe following hooks take a validation function and validate parts of the hook context.\n\n### validateData ​\n\n`schemaHooks.validateData` takes a validation function and allows to validate the `data` in a `create`, `update` and `patch` request as well as custom service methods. It can be used as an `around` or `before` hook.\n\nts\n```\nimport { Ajv, hooks as schemaHooks } from '@feathersjs/schema'\nimport { Type, getValidator } from '@feathersjs/typebox'\nimport type { Static } from '@feathersjs/typebox'\nimport { dataValidator } from '../validators'\n\nconst userSchema = Type.Object(\n  {\n    id: Type.Number(),\n    email: Type.String(),\n    password: Type.String(),\n    avatar: Type.Optional(Type.String())\n  },\n  { $id: 'User', additionalProperties: false }\n)\ntype User = Static\n\nconst userDataSchema = Type.Pick(userSchema, ['email', 'password'])\n\n// Returns validation functions for `create`, `update` and `patch`\nconst userDataValidator = getValidator(userDataSchema, dataValidator)\n\napp.service('users').hooks({\n  before: {\n    all: [schemaHooks.validateData(userDataValidator)]\n  }\n})\n```\n\n### validateQuery ​\n\n`schemaHooks.validateQuery` takes a validation function and validates the `query` of a request. It can be used as an `around` or `before` hook. When using the `queryValidator` from the usage section, strings will automatically be converted to the right type using Ajv's type coercion rules.\n\nts\n```\nimport { Ajv, schemaHooks } from '@feathersjs/schema'\nimport { Type, getValidator } from '@feathersjs/typebox'\nimport { queryValidator } from '../validators'\n\n// Schema for allowed query properties\nconst messageQueryProperties = Type.Pick(messageSchema, ['id', 'text', 'createdAt', 'userId'], {\n  additionalProperties: false\n})\nconst messageQuerySchema = querySyntax(messageQueryProperties)\ntype MessageQuery = Static\n\nconst messageQueryValidator = getValidator(messageQuerySchema, queryValidator)\n\napp.service('messages').hooks({\n  around: {\n    all: [schemaHooks.validateQuery(messageQueryValidator)]\n  }\n})\n```\n\n### Using validators with custom methods ​\n\nYou can optionally create validators for your custom methods. For example we will create a custom method in our `user` service that simply says \"Hello ${name}\" to the requestor.\n\nFor the example we can use this TypeBox schema\n\nts\n```\n//Our request object, we expect something like {name: \"Bob\"}\nexport const sayHelloRequest = Type.Object(\n  {\n    name: Type.String({\n      description: \"Who are we saying hello to!\",\n      examples: [\"Bob\"],\n      minLength: 2,\n    }),\n  },\n  { $id: \"sayHelloRequest\", additionalProperties: false },\n);\n\n//We intend on returning an object with a string response property\nexport const sayHelloResponse = Type.Object(\n  { response: Type.String() },\n  { $id: \"sayHelloResponse\", additionalProperties: false },\n);\n\nexport const sayHelloValidator = getValidator(sayHelloRequest, dataValidator);\n```\n\nIn our user class file, we can define our custom method\n",
    "version": "v5",
    "tokens": [
      "validators",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "ajv",
      "the",
      "default",
      "json",
      "schema",
      "validator",
      "used",
      "feathersjs",
      "chose",
      "because",
      "fully",
      "compliant",
      "with",
      "spec",
      "and",
      "fastest",
      "has",
      "its",
      "own",
      "compiler",
      "pre",
      "compiles",
      "code",
      "for",
      "each",
      "instead",
      "dynamically",
      "creating",
      "from",
      "schemas",
      "during",
      "runtime",
      "importantajv",
      "most",
      "other",
      "validation",
      "libraries",
      "are",
      "only",
      "ensuring",
      "data",
      "valid",
      "not",
      "designed",
      "convert",
      "different",
      "types",
      "type",
      "conversions",
      "populating",
      "can",
      "done",
      "using",
      "resolvers",
      "this",
      "ensures",
      "clean",
      "separation",
      "concern",
      "between",
      "validating",
      "usage",
      "following",
      "standard",
      "file",
      "that",
      "sets",
      "queries",
      "which",
      "string",
      "will",
      "coerced",
      "automatically",
      "also",
      "collection",
      "additional",
      "formats",
      "customized",
      "according",
      "documentation",
      "plugins",
      "you",
      "find",
      "available",
      "options",
      "class",
      "api",
      "docs",
      "import",
      "addformats",
      "formatspluginoptions",
      "const",
      "date",
      "time",
      "email",
      "hostname",
      "ipv4",
      "ipv6",
      "uri",
      "reference",
      "uuid",
      "template",
      "pointer",
      "relative",
      "regex",
      "export",
      "datavalidator",
      "new",
      "queryvalidator",
      "coercetypes",
      "true",
      "functions",
      "function",
      "takes",
      "validates",
      "them",
      "against",
      "they",
      "any",
      "library",
      "currently",
      "getvalidator",
      "typebox",
      "validate",
      "definition",
      "instance",
      "schem"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v5-api-schema-resolvers",
    "title": "Resolvers",
    "content": "Resolvers | feathers\n    \n    \n    • Skip to contentfeathersSearchMetaKAppearanceMenuReturn to top\n# Resolvers ​\nResolvers dynamically resolve individual properties based on a context, in a Feathers application usually the hook context.This provide a flexible way to do things like:Populating associations\n• Returning computed properties\n• Securing queries and e.g. limiting requests for a user\n• Setting context (e.g. logged in user or organization) specific default values\n• Removing protected properties for external requests\n• Add read- and write permissions on the property level\n• Hashing passwords and validating dynamic password policies\n\nYou can create a resolver for any data type and resolvers can also be used outside of Feathers.\n\n## Example ​\n\nHere is an example for a standalone resolver using a custom context:\n\nts\n```\nimport { resolve } from '@feathersjs/schema'\n\ntype User = {\n  id: number\n  name: string\n}\n\ntype Message = {\n  id: number\n  userId: number\n  likes: number\n  text: string\n  user: User\n}\n\nclass MyContext {\n  getUser(id) {\n    return {\n      id,\n      name: 'David'\n    }\n  }\n\n  getLikes(messageId) {\n    return 10\n  }\n}\n\nconst messageResolver = resolve({\n  likes: (value, message, context) => {\n    return context.getLikes(message.id)\n  },\n  user: (value, message, context) => {\n    return context.getUser(message.userId)\n  }\n})\n\nconst resolvedMessage = await messageResolver.resolve(\n  {\n    id: 1,\n    userId: 23,\n    text: 'Hello!'\n  },\n  new MyContext()\n)\n```\n\n## Property resolvers ​\n\nProperty resolvers are a map of property names to resolver functions. A resolver function is an `async` or regular function that resolves a property on a data object. If it returns `undefined` the property will not be included. It gets passed the following parameters:\n• `value` - The current value which can also be `undefined`\n• `data` - The initial data object\n• `context` - The context for this resolver\n• `status` - Additional status information like current property resolver path, the properties that should be resolved or a reference to the initial context.\n\nts\n```\nconst userResolver = resolve({\n  isDrinkingAge: async (value, user, context) => {\n    const drinkingAge = await context.getDrinkingAge(user.country)\n\n    return user.age >= drinkingAge\n  },\n  fullName: (value, user, context) => {\n    return `${user.firstName} ${user.lastName}`\n  }\n})\n```\n\ndanger\n\nProperty resolver functions should only return a value and not have side effects. This means a property resolver should not do things like create new data or modify the `data` or `context` object. Hooks should be used for side effects.\n\n## Virtual property resolvers ​\n\nVirtual resolvers are property resolvers that do not use the `value` but instead always return a value of their own. The parameters are (`(data, context, status)`). The above example can be written like this:\n\nts\n```\nimport { resolve, virtual } from '@feathersjs/schema'\n\nconst userResolver = resolve({\n  isDrinkingAge: virtual(async (user, context) => {\n    const drinkingAge = await context.getDrinkingAge(user.country)\n\n    return user.age >= drinkingAge\n  }),\n  fullName: virtual((user, context) => {\n    return `${user.firstName} ${user.lastName}`\n  })\n})\n```\n\nImportant\n\nVirtual resolvers should always be used when combined with a database adapter in order to make valid $select queries. Otherwise queries could try to select fields that do not exist in the database which will throw an error.\n\n## Options ​\n\nA resolver takes the following options as the second parameter:\n• `converter` (optional): A `(data, context) => {}` or `async (data, context) => {}` function that can return a completely new representation of the data. A `converter` runs before `properties` resolvers.\n\nts\n```\nconst userResolver = resolve(\n  {\n    isDrinkingAge: async (value, user, context) => {\n      const drinkingAge = await context.getDrinkingAge(user.country)\n\n      return user.age >= drinkingAge\n    },\n    fullName: async (value, user, context) => {\n      return `${user.firstName} ${user.lastName}`\n    }\n  },\n  {\n    // Convert the raw data into a new structure before running property resolvers\n    converter: async (rawData, context) => {\n      return {\n        firstName: rawData.data.first_name,\n        lastName: rawData.data.last_name\n      }\n    }\n  }\n)\n```\n\n## Hooks ​\n\nIn a Feathers application, resolvers are used through hooks to convert service `query`, `data` and `response`. The context for these resolvers is always the hook context.\n\n### resolveData ​\n\nData resolvers use the `hooks.resolveData(...resolvers)` hook and convert the `data` from a `create`, `update` or `patch` service method or a custom method. This can be used to validate against the schema and e.g. hash a password before storing it in the database or to remove properties the user is not allowed to write. It is possible to pass multiple objects containing resolvers which will run in the order they are passed. Subsequent resolver objects will receive the ",
    "version": "v5",
    "tokens": [
      "resolvers",
      "feathers",
      "skip",
      "contentfeatherssearchmetakappearancemenureturn",
      "top",
      "dynamically",
      "resolve",
      "individual",
      "properties",
      "based",
      "context",
      "application",
      "usually",
      "the",
      "hook",
      "this",
      "provide",
      "flexible",
      "way",
      "things",
      "like",
      "populating",
      "associations",
      "returning",
      "computed",
      "securing",
      "queries",
      "and",
      "limiting",
      "requests",
      "for",
      "user",
      "setting",
      "logged",
      "organization",
      "specific",
      "default",
      "values",
      "removing",
      "protected",
      "external",
      "add",
      "read",
      "write",
      "permissions",
      "property",
      "level",
      "hashing",
      "passwords",
      "validating",
      "dynamic",
      "password",
      "policies",
      "you",
      "can",
      "create",
      "resolver",
      "any",
      "data",
      "type",
      "also",
      "used",
      "outside",
      "example",
      "here",
      "standalone",
      "using",
      "custom",
      "import",
      "from",
      "feathersjs",
      "schema",
      "number",
      "name",
      "string",
      "message",
      "userid",
      "likes",
      "text",
      "class",
      "mycontext",
      "getuser",
      "return",
      "david",
      "getlikes",
      "messageid",
      "const",
      "messageresolver",
      "value",
      "resolvedmessage",
      "await",
      "hello",
      "new",
      "are",
      "map",
      "names",
      "functions",
      "function",
      "async",
      "regular",
      "that",
      "resolves",
      "object",
      "returns",
      "undefined",
      "will",
      "not",
      "included",
      "gets",
      "passed",
      "following",
      "parameters",
      "current",
      "which",
      "initial",
      "status",
      "additional",
      "information",
      "prop"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v4-api-application",
    "title": "Application",
    "content": "# Application npm install @feathersjs/feathers --save",
    "version": "v4",
    "tokens": [
      "application",
      "npm",
      "install",
      "feathersjs",
      "feathers",
      "save"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v4-api-events",
    "title": "Events",
    "content": "# Events Events are the key part of Feathers real-time functionality. All events in Feathers are provided through the NodeJS EventEmitter (opens new window) interface. This section describes A quick overview of the NodeJS EventEmitter interface The standard service events How to allow sending custom events from the server to the client Important: For more information on how to send real-time events to clients, see the Channels chapter . # EventEmitters Once registered, any service gets turned into a standard NodeJS EventEmitter (opens new window) and can be used accordingly. const messages = app . service ( 'messages' ) ; // Listen to a normal service event messages . on ( 'patched' , message => console . log ( 'message patched' , message ) ) ; // Only listen to an event once messsages . once ( 'removed' , message => console . log ( 'First time a message has been removed' , message ) ) ; // A reference to a handler const onCreatedListener = message => console . log ( 'New message created' , message ) ; // Listen `created` with a handler reference messages . on ( 'created' , onCreatedListener ) ; // Unbind the `created` event listener messages . removeListener ( 'created' , onCreatedListener ) ; // Send a custom event messages . emit ( 'customEvent' , { type : 'customEvent' , data : 'can be anything' } ) ;",
    "version": "v4",
    "tokens": [
      "events",
      "are",
      "the",
      "key",
      "part",
      "feathers",
      "real",
      "time",
      "functionality",
      "all",
      "provided",
      "through",
      "nodejs",
      "eventemitter",
      "opens",
      "new",
      "window",
      "interface",
      "this",
      "section",
      "describes",
      "quick",
      "overview",
      "standard",
      "service",
      "how",
      "allow",
      "sending",
      "custom",
      "from",
      "server",
      "client",
      "important",
      "for",
      "more",
      "information",
      "send",
      "clients",
      "see",
      "channels",
      "chapter",
      "eventemitters",
      "once",
      "registered",
      "any",
      "gets",
      "turned",
      "into",
      "and",
      "can",
      "used",
      "accordingly",
      "const",
      "messages",
      "app",
      "listen",
      "normal",
      "event",
      "patched",
      "message",
      "console",
      "log",
      "only",
      "messsages",
      "removed",
      "first",
      "has",
      "been",
      "reference",
      "handler",
      "oncreatedlistener",
      "creat"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v4-api-errors",
    "title": "Errors",
    "content": "# Errors (opens new window) (opens new window) npm install @feathersjs/errors --save",
    "version": "v4",
    "tokens": [
      "errors",
      "opens",
      "new",
      "window",
      "npm",
      "install",
      "feathersjs",
      "save"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v4-api-configuration",
    "title": "Configuration",
    "content": "# Configuration (opens new window) (opens new window) npm install @feathersjs/configuration --save",
    "version": "v4",
    "tokens": [
      "configuration",
      "opens",
      "new",
      "window",
      "npm",
      "install",
      "feathersjs",
      "save"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v4-api-express",
    "title": "Express",
    "content": "# Express (opens new window) (opens new window) npm install @feathersjs/express --save",
    "version": "v4",
    "tokens": [
      "express",
      "opens",
      "new",
      "window",
      "npm",
      "install",
      "feathersjs",
      "save"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v4-api-channels",
    "title": "Channels",
    "content": "# Channels On a Feathers server with a real-time transport ( Socket.io or Primus ) set up, event channels determine which connected clients to send real-time events to and how the sent data should look like. This chapter describes: Real-time Connections and how to access them Channel usage and how to retrieve, join and leave channels Publishing events to channels Important: If you are not using a real-time transport server (e.g. when making a REST only API or using Feathers on the client), channel functionality is not going to be available. Some examples where channels are used: Real-time events should only be sent to authenticated users Users should only get updates about messages if they joined a certain chat room Only users in the same organization should receive real-time updates about their data changes Only admins should be notified when new users are created When a user is created, modified or removed, non-admins should only receive a \"safe\" version of the user object (e.g. only email , id and avatar ) # Concepts When using channels, the server pushes events (such as \"created\", \"removed\" etc. for a particular service) down to its clients via channels . The client doesn’t listen to individual channels directly, but rather subscribes to specific events on services that it is interested in. Those events will only fire on the client if the server pushes data to one or more channels that the client has been added to. You can have any number of channels. This helps to organise how data is sent and to control the volume of data, by not sending things that aren't relevant. When a new client connects, the server explicitly adds that connection to any relevant channels. This is how clients are given access to events that they are allowed to see. The server can also change connection channel membership from time to time, eg before vs after login. The server needs to explicitly publish channels it is interested in sharing with clients before they become available. # Example The example below shows the generated channels.js file illustrating how the different parts fit together: module . exports = function ( app ) { if ( typeof app . channel !== 'function' ) { // If no real-time functionality has been configured just return return ; } app . on ( 'connection' , connection => { // On a new real-time connection, add it to the anonymous channel app . channel ( 'anonymous' ) . join ( connection ) ; } ) ; app . on ( 'login' , ( authResult , { connection } ) => { // connection can be undefined if there is no // real-time connection, e.g. when logging in via REST if ( connection ) { // Obtain the logged in user from the connection // const user = connection.user; // The connection is no longer anonymous, remove it app . channel ( 'anonymous' ) . leave ( connection ) ; // Add it to the authenticated user channel app . channel ( 'authenticated' ) . join ( connection ) ; // Channels can be named anything and joined on any condition // E.g. to send real-time event",
    "version": "v4",
    "tokens": [
      "channels",
      "feathers",
      "server",
      "with",
      "real",
      "time",
      "transport",
      "socket",
      "primus",
      "set",
      "event",
      "determine",
      "which",
      "connected",
      "clients",
      "send",
      "events",
      "and",
      "how",
      "the",
      "sent",
      "data",
      "should",
      "look",
      "like",
      "this",
      "chapter",
      "describes",
      "connections",
      "access",
      "them",
      "channel",
      "usage",
      "retrieve",
      "join",
      "leave",
      "publishing",
      "important",
      "you",
      "are",
      "not",
      "using",
      "when",
      "making",
      "rest",
      "only",
      "api",
      "client",
      "functionality",
      "going",
      "available",
      "some",
      "examples",
      "where",
      "used",
      "authenticated",
      "users",
      "get",
      "updates",
      "about",
      "messages",
      "they",
      "joined",
      "certain",
      "chat",
      "room",
      "same",
      "organization",
      "receive",
      "their",
      "changes",
      "admins",
      "notified",
      "new",
      "created",
      "user",
      "modified",
      "removed",
      "non",
      "safe",
      "version",
      "object"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v4-api-client",
    "title": "Feathers Client",
    "content": "# Feathers Client One of the most notable features of Feathers is that it can also be used as the client. In contrast with most other frameworks, it isn't a separate library; instead you get the exact same functionality with a client and on a server. This means you can use services and hooks and configure plugins. By default, a Feathers client automatically creates services that talk to a Feathers server. In order to connect to a Feathers server, a client creates Services that use a REST or websocket connection to relay method calls and allow listening to events on the server. This means the Feathers application instance is usable the exact same way as on the server. Modules most relevant on the client are: @feathersjs/feathers to initialize a new Feathers application @feathersjs/rest-client to connect to services through REST HTTP . @feathersjs/socketio-client to connect to services through Socket.io . @feathersjs/primus-client to connect to services through Primus . @feathersjs/authentication-client to authenticate a client Important: You do not have to use Feathers on the client to connect to a Feathers server. The client chapters above also describe how to use a REST HTTP, Socket.io or Primus connection directly without Feathers on the client side. For details on authentication, see the Authentication client chapter . This chapter describes how to set up Feathers as the client in Node, React Native and in the browser with a module loader like Webpack or Browserify or through a <script> tag. The examples are using the Socket.io client . For other connection methods see the chapters linked above. Important: Feathers can be used on the client through the individual modules or the @feathersjs/client module. The latter combines all modules mentioned above into a single, ES5 transpiled version. # Node To connect to a Feathers server in NodeJS, install the desired client connection library (here, socket.io-client ), alongside the Feathers core library, and the connection-specific library: npm install @feathersjs/feathers @feathersjs/socketio-client socket.io-client --save",
    "version": "v4",
    "tokens": [
      "feathers",
      "client",
      "one",
      "the",
      "most",
      "notable",
      "features",
      "that",
      "can",
      "also",
      "used",
      "contrast",
      "with",
      "other",
      "frameworks",
      "isn",
      "separate",
      "library",
      "instead",
      "you",
      "get",
      "exact",
      "same",
      "functionality",
      "and",
      "server",
      "this",
      "means",
      "use",
      "services",
      "hooks",
      "configure",
      "plugins",
      "default",
      "automatically",
      "creates",
      "talk",
      "order",
      "connect",
      "rest",
      "websocket",
      "connection",
      "relay",
      "method",
      "calls",
      "allow",
      "listening",
      "events",
      "application",
      "instance",
      "usable",
      "way",
      "modules",
      "relevant",
      "are",
      "feathersjs",
      "initialize",
      "new",
      "through",
      "http",
      "socketio",
      "socket",
      "primus",
      "authe"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v4-api-socketio",
    "title": "Socket.io",
    "content": "# Socket.io (opens new window) (opens new window) npm install @feathersjs/socketio --save",
    "version": "v4",
    "tokens": [
      "socket",
      "opens",
      "new",
      "window",
      "npm",
      "install",
      "feathersjs",
      "socketio",
      "save"
    ],
    "category": "core-concepts"
  },
  {
    "id": "v4-api-primus",
    "title": "Primus",
    "content": "# Primus (opens new window) (opens new window) npm install @feathersjs/primus --save",
    "version": "v4",
    "tokens": [
      "primus",
      "opens",
      "new",
      "window",
      "npm",
      "install",
      "feathersjs",
      "save"
    ],
    "category": "core-concepts"
  }
]
